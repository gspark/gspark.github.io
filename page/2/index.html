<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2021-05-25T07:19:23.000Z" title="2021-05-25T07:19:23.000Z">2021-05-25</time>发表</span><span class="level-item"><time datetime="2021-05-25T07:53:28.922Z" title="2021-05-25T07:53:28.922Z">2021-05-25</time>更新</span><span class="level-item">4 分钟读完 (大约528个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/05/25/pacman%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%87%E5%BF%98/">pacman常用命令备忘</a></h1><div class="content"><p>Pacman 是 Arch Linux 的包管理器。msys2 也采用 Pacman做包管理。</p><h2 id="修改镜像"><a class="markdownIt-Anchor" href="#修改镜像"></a> 修改镜像</h2><p>修改 etc\pacman.d\mirrorlist.mingw32 等文件，将</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/msys2/mingw/x86_64/</span><br></pre></td></tr></table></figure><p>移到 <code>Server = https://repo.msys2.org/mingw/x86_64/</code> 之前。</p><h2 id="更新系统"><a class="markdownIt-Anchor" href="#更新系统"></a> 更新系统</h2><p>可使用如下命令更新:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu</span><br></pre></td></tr></table></figure><p>如果你已经使用 <code>pacman -Sy</code> 将本地的包数据库与远程的仓库进行了同步，也可以只执行：<code>pacman -Su</code>。</p><p>在 pacman 5.0.1.6403 以后的版本执行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syuu</span><br></pre></td></tr></table></figure><p>更新已安装包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Suu</span><br></pre></td></tr></table></figure><h2 id="安装包"><a class="markdownIt-Anchor" href="#安装包"></a> 安装包</h2><p><code>pacman -S</code> + 包名：例如，执行 pacman -S firefox 将安装 Firefox。你也可以同时安装多个包，<br>只需以空格分隔包名即可。<br><code>pacman -Sy</code> + 包名：与上面命令不同的是，该命令将在同步包数据库后再执行安装。<br><code>pacman -Sv</code> + 包名：在显示一些操作信息后执行安装。<br><code>pacman -U</code> + 本地包名，其扩展名为 pkg.tar.gz。<br><code>pacman -U</code> + <a target="_blank" rel="noopener" href="http://www.example.com/repo/example.pkg.tar.xz%EF%BC%8C%E5%AE%89%E8%A3%85%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E5%8C%85%EF%BC%88%E4%B8%8D%E5%9C%A8">http://www.example.com/repo/example.pkg.tar.xz，安装一个远程包（不在</a> pacman 配置的源里面）</p><h2 id="删除包"><a class="markdownIt-Anchor" href="#删除包"></a> 删除包</h2><p><code>pacman -R</code> + 包名：该命令将只删除包，保留其全部已经安装的依赖关系<br><code>pacman -Rs</code> + 包名：在删除包的同时，删除其所有没有被其他已安装软件包使用的依赖关系<br><code>pacman -Rsc</code> + 包名：在删除包的同时，删除所有依赖这个软件包的程序<br><code>pacman -Rd</code> + 包名：在删除包时不检查依赖。</p><h2 id="搜索包"><a class="markdownIt-Anchor" href="#搜索包"></a> 搜索包</h2><p><code>pacman -Ss</code> + 关键字：在仓库中搜索含关键字的包。<br><code>pacman -Qs</code> + 关键字： 搜索已安装的包。<br><code>pacman -Qi</code> + 包名：查看有关包的详尽信息。<br><code>pacman -Ql</code> + 包名：列出该包的文件。</p><h2 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它</h2><p><code>pacman -Sw</code> + 包名：只下载包，不安装。<br><code>pacman -Sc</code> 清理未安装的包文件，包文件位于 /var/cache/pacman/pkg/ 目录。<br><code>pacman -Scc</code> 清理所有的缓存文件。<br><code>pacman -Qqdt</code> 列出可以清理的包。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-12-23T09:03:52.000Z" title="2020-12-23T09:03:52.000Z">2020-12-23</time>发表</span><span class="level-item"><time datetime="2020-12-24T01:46:56.636Z" title="2020-12-24T01:46:56.636Z">2020-12-24</time>更新</span><span class="level-item">4 分钟读完 (大约658个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/23/Java-send-mail/">Java send mail</a></h1><div class="content"><p>使用 Java 发送电子邮件主要有两个方法，一个是使用 sun 公司的 mail 包，另一个是使用 SpringBoot。SpringBoot 的封装更简单。<br>这里简单介绍使用 SpringBoot 发送邮件的方法和使用时的注意点。</p><h2 id="smtpsmtps-协议"><a class="markdownIt-Anchor" href="#smtpsmtps-协议"></a> SMTP/SMTPS 协议</h2><p>SMTP（Simple Mail Transfer Protocal）称为简单邮件传输协议。SMTP 是一个请求/响应协议，它监听25号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。<br>SMTPS（SMTP-over-SSL）为 SMTP 协议基于 SSL 安全协议之上的一种变种协议。它继承了 SSL 安全协议的非对称加密的高度安全可靠性，可防止邮件泄露。</p><p>如今绝大多数邮件服务器都使用 SMTP/SMTPS 协议。</p><h2 id="引入依赖库"><a class="markdownIt-Anchor" href="#引入依赖库"></a> 引入依赖库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续查看 spring-boot-starter-mail 的依赖树可以发现，它是对 sun 公司的 mail 包进行了封装。</p><h2 id="参数配置"><a class="markdownIt-Anchor" href="#参数配置"></a> 参数配置</h2><p>在 application.yml 里进行邮件发送的相关参数配置，示例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">mail.163.com</span> <span class="comment">#发送邮件服务器</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxx@163.com</span> <span class="comment">#发送邮件的邮箱地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">xXx@163.com</span> <span class="comment"># 发送邮件的地址，和上面username一致</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">sss@163.com</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtps</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">test-connection:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面的配置有几个需要注意的点：</p><ol><li>password 是客户端授权码，有客户端授权码填授权码，没有的话，填发送邮箱的密码。</li><li>protocol 需要填写。<br><strong>邮件服务器采用 SMTPS 发送协议，protocol 的值要写成 smtps；如果采用 SMTP，则要写成 smtp。</strong></li><li>port 的键是 spring.mail.port<br><strong>有些文章将 port 的键写成了 spring.mail.properties.mail.smtp.port，这可能是 SpringBoot 的版本原因，注意区分。</strong></li></ol><h2 id="封装接口实现发送"><a class="markdownIt-Anchor" href="#封装接口实现发送"></a> 封装接口实现发送</h2><p>封装 Service 实现邮件发送，一个简单的示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.to:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文本邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to      收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTextMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        <span class="comment">// 发送对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != to &amp;&amp; to.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                message.setTo(to.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                message.setTo(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message.setTo(from);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邮件主题</span></span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        <span class="comment">// 邮件内容</span></span><br><span class="line">        message.setText(content);</span><br><span class="line">        <span class="comment">// 邮件的发起者</span></span><br><span class="line">        message.setFrom(from);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaMailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (org.springframework.mail.MailSendException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;error:&quot;</span> + from, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 JavaMailSender，JavaMailSender 实现了邮件发送。上例是发送文本邮件，可发送多个人。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-12-07T07:44:40.000Z" title="2020-12-07T07:44:40.000Z">2020-12-07</time>发表</span><span class="level-item"><time datetime="2020-12-16T03:26:02.172Z" title="2020-12-16T03:26:02.172Z">2020-12-16</time>更新</span><span class="level-item">11 分钟读完 (大约1593个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/07/%E4%BC%AA%E5%85%B1%E4%BA%AB%E5%92%8CJava%E7%BC%93%E5%AD%98%E8%A1%8C/">伪共享和Java缓存行</a></h1><div class="content"><p>对于多线程编程来说，一般要注意线程安全的问题，如果是要实现超高并发的中间件，特别是需要多线程处理列表、数组和队列的时候，就需要注意伪共享的问题。否则可能无法发挥多线程的优势，性能可能比单线程还差。</p><h2 id="伪共享"><a class="markdownIt-Anchor" href="#伪共享"></a> 伪共享</h2><p>介绍伪共享前先说说 SMP、Cache、MESI 几个概念。</p><h3 id="smp-系统"><a class="markdownIt-Anchor" href="#smp-系统"></a> SMP 系统</h3></div><a class="article-more button is-small is-size-7" href="/2020/12/07/%E4%BC%AA%E5%85%B1%E4%BA%AB%E5%92%8CJava%E7%BC%93%E5%AD%98%E8%A1%8C/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-08-17T08:02:38.000Z" title="2020-08-17T08:02:38.000Z">2020-08-17</time>发表</span><span class="level-item"><time datetime="2020-08-18T09:08:49.148Z" title="2020-08-18T09:08:49.148Z">2020-08-18</time>更新</span><span class="level-item">7 分钟读完 (大约1074个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/17/%E4%BD%BF%E7%94%A8Java8%E7%9A%84Optional%E7%9A%84%E6%80%9D%E8%80%83/">使用Java8的Optional的思考</a></h1><div class="content"><p>Optional 是 Java 8 引入的一个工具类，也是 Java 8 的新特性之一。在 Stream API 中很多地方也都使用到了 Optional。<br>空指针异常（NullPointerExceptions）是 Java 最常见的异常之一。程序员不得不在代码中写很多 null 的检查逻辑，让代码看起来非常臃肿；由于其属于运行时异常，非常难以预判的。<br>为了预防空指针异常，Google 的 Guava 项目率先引入 Optional 类，通过使用检查空值的方式来防止代码污染，受到 Guava 项目的启发，Java 8 中引入了 Optional 类。那在使用 Optional 上有那些值得思考和注意的地方呢。</p><h2 id="ispresent-和-get-的思考"><a class="markdownIt-Anchor" href="#ispresent-和-get-的思考"></a> isPresent() 和 get() 的思考</h2><p>虽然官方文档说明中对 Optional 的描述是：<code>If a value is present, isPresent() will return true and get() will return the value</code>。我们就调用 isPresent() 和 get() 来避免 NullPointException 好了，但如果只是简单的认为它可以解决 NPE 的问题, 于是代码就会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student = ......</span><br><span class="line"><span class="keyword">if</span> (student.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> student.get().getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种写法这与我们之前写成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> .....</span><br><span class="line"><span class="keyword">if</span> (student != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> student.getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上是没有区别的。</p><p>虽然说使用 ifPresent(Consumer&lt;? super T&gt; consumer) 来替代 isPresent() 要好一些，但是 Consumer 的 accept 函数的返回值是 void 类型，接受单个输入参数且不返回结果的操作，有使用上的限制。</p><p>所以，如果我们在使用 Optional 时，如果有需要调用 isPresent() 和 get() 的地方，那就该重新审视一下，是否真的有必要使用 Optional。</p><h2 id="不要将-optional-作为函数参数"><a class="markdownIt-Anchor" href="#不要将-optional-作为函数参数"></a> 不要将 Optional 作为函数参数</h2><p>把 Optional 类型用作函数参数在 IntelliJ IDEA 中是强力不推荐的。这该怎么理解呢？Optional 对象是一个容器对象，它包含的对象是否是空，是不确定的。<br>函数作为被调用者，它根据传入的参数进行逻辑运算，那么传给它的参数应该是明确的。</p><p>参数不为 Optional 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    func2(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (student == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    student.setId(getId());</span><br><span class="line">    <span class="keyword">return</span> insertStudent(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数为 Optional 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    func2(Optional.ofNullable(student));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(Optional&lt;Student&gt; studentOpt)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentOpt.orElse(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    student.setId(getId());</span><br><span class="line">    <span class="keyword">return</span> insertStudent(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上两个例子，如果 Optional 为参数的话，按照后一个例子的写法，func2 的逻辑就改变了。<br>如果要逻辑一致的话，就又会使调用到 isPresent() 和 get() 方法，这样就不如不使用 Optional 更为直接。</p><h2 id="不要将-optional-作为字段类型"><a class="markdownIt-Anchor" href="#不要将-optional-作为字段类型"></a> 不要将 Optional 作为字段类型</h2><p>不要将 Optional 作为字段类型有两个原因：</p><ol><li>Optional 包含的对象是不确定的<br>不确定的数据作为字段值没有什么意义，应该审视是否有更好的设计。</li><li>Optional 不能支持序列化<br>Optional 作为字段类型,如果对象需要被序列化，将会出现异常<code>Exception in thread &quot;main&quot; java.io.NotSerializableException</code>。</li></ol><h2 id="optional-使用举例"><a class="markdownIt-Anchor" href="#optional-使用举例"></a> Optional 使用举例</h2><p>除了上述几个场景外，在需要处理 null 的地方，采用 Optional 还是比较好的选择。Optional 虽不能完全杜绝 NPE，但是它能相对优雅的预防 NPE。<br>比如我们可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; studentOpt = Optional.ofNullable(student);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> studentOpt.orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>Optional.ofNullable(obj)：以一种宽容的方式来构造一个 Optional 实例。传 null 进到就得到 Optional.empty(), 非 null 就调用 Optional.of(obj)。<strong>Optional.of(obj) 是可能抛出 NPE的，如果参数 obj 为 null 的话。</strong><br>Optional.orElse()：存在即返回, 无则提供默认值。</p><p>这样看起来比之前的写法要简单很多，改写成一行，更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Optional.ofNullable(student).orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如我们还可以这样，将 Steam 与 Optional 结合起来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(Collection&lt;Integer&gt; studentIds)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> studentIds.stream()</span><br><span class="line">        <span class="comment">//此处 getStudentById 返回的是 Optional&lt;Student&gt;</span></span><br><span class="line">        .map(<span class="built_in">this</span>::getStudentById)     <span class="comment">// 获得 Stream&lt;Optional&lt;Student&gt;&gt;</span></span><br><span class="line">        .filter(Optional::isPresent)   <span class="comment">// 去掉不包含值的 Optional</span></span><br><span class="line">        .map(Optional::get)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 的 Optional 除了上述的一些方法，还有一些其它的，像 flatMap 和 orElseThrow 等，可以详细了解一下，找到合适的使用场景。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-08-12T08:54:04.000Z" title="2020-08-12T08:54:04.000Z">2020-08-12</time>发表</span><span class="level-item"><time datetime="2020-08-12T09:55:15.104Z" title="2020-08-12T09:55:15.104Z">2020-08-12</time>更新</span><span class="level-item">3 分钟读完 (大约468个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/12/maven%E5%88%A9%E7%94%A8%E6%8F%92%E4%BB%B6antrun%E4%BD%BF%E7%94%A8if%E6%9D%A1%E4%BB%B6%E6%A0%87%E7%AD%BE/">maven利用插件antrun使用if条件标签</a></h1><div class="content"><p>利用 maven 对项目打包的时候，有时候需要根据条件选择不同的文件或输出到不同路径，因此希望 maven 能够提供 <code>if</code> 标签，maven 的 antrun 插件可以提供 <code>if</code> 标签。</p><h2 id="antrun-简介"><a class="markdownIt-Anchor" href="#antrun-简介"></a> antrun 简介</h2><p>通过 antrun 插件可以在 maven 中运行 ant task，可以在 POM 文件中嵌入 ant 脚本。具体参考 <a target="_blank" rel="noopener" href="http://maven.apache.org/plugins/maven-antrun-plugin">antrun</a>。</p><h2 id="使用-antrun"><a class="markdownIt-Anchor" href="#使用-antrun"></a> 使用 antrun</h2><p>可像如下格式使用 antrun</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  [...]</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span> <span class="comment">&lt;!-- a lifecycle phase --&gt;</span> <span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">                  在这里添加 ant task， 所有能在 ant 的 build.xml 的&lt;target&gt;标签里的都可以出现这里</span></span><br><span class="line"><span class="comment">                --&gt;</span></span><br><span class="line"></span><br><span class="line">              <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">  [...]</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用-if-标签"><a class="markdownIt-Anchor" href="#使用-if-标签"></a> 使用 if 标签</h2><p>要使用 if 标签，需要引入 Ant-Contrib，Ant-Contrib 是 ant 的一个任务集。配置例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span>&gt;</span></span><br><span class="line">  [...]</span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    [...]</span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      [...]</span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            [...]</span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 下面这句很重要，ant 会加载 antcontrib.properties 中定义的标签，其中就有 if 标签--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">taskdef</span> <span class="attr">resource</span>=<span class="string">&quot;net/sf/antcontrib/antcontrib.properties&quot;</span> <span class="attr">classpathref</span>=<span class="string">&quot;maven.plugin.classpath&quot;</span>/&gt;</span></span><br><span class="line">                [...]</span><br><span class="line">              <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant-contrib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant-contrib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0b3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ant<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意引入了 ant-contrib 这个倚赖包。</p><h2 id="if-标签的例子"><a class="markdownIt-Anchor" href="#if-标签的例子"></a> if 标签的例子</h2><p>下面是一个根据条件选择不同的文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">taskdef</span> <span class="attr">resource</span>=<span class="string">&quot;net/sf/antcontrib/antcontrib.properties&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">classpathref</span>=<span class="string">&quot;maven.plugin.classpath&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;$&#123;profileActive&#125;&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;local&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">then</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">&quot;$&#123;project.build.directory&#125;/classes&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">overwrite</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="comment">&lt;!--执行复制操作,todir的值是将要复制文件到的地方,overwrite是否重写--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fileset</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">dir</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span><span class="comment">&lt;!--$&#123;project.build.directory&#125;值是你的target目录--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">&quot;logback-spring-$&#123;profileActive&#125;.xml&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">then</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">else</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">copy</span> <span class="attr">todir</span>=<span class="string">&quot;$&#123;project.build.directory&#125;/classes&quot;</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">overwrite</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="comment">&lt;!--执行复制操作,todir的值是将要复制文件到的地方,overwrite是否重写--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fileset</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">dir</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span><span class="comment">&lt;!--$&#123;project.build.directory&#125;值是你的target目录--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">&quot;logback-spring.xml&quot;</span>/&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">fileset</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">copy</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">else</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <code>&lt;equals arg1=&quot;$&#123;profileActive&#125;&quot; arg2=&quot;local&quot;/&gt;</code> 的意思是：<br>arg1 的值等于<code>$&#123;profileActive&#125;</code>, arg2 的值等于<code>local</code>，判断 arg1 是否等于 arg2。</p><p>结合<code>if</code>标签，就是如果 arg1 等于 arg2，就执行 <code>then</code> 标签里面的任务，否则，就执行<code>else</code> 标签中的任务。</p><h2 id="if-标签的其它例子"><a class="markdownIt-Anchor" href="#if-标签的其它例子"></a> if 标签的其它例子</h2><p>Ant-Contrib 的 <code>if</code> 标签还有一些其它用法，例如 <code>elseif</code> 标签，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;$&#123;foo&#125;&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;bar&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">then</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The value of property foo is &#x27;bar&#x27;&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">then</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">elseif</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">equals</span> <span class="attr">arg1</span>=<span class="string">&quot;$&#123;foo&#125;&quot;</span> <span class="attr">arg2</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">then</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The value of property foo is &#x27;foo&#x27;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">then</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">elseif</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">else</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">echo</span> <span class="attr">message</span>=<span class="string">&quot;The value of property foo is not &#x27;foo&#x27; or &#x27;bar&#x27;&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">else</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体可以参看<a target="_blank" rel="noopener" href="http://ant-contrib.sourceforge.net/tasks/tasks/if.html">文档</a>。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-08-06T11:40:18.000Z" title="2020-08-06T11:40:18.000Z">2020-08-06</time>发表</span><span class="level-item"><time datetime="2020-08-07T07:52:14.311Z" title="2020-08-07T07:52:14.311Z">2020-08-07</time>更新</span><span class="level-item">5 分钟读完 (大约801个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/06/springboot%E4%B8%ADapplication-yml%E5%92%8Cbootstrap-yml%E7%9A%84%E5%8C%BA%E5%88%AB/">springboot中application.yml和bootstrap.yml的区别</a></h1><div class="content"><p>spring boot 默认支持 properties(.properties)和 YAML(.yml .yaml ) 两种格式的配置文件。<br>yml 和 properties 文件都属于配置文件，它们的功能一样。<br>在 spring boot 框架中 bootstrap.yml 和 application.yml 都可以用来配置参数，甚至这两个文件可以同时出现。</p><h2 id="配置写到-bootstrapyml和写到-applicationyml-有什么区别"><a class="markdownIt-Anchor" href="#配置写到-bootstrapyml和写到-applicationyml-有什么区别"></a> 配置写到 bootstrap.yml和写到 application.yml 有什么区别</h2><h3 id="加载顺序不一样"><a class="markdownIt-Anchor" href="#加载顺序不一样"></a> 加载顺序不一样</h3><p>bootstrap.yml 先加载 application.yml 后加载。<br>从技术上来讲，bootstrap.yml 由父 Spring ApplicationContext 加载。父 ApplicationContext 在使用 application.yml 之前被加载。</p><h3 id="应用场景不一样"><a class="markdownIt-Anchor" href="#应用场景不一样"></a> 应用场景不一样</h3><h4 id="bootstrapyml-典型的应用场景"><a class="markdownIt-Anchor" href="#bootstrapyml-典型的应用场景"></a> bootstrap.yml 典型的应用场景</h4><p>stackoverflow 中有个高票（301）的回答：</p><blockquote><p>I have just asked the Spring Cloud guys and thought I &gt;should share the info I have here.</p><p>bootstrap.yml <strong>is loaded before</strong> application.yml.</p><p>It is typically used for the following:</p><ul><li>when using Spring Cloud Config Server, you should specify <a target="_blank" rel="noopener" href="http://spring.application.name">spring.application.name</a> and spring.cloud.config.server.git.uri inside bootstrap.yml</li><li>some encryption/decryption information</li></ul><p>Technically, bootstrap.yml is loaded by a parent Spring ApplicationContext. That parent ApplicationContext is loaded before the one that uses application.yml.</p></blockquote><p>大致意思如下：</p><ul><li>当使用 Spring Cloud Config Server 配置中心时，需要在 bootstrap.yml 配置文件中指定 <a target="_blank" rel="noopener" href="http://spring.application.name">spring.application.name</a> 和<br>spring.cloud.config.server.git.uri，添加连接到配置中心的配置属性来加载外部配置中心的配置信息。</li><li>一些加密/解密信息</li></ul><p>因为当使用 Spring Cloud 的时候，配置信息一般是从 config server 加载的，为了取得配置信息（比如密码等），需要一些提早的或引导配置。因此，把 config server 信息放在 bootstrap.yml，用来加载真正需要的配置信息。config server 可能做了安全认证，所以访问所需的加解密信息也需要配置在 bootstrap.yml 里。</p><h2 id="属性覆盖"><a class="markdownIt-Anchor" href="#属性覆盖"></a> 属性覆盖</h2><ul><li><p>不接配置中心的情况下，启动的时候 spring boot 默认会加载 bootstrap.yml 以及 bootstrap-{profile}。{profile}在 bootstrap.yml中 spring.profiles.active 指定。<br>加载顺序是： bootstrap.yml &gt; bootstrap-{profile}.yml &gt; application.yml &gt;application-{profile}.yml</p><p>如果这4个配置文件中存在相同的属性，那么后加载的属性值会覆盖掉前加载的属性值。</p><p><strong>需要注意的是，有些文章说 bootstrap 不会被本地配置覆盖，如果这个说法是指 bootstrap 配置属性不会被 application 覆盖，那是错误的。</strong></p><p><strong>如果 spring.profiles.active 配置多个 profile，最后面的 profile 才会生效。例如：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev,mysql</span></span><br></pre></td></tr></table></figure><p>mysql profile才有效</p></li><li><p>在接配置中心的情况下，如果有 application.yml，它的属性值会被从配置中心中的同名属性值覆盖。</p></li></ul><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><p>在没有配置中心的情况下，是选择使用 bootstrap.yml 还是 application.yml，或者两者都用？<br>根据 bootstrap.yml 典型的应用场景，在没有配置中心的情况下，使用 bootstrap.yml 的意义不大，即使有加解密信息，将它们放到 application.yml 也是可以的。<br>建议在没有配置中心的情况下，去掉 bootstrap.yml 只使用 application.yml，减少配置文件，配置集中以减少出错的几率。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-07-22T06:17:14.000Z" title="2020-07-22T06:17:14.000Z">2020-07-22</time>发表</span><span class="level-item"><time datetime="2020-07-27T01:59:13.310Z" title="2020-07-27T01:59:13.310Z">2020-07-27</time>更新</span><span class="level-item">11 分钟读完 (大约1593个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/07/22/Kafka%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86/">Kafka日志管理</a></h1><div class="content"><p>Kafka 启动后，会产生很多日志，包括程序运行日志和消息日志，存在把磁盘撑爆的风险，所以为了 Kafka 能够正常的运行，对它进行日志管理是必要的一环。</p><h2 id="kafka运行日志"><a class="markdownIt-Anchor" href="#kafka运行日志"></a> Kafka运行日志</h2><h3 id="修改kafka-run-classsh"><a class="markdownIt-Anchor" href="#修改kafka-run-classsh"></a> <a target="_blank" rel="noopener" href="http://xn--kafka-run-class-tu9xw16x.sh">修改kafka-run-class.sh</a></h3><p>Kafka 运行时日志默认输出到 $KAFKA_HOME/logs 目录下，需要将日志输出到指定分区(应该选择一个磁盘空间比较大的分区)。<br>比如 /data/kafka/logs 目录下。</p><p>修改脚本 $KAFKA_HOME/bin/kafka-run-class.sh。</p><p><code>$KAFKA_HOME</code> 为 Kafka 的安装路径。</p><p>打开 <a target="_blank" rel="noopener" href="http://kafka-run-class.sh">kafka-run-class.sh</a>，定位到LOG_DIR</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Log directory to use</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$LOG_DIR</span>&quot;</span> = <span class="string">&quot;x&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  LOG_DIR=<span class="string">&quot;<span class="variable">$base_dir</span>/logs&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>增加一行，修改为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOG_DIR=/data/kafka/logs</span><br><span class="line"><span class="comment"># Log directory to use</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;x<span class="variable">$LOG_DIR</span>&quot;</span> = <span class="string">&quot;x&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  LOG_DIR=<span class="string">&quot;<span class="variable">$base_dir</span>/logs&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="log4jproperties"><a class="markdownIt-Anchor" href="#log4jproperties"></a> log4j.properties</h3><p>Kafka 采用 log4j 进行日志信息输送控制，Kafka 日志管理的配置文件为 log4j.properties，位于$KAFKA_HOME/config/log4j.properties。<br>在生产环境下，建议把日志级别改为 error 级。<br>Kafka 的 log4j.properties 中采用 DailyRollingFileAppender 按天进行日志备份，不支持只保留最近 n 天的数据，时间一久导致日志文件很多，<br>并且一天的文件有可能比较大，所以可以把 DailyRollingFileAppender 改成 RollingFileAppender，限制日志文件的大小和备份的个数。</p><p><strong>但如果要求必须按天保存的话，也就只能 DailyRollingFileAppender 进行日志备份了，这时就要注意定期进行日志的清理，避免大量的日志撑爆磁盘。</strong><br>下面是一个修改日志级别，并采用 RollingFileAppender，进行日志备份的例子：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=ERROR, default</span><br><span class="line"></span><br><span class="line">log4j.appender.default=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.default.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/default.log</span><br><span class="line">log4j.appender.default.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.default.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.default.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.default.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.kafkaAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.kafkaAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/server.log</span><br><span class="line">log4j.appender.kafkaAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.kafkaAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.kafkaAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.kafkaAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.stateChangeAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.stateChangeAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/state-change.log</span><br><span class="line">log4j.appender.stateChangeAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.stateChangeAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.stateChangeAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stateChangeAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.requestAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.requestAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/kafka-request.log</span><br><span class="line">log4j.appender.requestAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.requestAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.requestAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.requestAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.cleanerAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.cleanerAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/log-cleaner.log</span><br><span class="line">log4j.appender.cleanerAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.cleanerAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.cleanerAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.cleanerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log4j.appender.controllerAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.controllerAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/controller.log</span><br><span class="line">log4j.appender.controllerAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.controllerAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.controllerAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.controllerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line">log4j.appender.authorizerAppender=org.apache.log4j.RollingFileAppender</span><br><span class="line">log4j.appender.authorizerAppender.File=<span class="variable">$&#123;kafka.logs.dir&#125;</span>/kafka-authorizer.log</span><br><span class="line">log4j.appender.authorizerAppender.MaxBackupIndex = 10</span><br><span class="line">log4j.appender.authorizerAppender.MaxFileSize = 100MB</span><br><span class="line">log4j.appender.authorizerAppender.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.authorizerAppender.layout.ConversionPattern=[%d] %p %m (%c)%n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change the line below to adjust ZK client logging</span></span><br><span class="line">log4j.logger.org.apache.zookeeper=WARN</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change the two lines below to adjust the general broker logging level (output to server.log and stdout)</span></span><br><span class="line">log4j.logger.kafka=ERROR</span><br><span class="line">log4j.logger.org.apache.kafka=ERROR</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change to DEBUG or TRACE to enable request logging</span></span><br><span class="line">log4j.logger.kafka.request.logger=ERROR, requestAppender</span><br><span class="line">log4j.additivity.kafka.request.logger=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uncomment the lines below and change log4j.logger.kafka.network.RequestChannel$ to TRACE for additional output</span></span><br><span class="line"><span class="comment"># related to the handling of requests</span></span><br><span class="line"><span class="comment">#log4j.logger.kafka.network.Processor=TRACE, requestAppender</span></span><br><span class="line"><span class="comment">#log4j.logger.kafka.server.KafkaApis=TRACE, requestAppender</span></span><br><span class="line"><span class="comment">#log4j.additivity.kafka.server.KafkaApis=false</span></span><br><span class="line">log4j.logger.kafka.network.RequestChannel$=WARN, requestAppender</span><br><span class="line">log4j.additivity.kafka.network.RequestChannel$=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">log4j.logger.kafka.controller=ERROR, controllerAppender</span><br><span class="line">log4j.additivity.kafka.controller=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">log4j.logger.kafka.log.LogCleaner=ERROR, cleanerAppender</span><br><span class="line">log4j.additivity.kafka.log.LogCleaner=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">log4j.logger.state.change.logger=ERROR, stateChangeAppender</span><br><span class="line">log4j.additivity.state.change.logger=<span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注意：<br><strong>上述配置中的文件大小、备份日志文件个数和日志级别需要根据环境和要求进行调整</strong></p><h2 id="kafka的数据"><a class="markdownIt-Anchor" href="#kafka的数据"></a> Kafka的数据</h2><p>Kafka 的数据有时也会称为日志或消息，请不要与运行日志混淆。<br>在 $KAFKA_HOME/config/server.properties 中配置了 log.dirs 值，表示 Kafka 数据的存放目录，而非 Kafka 的运行日志目录。</p><h3 id="日志消息清理delete"><a class="markdownIt-Anchor" href="#日志消息清理delete"></a> 日志/消息清理（delete）</h3><p>Kafka 消息日志的清理逻辑是启动线程定期扫描日志文件，将符合清理规则的消息日志文件删除。<br>Kafka 默认的清理策略是基于文件修改时间戳的清理策略，默认会保留 7 天的消息日志量，基于消息日志总量大小的清理规则不生效。<br>在 $KAFKA_HOME/config/server.properties 中 log.retention.hours 配置了该值：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion due to age</span></span><br><span class="line">log.retention.hours=168</span><br></pre></td></tr></table></figure><p>单位是小时，刚好 7 天。</p><p><strong>因此，Kafka 数据的存放目录也一定要考虑磁盘空间是否能够满足保存7天的消息日志量，避免出现磁盘空间不够的情况。</strong></p><p>Kafka 还可以基于消息日志大小进行清理，该策略会依次检查每个日志中的日志分段是否超出指定的大小（retentionSize），对超出指定大小的日志分段采取<br>删除策略。retentionSize 可通过参数 log.retention.bytes 来配置（在 $KAFKA_HOME/config/server.properties 中），单位为字节，<br>默认值为 -1，表示无穷大。该参数配置的是Log中所有日志文件的总大小，并非单个日志分段的大小。Kafka 的默认配置是基于上述的时间段清理，该参数是注释<br>状态。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A size-based retention policy for logs. Segments are pruned from the log unless the remaining</span></span><br><span class="line"><span class="comment"># segments drop below log.retention.bytes. Functions independently of log.retention.hours.</span></span><br><span class="line"><span class="comment">#log.retention.bytes=1073741824</span></span><br></pre></td></tr></table></figure><p>单个日志分段文件的大小限制可通过 log.segment.bytes 来限制，默认为1073741824，即1GB。</p><h2 id="运行建议"><a class="markdownIt-Anchor" href="#运行建议"></a> 运行建议</h2><p>建议在 Kafka 运行期间 对 Kafka 运行日志和消息进行监控，总结分析出每天的日志量的大小，合理规划磁盘空间和时间，<br>定期对 Kafka 的运行日志和消息进行备份和清理。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-06-12T03:41:42.000Z" title="2020-06-12T03:41:42.000Z">2020-06-12</time>发表</span><span class="level-item"><time datetime="2020-06-16T07:21:07.508Z" title="2020-06-16T07:21:07.508Z">2020-06-16</time>更新</span><span class="level-item">15 分钟读完 (大约2280个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/12/Java8%E6%B5%81%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/">Java8流使用简介</a></h1><div class="content"><p>Stream API支持的许多操作。这些操作能让你快速完成复杂的数据查询，如筛选、切片、映射、查找、匹配和归约。</p><h2 id="筛选和切片"><a class="markdownIt-Anchor" href="#筛选和切片"></a> 筛选和切片</h2><p>Streams 接口支持 filter 方法。该操作会接受一个谓词（一个返回 boolean 的函数）作为参数，并返回一个包括所有符合谓词的元素的流。<br>流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的 hashCode 和 equals 方法实现）的流。<br>看下面一个例子，筛选出列表中所有的偶数，并确保没有重复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">    .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="跳过元素"><a class="markdownIt-Anchor" href="#跳过元素"></a> 跳过元素</h2><p>流还支持skip(n)方法，返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。请注意，limit(n)和skip(n)是互补的。<br>如下例，跳过超过90分的头1个学生，并剩下的学生中的头3个的姓名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; goodStudentNames = students.stream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter-&gt; &quot;</span> + s.getName());</span><br><span class="line">        <span class="keyword">return</span> s.getScore() &gt; GOOD;</span><br><span class="line">    &#125;)</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map-&gt; &quot;</span> + s.getName());</span><br><span class="line">        <span class="keyword">return</span> s.getName();</span><br><span class="line">    &#125;)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(toList());</span><br><span class="line"></span><br><span class="line">System.out.println(goodStudentNames);</span><br></pre></td></tr></table></figure><h2 id="映射"><a class="markdownIt-Anchor" href="#映射"></a> 映射</h2><p>Stream API 通过 map 和 flatMap 方法从某些对象中选择信息。<br>map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于<br>它是“创建一个新版本”而不是去“修改”）。</p><p>给定一个单词列表，返回另一个列表，显示每个单词中有几个字母。可以像下例，给 map 传递一个方法引用 String::length 来解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;Java 8&quot;</span>, <span class="string">&quot;Lambdas&quot;</span>, <span class="string">&quot;In&quot;</span>, <span class="string">&quot;Action&quot;</span>);</span><br><span class="line">List&lt;Integer&gt; wordLengths = words.stream()</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .collect(toList());</span><br><span class="line">System.out.println(wordLengths);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[6, 7, 2, 6]</span><br></pre></td></tr></table></figure><h2 id="扁平化"><a class="markdownIt-Anchor" href="#扁平化"></a> 扁平化</h2><p>对于一张单词表，如何返回一张列表，列出里面各不相同的字符呢？例如，给定单词列表[“Hello”,“World”]，你想要返回列表[“H”,“e”,“l”, “o”,“W”,“r”,“d”]。<br>可以用 flatMap 来解决这个问题。程序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; uniqueCharacters =</span><br><span class="line">    words.stream()</span><br><span class="line">        .map(w -&gt; w.split(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        .flatMap(Arrays::stream)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">System.out.println(uniqueCharacters);</span><br></pre></td></tr></table></figure><p>Arrays.stream()的方法可以接受一个数组并产生一个流，如下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arrayOfWords = &#123;<span class="string">&quot;Goodbye&quot;</span>, <span class="string">&quot;Tom&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; streamOfwords = Arrays.stream(arrayOfWords);</span><br></pre></td></tr></table></figure><p>map(w -&gt; w.split(“”)) 得到 <code>Stream&lt;String[]&gt;</code>。<br>flatMap(Arrays::stream) 得到 <code>Stream&lt;String&gt;</code>，使用 flatMap 方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容。所<br>有使用map(Arrays::stream)时生成的单个流都被合并起来，即扁平化为一个流。<br>如果是map<br>map(Arrays::stream) 得到 <code>Stream&lt;Stream&lt;String&gt;&gt;</code></p><p>再看一个问题：给定两个数字列表，如何返回所有的数对呢？例如，给定列表[1, 2, 3]和列表[3, 4]，应该返回<br>[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]。为简单起见，用有两个元素的数组来代表数对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; numbers2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; pairs = numbers1.stream()</span><br><span class="line">    .flatMap(</span><br><span class="line">        i -&gt; numbers2.stream().map(j -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;)</span><br><span class="line">    )</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><p>当 i = 1 时 i -&gt; numbers2.stream().map(j -&gt; new int[]{i, j}) 得到<br>Stream&lt;Int[]&gt; (1,3), Stream&lt;Int[]&gt; (1,4) 这一对流。<br>依次循环，会得到 3 对流，flatMap 对这 3 对流扁平化，新成包含 6 个数组的一个流。</p><p>扩展上面的问题，只返回总和能被3整除的数对呢？可利用 filter 来实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">List&lt;Integer&gt; numbers2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; pairs = numbers1.stream()</span><br><span class="line">    .flatMap(</span><br><span class="line">        i -&gt; numbers2.stream()</span><br><span class="line">            .filter(j -&gt; (i + j) % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">            .map(j -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;)</span><br><span class="line">    )</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(2,4)(3,3)]</span><br></pre></td></tr></table></figure><h2 id="查找和匹配"><a class="markdownIt-Anchor" href="#查找和匹配"></a> 查找和匹配</h2><p>Stream API通过allMatch、anyMatch、noneMatch、findFirst和findAny方法，来判断数据集中的某些元素是否匹配一个给定的属性。</p><h2 id="归约"><a class="markdownIt-Anchor" href="#归约"></a> 归约</h2><p>将流中所有元素反复结合起来，得到一个值，比如一个Integer。这样的查询可以被归类为归约操作（将流归约成一个值）。</p><h3 id="元素求和"><a class="markdownIt-Anchor" href="#元素求和"></a> 元素求和</h3><p>对流中所有的元素求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br></pre></td></tr></table></figure><p>reduce接受两个参数：</p><ol><li>初始值，这里是0</li><li>BinaryOperator<t>来将两个元素结合起来产生一个新值，这里我们用的是lambda (a, b) -&gt; a + b。<br>首先，0作为Lambda（a）的第一个参数，从流中获得4作为第二个参数（b）。0 + 4得到4，它成了新的累积值。<br>然后再用累积值和流中下一个元素5调用Lambda，产生新的累积值9。接下来，再用累积值和下一个元素3调用Lambda，得到12。<br>最后，用12和流中最后一个元素9调用Lambda，得到最终结果21。</t></li></ol><p>在Java 8中，Integer类现在有了一个静态的 sum 方法来对两个数求和，用不着反复用Lambda写同一段代码了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><p>如果没有初始值，reduce 还有一个重载的变体，它不接受初始值，但是会返回一个Optional对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure><h3 id="最大值-最小值"><a class="markdownIt-Anchor" href="#最大值-最小值"></a> 最大值、最小值</h3><p>我们利用刚刚学到的 reduce 来计算流中最大或最小的元素是否可能，该怎样做呢？<br>正如前面描述的，reduce接受两个参数：</p><ol><li>一个初始值</li><li>一个 Lambda 来把两个流元素结合起来并产生一个新值</li></ol><p>那么我们需要一个给定两个元素能够返回最大值和最小值的 Lambda 表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce((x, y) -&gt; x &gt; y ? y : x);</span><br><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line">System.out.println(<span class="string">&quot;min: &quot;</span> + min.orElse(<span class="number">0</span>) + <span class="string">&quot; max: &quot;</span> + max.orElse(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min: 3 max: 9</span><br></pre></td></tr></table></figure><h2 id="构建"><a class="markdownIt-Anchor" href="#构建"></a> 构建</h2><h3 id="值创建"><a class="markdownIt-Anchor" href="#值创建"></a> 值创建</h3><p>使用静态方法 Stream.of，通过显式值创建一个流。它可以接受任意数量的参数。例如，以下代码直接使用 Stream.of 创建了一个字符串流。<br>然后将字符串转换为大写，再一个个打印出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Java 8 &quot;</span>, <span class="string">&quot;Lambdas &quot;</span>, <span class="string">&quot;In &quot;</span>, <span class="string">&quot;Action&quot;</span>);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="数组创建"><a class="markdownIt-Anchor" href="#数组创建"></a> 数组创建</h3><p>使用静态方法Arrays.stream从数组创建一个流。它接受一个数组作为参数。例如，将一个原始类型int的数组转换成一个IntStream，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">14</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><h3 id="文件生成流"><a class="markdownIt-Anchor" href="#文件生成流"></a> 文件生成流</h3><p>Java中用于处理文件等I/O操作的NIO API 已更新，以便利用Stream API。java.nio.file.Files 中的很多静态方法都会返回一个流。<br>如下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">uniqueWords</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines =</span><br><span class="line">          Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset()))&#123;</span><br><span class="line">uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                   .distinct()</span><br><span class="line">                   .count();</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Files.lines得到一个流，其中的每个元素都是给定文件中的一行。然后对line调用split方法将行拆分成单词。应该注意的是，该如何使用flatMap产生一个扁<br>平的单词流，而不是给每一行生成一个单词流。最后，把distinct和count方法链接起来，数数流中有多少各不相同的单词。</p><h3 id="函数生成流"><a class="markdownIt-Anchor" href="#函数生成流"></a> 函数生成流</h3><p>Stream API提供了两个静态方法来从函数生成流：Stream.iterate和Stream.generate。这两个操作可以创建所谓的无限流。<br>一般来说，应该使用limit(n)来对这种流加以限制。</p><ol><li>迭代</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">      .limit(<span class="number">10</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>iterate 方法接受一个初始值（在这里是0），还有一个依次应用在每个产生的新值上的Lambda。这里，我们使用<code>n -&gt; n + 2</code>，返回的是前一个元<br>素加上 2。因此，iterate 方法生成了一个所有正偶数的流：流的第一个元素是初始值 0。然后加上 2 来生成新的值 2，再加上 2 来得到新的值 4，以此类推。<br>这种iterate操作基本上是顺序的，因为结果取决于前一次应用。此操作将生成一个无限流——这个流没有结尾，因为值是按需计算的，可以永远计算下去。<br>我们说这个流是无界的。使用limit方法来显式限制流的大小。这里只选择了前10个偶数。然后可以调用forEach终端操作来消费流，并分别打印每个元素。</p><ol start="2"><li>生成</li></ol><p>generate 方法也可让你按需生成一个无限流。但 generate 不是依次对每个新生成的值应用函数的。它接受一个 Supplier<t>类型的 Lambda 提供新的值。<br>我们先来看一个简单的用法：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">      .limit(<span class="number">5</span>)</span><br><span class="line">      .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这段代码将生成一个流，其中有五个0到1之间的随机双精度数。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-06-08T12:12:45.000Z" title="2020-06-08T12:12:45.000Z">2020-06-08</time>发表</span><span class="level-item"><time datetime="2020-06-12T03:46:05.938Z" title="2020-06-12T03:46:05.938Z">2020-06-12</time>更新</span><span class="level-item">12 分钟读完 (大约1787个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/08/%E7%AE%80%E4%BB%8BJava8%E7%9A%84%E6%B5%81/">简介Java8的流</a></h1><div class="content"><p>流是Java API的新成员，它允许以<code>声明性</code>方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。<br>流还可以透明地并行处理，无需编写任何多线程代码了。</p><h2 id="使用流的例子"><a class="markdownIt-Anchor" href="#使用流的例子"></a> 使用流的例子</h2><p>下面两段代码都是用来返回成绩好的学生的姓名，并按照得分排序，一个是用Java 7写的，另一个是用Java 8的流写的。</p><p>Java7</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">studentNames</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Student&gt; goodStudents = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student d : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d.getScore() &gt;= GOOD) &#123;</span><br><span class="line">            goodStudents.add(d);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    goodStudents.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student d1, Student d2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(d1.getScore(), d2.getScore());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;String&gt; goodStudentNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student d : goodStudents) &#123;</span><br><span class="line">        goodStudentNames.add(d.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(goodStudentNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java8采用流的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">studentNamesJ8</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; goodStudentNames = students.stream()</span><br><span class="line">        .filter(s -&gt; s.getScore() &gt;= GOOD)</span><br><span class="line">        .sorted(comparing(Student::getScore))</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(goodStudentNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了利用多核架构并行执行这段代码，只需要把stream()换成parallelStream():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">studentNamesJ8</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; goodStudentNames = students.parallelStream()</span><br><span class="line">        .filter(s -&gt; s.getScore() &gt;= GOOD)</span><br><span class="line">        .sorted(comparing(Student::getScore))</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(goodStudentNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用流方法的好处:</p><ul><li>声明性方式<br>说明想要完成什么（筛选成绩好的学生）而不是说明如何实现（循环和if条件等控制流语句）。</li><li>代码清晰易读<br>把几个基础操作链接起来，来表达复杂的数据处理流水线。filter 的结果被传给了 sorted 方法，再传给 map 方法，最后传给 collect 方法。</li><li>可轻松利用多核<br>只需把stream()换成parallelStream()。</li></ul><h2 id="流是什么"><a class="markdownIt-Anchor" href="#流是什么"></a> 流是什么</h2><p>Java 8中的集合支持一个新的 stream 方法，它会返回一个流（接口定义在java.util.stream.Stream里）。还有很多其他的方法可以得到流，<br>比如利用数值范围或从I/O资源生成流元素。流的简短定义就是“从支持数据处理操作的源生成的元素序列”。<br>进一步说明这个定义：</p><ul><li>元素序列<br>就像集合一样，流也提供了一个接口，可以访问特定元素类型的一组有序值。但流的目的在于表达计算，比如前面见到的 filter、sorted 和 map。<br>与集合不同地方是集合讲的是数据，流讲的是计算。</li><li>源<br>流会使用一个提供数据的源，如集合、数组或输入/输出资源。</li><li>数据处理操作<br>流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中的常用操作，如filter、map、reduce、find、match、sort等。流操作可以<br>顺序执行，也可并行执行。</li></ul><p>此外，流还有两个重要特点：</p><ul><li>流水线<br>很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。</li><li>内部迭代<br>流的迭代操作是在背后进行的。</li></ul><p>一段体现这些概念的代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">studentNamesLimit</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;String&gt; goodStudentNames = students.stream()</span><br><span class="line">        .filter(s -&gt; s.getScore() &gt;= GOOD)</span><br><span class="line">        .sorted(comparing(Student::getScore))</span><br><span class="line">        .map(Student::getName)</span><br><span class="line">        .limit(<span class="number">3</span>)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    System.out.println(goodStudentNames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，我们先是对 students 调用 stream 方法，由学生列表得到一个流。数据源是学生列表，它给流提供一个元素序列。<br>接下来，对流应用一系列数据处理操作：filter、sorted、map、limit 和 collect。<br>除了 collect 之外，所有这些操作都会返回另一个流，这样它们就可以接成一条流水线，于是就可以看作对源的一个查询。<br>最后，collect 操作开始处理流水线，并返回结果（它和别的操作不一样，因为它返回的不是流，在这里是一个 List ）。<br>在调用 collect 之前，没有任何结果产生，实际上根本就没有从 students 里选择元素。你可以这么理解：链中的方法调用都在排队等待，直到调用collect。</p><p>在这里我们并没有去实现筛选（filter）、排序（sorted）、提取（map）或截断（limit）功能，Streams库已经自带了。</p><h2 id="流与集合"><a class="markdownIt-Anchor" href="#流与集合"></a> 流与集合</h2><p>Java 现有的集合和新的流都提供了接口，来配合代表元素型有序值的数据接口。所谓有序，就是说我们一般是按顺序取用值，而不是随机取用的。<br>集合与流之间的差异就在于什么时候进行计算。集合是一个内存中的数据结构，它包含数据结构中目前所有的值 —— 集合中的每个元素都得先算出来才能添加到集合中。<br>（可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）相比之下，<br>流则是在概念上固定的数据结构（不能添加或删除元素），其元素则是按需计算的。这是一种生产者－消费者的关系。从另一个角度来说，流就像是一个<br>延迟创建的集合：只有在消费者要求的时候才会计算值（用管理学的话说这就是需求驱动，甚至是实时制造)。</p><p>流只能遍历一次，遍历完了后，遍历完之后，我们就说这个流已经被消费掉了。例如，以下代码会抛出一个异常，说流已被消费掉了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; title = Arrays.asList(<span class="string">&quot;Java8&quot;</span>, <span class="string">&quot;Stream&quot;</span>, <span class="string">&quot;Example&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; s = title.stream();</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line">s.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Java8</span><br><span class="line">In</span><br><span class="line">Action</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure><h2 id="流操作"><a class="markdownIt-Anchor" href="#流操作"></a> 流操作</h2><p>可以连接起来的流操作称为中间操作，关闭流的操作称为终端操作。<br>诸如 filter 或 sorted 等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，<br>否则中间操作不会执行任何处理。这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理。看一个例子，在每个 Lambda 都打印当前处理的学生名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; goodStudentNames = students.stream()</span><br><span class="line">    .filter(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;filter-&gt; &quot;</span> + s.getName());</span><br><span class="line">        <span class="keyword">return</span> s.getScore() &gt;= GOOD;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map-&gt; &quot;</span> + s.getName());</span><br><span class="line">        <span class="keyword">return</span> s.getName();</span><br><span class="line">    &#125;)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(toList());</span><br><span class="line"></span><br><span class="line">System.out.println(goodStudentNames);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filter-&gt; tom</span><br><span class="line">filter-&gt; jerry</span><br><span class="line">filter-&gt; 小李</span><br><span class="line">map-&gt; 小李</span><br><span class="line">filter-&gt; 小张</span><br><span class="line">map-&gt; 小张</span><br><span class="line">filter-&gt; 小明</span><br><span class="line">filter-&gt; 大熊</span><br><span class="line">filter-&gt; 小雨</span><br><span class="line">filter-&gt; 二狗</span><br><span class="line">map-&gt; 二狗</span><br><span class="line">[小李, 小张, 二狗]</span><br></pre></td></tr></table></figure><p>可以看到 filter 的操作次数没有列表那么长，说明 filter 和 map 的操作有合并。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-06-01T03:05:41.000Z" title="2020-06-01T03:05:41.000Z">2020-06-01</time>发表</span><span class="level-item"><time datetime="2020-06-05T02:44:07.634Z" title="2020-06-05T02:44:07.634Z">2020-06-05</time>更新</span><span class="level-item">9 分钟读完 (大约1294个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/06/01/Java8%E4%B9%8BLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/">Java8之Lambda表达式</a></h1><div class="content"><p>Java 8 的最大变化是引入了 Lambda 表达式——一种紧凑的、传递行为的方式。Lambda 表达式是 Java 支持函数式编程的基础，也可以称之为<code>闭包</code>。</p><h2 id="一个-lambda-表达式"><a class="markdownIt-Anchor" href="#一个-lambda-表达式"></a> 一个 Lambda 表达式</h2><p>Java 8 之前排序，对 students 中的学生按照得分进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    students.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s1.getScore() - s2.getScore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java 8里面，可以编写更为简洁的代码，这些代码读起来更接近问题的描述：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    students.sort(comparing((s) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> s.getScore();</span><br><span class="line">        &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是一个 Lambda 表达式，它念起来就是“给学生排序，比较得分的多少”。<br>上面的代码可改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort2</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    students.sort(comparing(Student::getScore));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>::</code>语法 是Java 8的方法引用（即“把这个方法作为值”），比上面的写法更简洁。</p><h2 id="什么是-lambda-表达式"><a class="markdownIt-Anchor" href="#什么是-lambda-表达式"></a> 什么是 Lambda 表达式</h2><p>可以把 Lambda 表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。</p><ul><li>匿名<br>它不像普通的方法那样有一个明确的名称</li><li>函数<br>Lambda 函数不像方法那样属于某个特定的类。但和方法一样，Lambda 有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表。</li><li>传递<br>Lambda 表达式可以作为参数传递给方法或存储在变量中。简单来说，就是在 Java 语法层面允许将函数当作方法的参数，函数可以当做对象。</li></ul><h3 id="lambda-表达式的基本语法"><a class="markdownIt-Anchor" href="#lambda-表达式的基本语法"></a> Lambda 表达式的基本语法</h3><p>语法格式：<br>(parameters) -&gt; expression 或者 (parameters) -&gt; { statements; }<br>格式理解：<br>(对应函数式接口的参数列表) -&gt; { 对应函数式接口的实现方法 }</p><p>简单范例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleLambda1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleLambda2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数式接口"><a class="markdownIt-Anchor" href="#函数式接口"></a> 函数式接口</h3><p>Runnable 的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Runnable 添加了 <code>@FunctionalInterface</code> 注解，这个注解用于表示该接口会设计成一个函数式接口。表明 Runnable 接口可用作函数接口。<br>该注解会强制 javac 检查一个接口是否符合函数接口的标准。如果该注解添加给一个枚举类型、类或另一个注解，或者接口包含不止一个抽象方法，javac 就会报错。<br>重构代码时，使用它能很容易发现问题。</p><p>函数接口是只有一个抽象方法的接口，用作 Lambda 表达式的类型。任一 Lambda 表达式都有且只有一个函数式接口与之对应，从这个角度来看，也可以说是<br>该函数式接口的实例化。</p><h3 id="引用值"><a class="markdownIt-Anchor" href="#引用值"></a> 引用值</h3><p>java 8 之前 使用匿名内部类，也许遇到过这样的情况：需要引用它所在方法里的变量。这时，需要将变量声明为 <code>final</code>，Java 8 虽然放松了这一限制，可以<br>引用非 final 变量，但是该变量在既成事实上必须是 final。</p><p>Lambda 表达式中引用既成事实上的 final 变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleLambda3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + ss);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果试图给ss赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleLambda4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + ss);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    ss = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器报错，提示：“Variable used in lambda expression should be final or effectively final”。</p><h2 id="不同形式的-lambda-表达式"><a class="markdownIt-Anchor" href="#不同形式的-lambda-表达式"></a> 不同形式的 Lambda 表达式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">Runnable</span> <span class="variable">noArguments</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> <span class="type">Runnable</span> <span class="variable">multiStatement</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; World&quot;</span>);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> <span class="type">ActionListener</span> <span class="variable">oneArgument</span> <span class="operator">=</span> event -&gt; System.out.println(<span class="string">&quot;button clicked&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>所示的 Lambda 表达式不包含参数，使用空括号 () 表示没有参数。该 Lambda 表达式实现了 Runnable 接口，该接口也只有一个 run 方法，没有参数，<br>且返回类型为 void。</li><li>所示的 Lambda 表达式不包含参数，主体是一段代码块，使用大括号（{}）将代码块括起来。<br><strong>只有一行代码的 Lambda 表达式也可使用大括号，用以明确 Lambda 表达式从何处开始、到哪里结束。</strong></li><li>所示的 Lambda 表达式包含且只包含一个参数，可省略参数的括号。</li><li>所示的 Lambda 表达式包含多个参数，并显式的声明了参数类型。这行代码并不是将两个数字相加，而是创建了一个函数，用来计算两个数字相加的结果。</li><li>所示的 Lambda 表达式包含多个参数，和 4 不同的是它参数类型是编译器推导出来的</li></ol></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">上一页</a></div><div class="pagination-next"><a href="/page/3/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>