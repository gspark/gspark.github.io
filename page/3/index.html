<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-05-26T08:10:28.000Z" title="2020-05-26T08:10:28.000Z">2020-05-26</time>发表</span><span class="level-item"><time datetime="2020-07-10T07:15:00.946Z" title="2020-07-10T07:15:00.946Z">2020-07-10</time>更新</span><span class="level-item">14 分钟读完 (大约2174个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/26/Java%E4%B9%8Bhappens-before/">Java之happens-before</a></h1><div class="content"><h2 id="从一个例子开始"><a class="markdownIt-Anchor" href="#从一个例子开始"></a> 从一个例子开始</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemModle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> a;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> b;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在单线程的情况下，如果先执行 method1 再执行 method2，最终 m1，m2 为 1， 0；如果先执行 method2 再执行 method1，最终 m1，m2 为 0， 2。<br>在多线程的情况下，假设这两个方法分别在不同的线程执行，如果 Java 虚拟机在执行了任一方法的第一条赋值语句后就切换线程，那么 m1，m2 的最终结果可能就是<br>0，0 了。除了上面三种情况外，m1，m2 的结果还有一种情况出现：1，2。</p><p>造成这种看似不可能的结果的原因有 3 个：</p><ul><li>即时编译器的重排序</li><li>处理器的乱序执行</li><li>内存系统的重排序</li></ul><p>后面两种原因涉及到具体的体系架构，这里不做探讨。</p><h2 id="即时编译器的重排序"><a class="markdownIt-Anchor" href="#即时编译器的重排序"></a> 即时编译器的重排序</h2><p>即时编译器(和处理器)需要保证程序能够遵守 <code>as-if-serial</code> 属性。<code>as-if-serial</code> 语义是：不管怎么重排序（编译器和处理器为了提高并行度），<br>（单线程）程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 <code>as-if-serial</code> 语义。<br>通俗的讲，在单线程的情况下，要给程序一个顺序执行的假象，即经过重排序的执行结果要和顺序执行的结果一致。<br>此外，如果两个操作之间存在数据依赖，那么即时编译器(和处理器)不能调整它们的执行顺序，否则会造成程序语义的变化。</p><h2 id="java-内存模型与-happens-before"><a class="markdownIt-Anchor" href="#java-内存模型与-happens-before"></a> Java 内存模型与 happens-before</h2><p>Java 5 引入了明确定义的 Java 内存模型，其中最为重要的一个概念就是 happens-before 关系。happens-before 关系是用来描述两个操作的内存可见性的。<br>它定义了内存的可见性原则。如果一个操作 happens-before 另一个操作， 那么第一个操作的结果对第二个结果可见。</p><h3 id="规则"><a class="markdownIt-Anchor" href="#规则"></a> 规则</h3><p>下面是Java内存模型中的八条可保证 happen—before 的规则，它们无需任何同步器协助就已经存在，可以在编码中直接使用。<br>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随机地重排序。</p><ul><li>单线程规则<br>在一个单独的线程中，执行结果与按照程序代码的执行顺序的结果是一致的。</li><li>锁定规则<br>一个 解锁 操作 happen—before 之后对同一个锁的 加锁 操作。</li><li>volatile 变量规则<br>对一个 volatile 变量的写操作 happen—before 之后对该变量的读操作。</li><li>线程启动规则<br>Thread 对象的 start() happen—before 该线程的第一个操作。</li><li>线程结束规则<br>线程的最后一个操作 happen—before 它的终止事件（即其它线程通过Thread.isAlive()或者Thread.join() 判断该线程是否终止）。</li><li>中断规则<br>线程对其它线程的中断操作 happen—before 被中断线程所收到的中断时事件（被中断线程的 InterruptedException 异常或者Thread.interrupted 调用）。</li><li>终结器规则<br>构造器中的最后一个操作 happen—before 析构器的第一个操作。</li><li>传递性规则<br>happens-before 关系具备传递性，如果操作 A happens-before 操作 B， 而操作 B happens-before 操作 C，那么 操作 A happens-before 操作 C。</li></ul><p>在开头的例子中，程序没有定义任何 happens-before 关系，仅拥有默认线程内 happens-before 关系，也就是 m2 的赋值操作 happens-before b 的<br>赋值操作，m1的赋值操作 happens-before a 的赋值操作。拥有 happens-before 关系的两对赋值操作之间没有数据依赖，因此即时编译器（处理器）都可能<br>对其进行重排序。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1    thread2</span><br><span class="line">   |          |</span><br><span class="line">  m2=a       m1=b</span><br><span class="line">  b=<span class="number">1</span>        a=<span class="number">2</span></span><br><span class="line">   |          |</span><br><span class="line">   |          |</span><br></pre></td></tr></table></figure><p>重排后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1    thread2</span><br><span class="line">   |          |</span><br><span class="line">  b=<span class="number">1</span>         |</span><br><span class="line">   |          m1=b</span><br><span class="line">   |          a=<span class="number">2</span></span><br><span class="line">  m2=a        |</span><br></pre></td></tr></table></figure><p>只要将 b 的赋值操作排在 m2 的赋值操作之前，那么就可以 1，2 的结果。</p><p>那么怎么解决这个问题呢？将 a 或者 b 设置为 volatile 字段。</p><p>比如将 b 设置为 volatile 字段。根据 volatile 字段的 happens-before 规则，我们知道 b 的写（赋值）操作 happens-before m1 的赋值操作。<br>在没有标记 volatile 的时候，同一线程中，m2=a和b=1存在happens before关系，但因为没有数据依赖可以重排列。一旦标记了volatile，即时编译器和CPU需要考虑到多线程happens-before关系，因此不能自由地重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread1    thread2</span><br><span class="line">   |          |</span><br><span class="line">  m2=a        |</span><br><span class="line">  b=<span class="number">1</span>         |</span><br><span class="line">   |          m1=b</span><br><span class="line">   |          a=<span class="number">2</span></span><br></pre></td></tr></table></figure><p>也就意味着，当对 a 进行赋值的时候，对 m2 的赋值操作已经完成。因此，在 b 为 volatile 字段的情况下，不会出现 m1，m2 出现 1， 2 的情况。</p><h2 id="内存模型的实现"><a class="markdownIt-Anchor" href="#内存模型的实现"></a> 内存模型的实现</h2><p>Java 内存模型是通过内存屏障（Memory Barrier）来禁止指令重排序的。<br>对于即时编译器来说，它会根据 happens-before 规则，向正在编译的目标方法中插入相应的读读、读写、写读和写写内存屏障。<br>这些内存屏障会限制即时编译器的重排序操作。以 volatile 字段访问为例，所插入的内存屏障将不允许 volatile 字段 写操作 之前的内存访问被重排序至其之后；<br>也将不允许 volatile 字段 读操作 之后的内存访问被重排序至其之前。</p><p>然后，即时编译器将根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。以我们日常接触的 X86_64 架构来说，读读、读写以及写写内存屏障是<br>空操作（no-op），只有写读内存屏障会被替换成具体指令。</p><h2 id="锁final-字段"><a class="markdownIt-Anchor" href="#锁final-字段"></a> 锁，final 字段</h2><h3 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h3><p>锁操作同样具备 happens-before 关系。解锁操作 happens-before 之后对同一把锁的加锁操作。实际上，在解锁时，Java 虚拟机同样需要强制<br>刷新缓存，使得当前线程所修改的内存对其它线程可见。需要注意的是，锁操作的 happens-before 规则的关键字是同一把锁。也就意味着，如果编译器能够<br>证明某把锁仅被同一线程持有，那么它可以移除相应的加锁解锁操作。<br>因此也就不再强制刷新缓存。举个例子，即时编译后的 <code>synchronized (new Object()) &#123;&#125;</code>，可能等同于空操作，而不会强制刷新缓存。</p><h3 id="final-字段"><a class="markdownIt-Anchor" href="#final-字段"></a> final 字段</h3><p>final 实例字段则涉及新建对象的发布问题。当一个对象包含 final 实例字段时，我们希望其他线程只能看到已初始化的 final 实例字段。</p><p>因此，即时编译器会在 final 字段的写操作后插入一个写写屏障（StoreStore屏障），以防某些优化将新建<strong>对象的发布</strong>（即将实例对象写入一个共享引用中）重排序至 final 字段的<br>写操作之前。在 X86_64 平台上，写写屏障（StoreStore屏障）是空操作。<br>具体来说对于final域，编译器和处理器要遵守两个重排序规则：</p><ul><li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemModle1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;                            <span class="comment">//普通变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> j;                      <span class="comment">//final变量</span></span><br><span class="line">    <span class="keyword">static</span> MemModle1 obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MemModle1</span><span class="params">()</span> &#123;</span><br><span class="line">        i = <span class="number">1</span>;                        <span class="comment">//写普通域</span></span><br><span class="line">        j = <span class="number">2</span>;                        <span class="comment">//写final域</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;    <span class="comment">//写线程A执行</span></span><br><span class="line">        obj = <span class="keyword">new</span> <span class="title class_">MemModle1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;       <span class="comment">//读线程B执行</span></span><br><span class="line">        <span class="type">MemModle1</span> <span class="variable">object</span> <span class="operator">=</span> obj;       <span class="comment">//读对象引用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> object.i;                <span class="comment">//读普通域</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> object.j;                <span class="comment">//读final域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><p>极客时间 -《Java内存模型》</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-05-14T07:51:35.000Z" title="2020-05-14T07:51:35.000Z">2020-05-14</time>发表</span><span class="level-item"><time datetime="2020-05-22T01:20:40.630Z" title="2020-05-22T01:20:40.630Z">2020-05-22</time>更新</span><span class="level-item">19 分钟读完 (大约2790个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/14/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">Java单例模式</a></h1><div class="content"><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。<br>单例模式（Singleton Pattern）的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式是一种常用的模式，有一些对象我们往往<br>只需要一个，比如线程池、全局缓存。单例模式一般被认为是最简单、最易理解的设计模式，也因为它的简洁易懂，是项目中最常用、最易被识别出来的模式。但<br>单例模式要用好、用对并不是一件简单的事。</p><h2 id="单例模式的问题"><a class="markdownIt-Anchor" href="#单例模式的问题"></a> 单例模式的问题</h2><ul><li>单例模式可以有多种实现方法，需要根据情况作出正确的选择</li><li>单例模式极易被滥用<br>如果某个工程中出现了太多单例，就应该重新审视一下设计。</li><li>单例模式的争议<ul><li>单例既负责实例化类并提供全局访问，又实现了特定的业务逻辑，一定程度上违背了“单一职责原则”，是反模式的。</li><li>单例模式将全局状态（global state）引入了应用，全局状态会引入状态不确定性（state indeterminism），导致微妙的副作用，很容易就会破坏了<br>单元测试的有效性。</li><li>单例导致了类之间的强耦合，扩展性差，违反了面向对象编程的理念。<br>单例封装了自己实例的创建，不适用于继承和多态，同时创建时一般也不传入参数等，难以用一个模拟对象来进行测试。</li></ul></li></ul><h2 id="java单例模式的实现"><a class="markdownIt-Anchor" href="#java单例模式的实现"></a> Java单例模式的实现</h2><h3 id="懒加载线程不安全"><a class="markdownIt-Anchor" href="#懒加载线程不安全"></a> 懒加载，线程不安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒加载线程安全"><a class="markdownIt-Anchor" href="#懒加载线程安全"></a> 懒加载，线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但由于加上了同步机制导致效率降低。</p><h3 id="静态常量"><a class="markdownIt-Anchor" href="#静态常量"></a> 静态常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式基于 classloder 机制，在类加载的时候就完成实例化，Java类加载器初始化静态资源过是线程安全的，避免了线程同步问题。但在类装载的时候就<br>完成实例化，如果从始至终从未使用过这个实例，则会造成内存的浪费。</p><h3 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它和“静态常量”方式不同：“静态常量”方式是只要 Singleton 类被装载了，那么<br>instance 就会被实例化（没有达到 lazy loading 效果，可能造成资源浪费），而“静态内部类”方式是 Singleton 类被装载了，instance 不一定被初始化。<br>因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。</p><h3 id="双重校验锁"><a class="markdownIt-Anchor" href="#双重校验锁"></a> 双重校验锁</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>第一次校验：由于单例模式只需要创建一次实例，如果后面再次调用 getInstance 方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面<br>的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的“静态常量”方式没什么区别，每次都要去竞争锁。</p><p>第二次校验：如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。<br>接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致<br>创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p><p>但这个例子是错误的，问题的原因在于JVM指令重排优化。<br><code>instance = new Singleton();</code> 这行，当某个线程执行这行语句时，构造函数的调用似乎应该在 instance 得到赋值之前发生，但是在java虚拟机内部，<br>却不是这样的，完全有可能先new出来一个空的未调用过构造函数的 instance 对象，然后再将其赋值给 instance 引用，然后再调用构造函数，<br>对 instance 对象当中的元素进行初始化。若紧接着另外一个线程来调用 getInstance，取到的就是状态不正确的对象，程序可能就会出错。</p><h3 id="枚举"><a class="markdownIt-Anchor" href="#枚举"></a> 枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;  </span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">something</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的方式实现单例，可以保证线程安全。</p><h3 id="破除单例模式的方法"><a class="markdownIt-Anchor" href="#破除单例模式的方法"></a> 破除单例模式的方法</h3><h4 id="克隆"><a class="markdownIt-Anchor" href="#克隆"></a> 克隆</h4><p>如果类继承了 Cloneable 接口，并且实现了 clone 方法，尽管这个类的构造函数是私有的，还是可以创建一个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span> <span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;999&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    com.shrill.singleton.<span class="type">Singleton</span> <span class="variable">s</span> <span class="operator">=</span> com.shrill.singleton.Singleton.getInstance();</span><br><span class="line">    com.shrill.singleton.<span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        s1 = (com.shrill.singleton.Singleton) s.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;s  hashCode:&quot;</span> + s.hashCode());</span><br><span class="line">        System.out.println(<span class="string">&quot;s1 hashCode:&quot;</span> + s1.hashCode());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">s  hashCode:<span class="number">1618212626</span></span><br><span class="line">s1 hashCode:<span class="number">1129670968</span></span><br></pre></td></tr></table></figure><p>hash 值不一样，所以克隆成功了，生成了一个新对象。单例模式被成功破坏！</p><h4 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h4><p>假设你的单例模式，实现了 Serializable 接口，那模式可能会被破坏。如下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerSingleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SerSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;999&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SerSingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SerSingleton</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">SerSingleton</span> <span class="variable">s</span> <span class="operator">=</span> SerSingleton.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;z:\\a.bin&quot;</span>))) &#123;</span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;z:\\a.bin&quot;</span>))) &#123;</span><br><span class="line">        s1 = (SerSingleton) ois.readObject();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != s1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s  hashCode:&quot;</span> + s.hashCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 hashCode:&quot;</span> + s1.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">s  hashCode:<span class="number">1729199940</span></span><br><span class="line">s1 hashCode:<span class="number">127618319</span></span><br></pre></td></tr></table></figure><p>解决办法，实现 readResolve 方法，返回 instance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h4><p>通过反射可以执行对象的非公开方法，那么就可以执行对象的私有构造方法，从而构造出一个新的对象，单例模式又被破坏了。解决方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">SerSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != instance) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再说枚举单例模式"><a class="markdownIt-Anchor" href="#再说枚举单例模式"></a> 再说枚举单例模式</h3><p>前面提到枚举的方式实现单例，可以保证线程安全，它是怎样做到呢？<br>定义枚举时使用enum和class一样，是Java中的一个关键字。就像class对应用一个Class类一样，enum也对应有一个Enum类。通过将定义好的枚举反编译就能<br>发现，枚举在经过javac的编译之后，会被转换成形如public final class T extends Enum的定义。而且，枚举中的各个枚举项是通过static来定义的。<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>, Cloneable &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> <span class="string">&quot;999&quot;</span>;</span><br><span class="line"></span><br><span class="line">    SingletonEnum() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SingletonEnum create&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.shrill.singleton.SingletonEnum <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.shrill.singleton.SingletonEnum&gt; <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, java.lang.Cloneable &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.shrill.singleton.SingletonEnum INSTANCE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.shrill.singleton.SingletonEnum[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.shrill.singleton.SingletonEnum <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHashCode</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 INSTANCE 变量加上静态属性，而Java类加载器初始化静态资源过是线程安全的，所以，创建一个enum类型是线程安全的。</p><p>由于枚举没有 clone 方法，即是实现了 Cloneable 也没有 clone 方法可被调用，所以通过 enum 实现的单例模式不会被 clone 破坏。</p><p>对于序列化，枚举的特殊之处又在哪里？普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。即使单例中构造函数是私有的，也会被<br>反射给破坏掉。由于反序列化后的对象是重新 new 出来的，所以这就破坏了单例。Java 序列化枚举对象仅仅是将枚举对象的name属性输出到结果中，反序列化的<br>时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对枚举这种序列化机制的定制，因此禁用了<br>writeObject、readObject等方法。所以通过 enum 实现的单例模式不会被 序列化 破坏。<code>valueOf</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;T&gt;&gt; T <span class="title function_">valueOf</span><span class="params">(Class&lt;T&gt; enumType,</span></span><br><span class="line"><span class="params">                                                String name)</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> enumType.enumConstantDirectory().get(name);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;Name is null&quot;</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">        <span class="string">&quot;No enum constant &quot;</span> + enumType.getCanonicalName() + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用 enumType 这个 Class 对象的 enumConstantDirectory 方法返回的 map 中获取名字为name的枚举对象，如果不存在就会抛出异常。<br>跟进<code>enumConstantDirectory</code>方法,发现到最后会以反射的方式调用 enumType 这个类型的 values() 静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充enumType这个Class对象中的enumConstantDirectory属性。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singletonEnum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingletonEnum</span> <span class="variable">s</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;z:\\b.bin&quot;</span>))) &#123;</span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SingletonEnum</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;z:\\b.bin&quot;</span>))) &#123;</span><br><span class="line">        s1 = (SingletonEnum) ois.readObject();</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != s1) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s  hashCode:&quot;</span> + s.hashCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 hashCode:&quot;</span> + s1.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出:</span></span><br><span class="line"></span><br><span class="line">SingletonEnum create</span><br><span class="line">s  hashCode:<span class="number">1020391880</span></span><br><span class="line">s1 hashCode:<span class="number">1020391880</span></span><br><span class="line">s equals s1 <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>说明序列化后是同一个对象。</p><p>java 语言规范禁止对枚举类型的反射实例化。所以反射也对枚举实现的单例不能起破坏作用。例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">singletonEnum1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SingletonEnum</span> <span class="variable">s</span> <span class="operator">=</span> SingletonEnum.INSTANCE;</span><br><span class="line">    System.out.println(<span class="string">&quot;s  hashCode:&quot;</span> + s.getHashCode());</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clz = SingletonEnum.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;?&gt; c = clz.getConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rcvr</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> rcvr.getClass().getMethod(<span class="string">&quot;getHashCode&quot;</span>);</span><br><span class="line">        method.invoke(rcvr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NoSuchMethodException | SecurityException</span><br><span class="line">        | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">SingletonEnum create</span><br><span class="line">s  hashCode:<span class="number">1618212626</span></span><br><span class="line">java.lang.NoSuchMethodException: com.shrill.singleton.SingletonEnum.&lt;init&gt;()</span><br><span class="line">    at java.lang.Class.getConstructor0(Class.java:<span class="number">3082</span>)</span><br><span class="line">    at java.lang.Class.getConstructor(Class.java:<span class="number">1825</span>)</span><br><span class="line">    at com.shrill.SingletonApp.singletonEnum(SingletonApp.java:<span class="number">62</span>)</span><br></pre></td></tr></table></figure><p>反射会抛出异常。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-05-08T06:44:41.000Z" title="2020-05-08T06:44:41.000Z">2020-05-08</time>发表</span><span class="level-item"><time datetime="2020-05-14T07:39:30.246Z" title="2020-05-14T07:39:30.246Z">2020-05-14</time>更新</span><span class="level-item">10 分钟读完 (大约1531个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/05/08/%E7%AE%80%E4%BB%8BJava%E5%8F%8D%E5%B0%84/">简介Java反射</a></h1><div class="content"><p>在介绍 Java 的反射之前，先对类对象、类加载做个简单说明，大概可以了解 Java 反射的基本原理。</p><h2 id="类文件-类对象和元数据"><a class="markdownIt-Anchor" href="#类文件-类对象和元数据"></a> 类文件、类对象和元数据</h2><ul><li>类文件是编译 Java 源码文件（也可能是其他语言的源码文件）得到的中间格式，供 JVM 使用。类文件是二进制文件，目的不是供人类阅读。</li><li>运行时通过包含元数据的类对象（Class 对象）表示类文件，而类对象表示的是从中创建类文件的 Java 类型。<br>Class 对象保存了类相关的类型信息，当 new 一个新的对象或者引用静态成员变量时，JVM的类加载器会将<br>对应 Class 对象加载在 JVM 中，然后 JVM 再根据这个类型信息相关的 Class 对象构造实例对象或者提供静态变量的引用值。</li></ul><p>在 Java 中，获取类对象有多种方式。其中最简单的方式是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; myCl = getClass();</span><br></pre></td></tr></table></figure><p>上述代码返回调用 getClass() 方法的实例对应的类对象。</p><ul><li>类对象包含指定类型的元数据，包括这个类中定义的方法、字段和构造方法等。<br>例如，可以找出类文件中所有的弃用方法（弃用方法使用 @Deprecated 注解标记）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = getClassFromDisk();</span><br><span class="line"><span class="keyword">for</span> (Method m : clz.getMethods()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (Annotation a : m.getAnnotations()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.annotationType() == Deprecated.class) &#123;</span><br><span class="line">      System.out.println(m.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类文件必须符合非常明确的布局才算合法，JVM 才能加载。</p><h2 id="类加载"><a class="markdownIt-Anchor" href="#类加载"></a> 类加载</h2><p>类加载是把新类型添加到运行中的 JVM 进程里的过程。这是新代码进入 Java 系统的唯一方式，也是 Java 平台中把数据变成代码的唯一方式。<br>Java 的类加载子系统实现了很多安全功能。类加载架构的核心安全机制是，只允许使用一种方式把可执行的代码传入进程——类。<br>因为创建新类只有一种方式，即使用 Classloader 类提供的功能，从字节流中加载类。</p><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><p>反射是在运行时审查、操作和修改对象的能力，可以修改对象的结构和行为，甚至还能自我修改。</p><p>即便编译时不知道类型和方法名称，也能使用反射。反射使用类对象提供的基本元数据，能从类对象中找出方法或字段的名称，然后获取表示方法或字段的对象。</p><p>（使用 Class::newInstance() 或另一个构造方法）创建实例时也能让实例具有反射功能。如果有一个能反射的对象和一个 Method 对象，我们就能在之前<br>类型未知的对象上调用任何方法。</p><h3 id="如何使用反射"><a class="markdownIt-Anchor" href="#如何使用反射"></a> 如何使用反射</h3><p>任何反射操作的第一步都是获取一个 Class 对象，表示要处理的类型。有了这个对象，就能访问表示字段、方法或构造方法的对象，并将其应用于未知类型的实例。</p><p>获取未知类型的实例，最简单的方式是使用没有参数的构造方法，这个构造方法可以直接在 Class 对象上调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; clz = getSomeClassObject();</span><br><span class="line"><span class="type">Object</span> <span class="variable">rcvr</span> <span class="operator">=</span> clz.newInstance();</span><br></pre></td></tr></table></figure><p>如果构造方法有参数，必须找到具体需要使用的构造方法，并使用 Constructor 对象表示。<br>Method 对象是反射 API 提供的对象中最常使用的。Constructor 和 Field 对象在很多方面都和 Method 对象类似。</p><p>下面这个示例在 String 对象上调用 hashCode() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeHashCode</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">rcvr</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt;[] argTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;;</span><br><span class="line">        Object[] args = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> rcvr.getClass().getMethod(<span class="string">&quot;hashCode&quot;</span>, argTypes);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(rcvr, args);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NoSuchMethodException | SecurityException</span><br><span class="line">        | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了获取想使用的 Method 对象，我们在类对象上调用 getMethod() 方法，得到的是一个 Method 对象的引用，指向这个类中对应的公开方法。</p><p>下面这个例子是 通过反射构造一个 String 对象，在上面调用 hashCode() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeHashCode1</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clz = String.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt;[] argTypes = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;&#125;;</span><br><span class="line">        Object[] args = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        Constructor&lt;?&gt; c = clz.getConstructor(String.class);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rcvr</span> <span class="operator">=</span> c.newInstance(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> rcvr.getClass().getMethod(<span class="string">&quot;hashCode&quot;</span>, argTypes);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> method.invoke(rcvr, args);</span><br><span class="line">        System.out.println(ret);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NoSuchMethodException | SecurityException</span><br><span class="line">        | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理非公开方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeSameSeed</span><span class="params">()</span> &#123;</span><br><span class="line">    Class&lt;?&gt; clz = RandomTest.class;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Constructor&lt;?&gt; c = clz.getConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">rcvr</span> <span class="operator">=</span> c.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> rcvr.getClass().getDeclaredMethod(<span class="string">&quot;sameSeed&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(rcvr);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NoSuchMethodException | SecurityException</span><br><span class="line">        | IllegalAccessException | InvocationTargetException | InstantiationException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法不构造实例处理非公开方法的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeSameSeed1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> RandomTest.class.getDeclaredMethod(<span class="string">&quot;sameSeed&quot;</span>);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException | NoSuchMethodException | SecurityException</span><br><span class="line">        | IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射的问题"><a class="markdownIt-Anchor" href="#反射的问题"></a> 反射的问题</h3><p>Java 的反射 API 往往是处理动态加载代码的唯一方式，不过 API 中有些让人头疼的地方，<br>处理起来稍微有点困难：</p><ul><li>大量使用 Object[] 表示调用参数和其他实例；</li><li>大量使用 Class[] 表示类型；</li><li>同名方法可以重载，所以需要维护一个类型组成的数组，区分不同的方法；</li><li>不能很好地表示基本类型——需要手动打包和拆包。</li></ul><h3 id="何时使用反射"><a class="markdownIt-Anchor" href="#何时使用反射"></a> 何时使用反射</h3><p>多数 Java 框架都会适度使用反射。如果编写的架构足够灵活，在运行时之前都不知道要处理什么代码，那么通常会使用反射。<br>反射在测试中也有广泛应用，例如，JUnit 和 TestNG 库都用到了反射，而且创建模拟对象也要使用反射。<br>如果你用过任何一个 Java 框架，即便没有意识到，也几乎可以确定，你使用的是具有反射功能的代码，比如 spring framework。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-04-29T08:01:06.000Z" title="2020-04-29T08:01:06.000Z">2020-04-29</time>发表</span><span class="level-item"><time datetime="2020-04-30T07:05:52.328Z" title="2020-04-30T07:05:52.328Z">2020-04-30</time>更新</span><span class="level-item">12 分钟读完 (大约1743个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/29/Java%E4%B8%AD%E7%9A%84Random%E7%B1%BB/">Java中的Random类</a></h1><div class="content"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>Java中生成随机数的方式有很多，Math.Random()、Random、ThreadLocalRandom、SecureRandom类等。不同的类和方法适用的产生随机数的场景也不一样。<br>伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若<br>使用的初值（种子）不变，那么伪随机数的数序也不变。</p><h2 id="mathrandom"><a class="markdownIt-Anchor" href="#mathrandom"></a> Math.Random()</h2><p>Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该<br>范围内（近似）均匀分布。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mathRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Math.random()=&quot;</span> + Math.random());</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.random()=<span class="number">0.8890842451831729</span></span><br><span class="line">num=<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="random类"><a class="markdownIt-Anchor" href="#random类"></a> Random类</h2><p>Random类有两种构造方法：</p><ul><li>Random()<br>使用系统计时器的当前值作为随机种子来构建Random对象</li><li>Random(long seed)<br>使用指定 long 种子来构建Random对象</li></ul><p>创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=rand.nextInt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>初始种子为10，它对产生的随机数的范围并没有起作用,<code>rand.nextInt(100);</code>中的100是随机数的上限,产生的随机数为0-100的整数,不包括100。</p><h3 id="对于种子相同的random对象生成的随机数序列是一样的"><a class="markdownIt-Anchor" href="#对于种子相同的random对象生成的随机数序列是一样的"></a> 对于种子相同的Random对象，生成的随机数序列是一样的</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">ran1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran1.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="type">Random</span> <span class="variable">ran2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用另一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line">使用另一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="相同的random对象多次调用nextint生成的随机数序列会不同"><a class="markdownIt-Anchor" href="#相同的random对象多次调用nextint生成的随机数序列会不同"></a> 相同的Random对象，多次调用nextInt生成的随机数序列会不同</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">ran2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用另一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用同一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用另一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line">使用同一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">2</span> <span class="number">9</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="不同的random对象采用默认构造函数生成的随机数序列不一样"><a class="markdownIt-Anchor" href="#不同的random对象采用默认构造函数生成的随机数序列不一样"></a> 不同的Random对象，采用默认构造函数，生成的随机数序列不一样</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子缺省是当前系统时间的Random对象生成[0,10)内随机整数序列&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(r3.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Random</span> <span class="variable">r4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子缺省是当前系统时间的Random对象生成[0,10)内随机整数序列&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(r4.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用种子缺省是当前系统时间的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列</span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">使用种子缺省是当前系统时间的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列</span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="random-objects-should-be-reused"><a class="markdownIt-Anchor" href="#random-objects-should-be-reused"></a> “Random” objects should be reused</h3><p>Sonar 的代码审查提出“For better efficiency and randomness, create a single Random, then store, and reuse it.”，主要原因是：</p><ul><li>创建Random是有代价的，如下面的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span> bound)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">return</span> ran.nextInt(bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getRandom每次调用都会构造一个新的Random对象，效率不高。</p><ul><li>随机性不够好，如下面例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span> bound)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ran.nextInt(bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样多次调用getRandom可能得到的值都是一样的，随机性不够好。其实这也是一种随机，只是均匀性，对立性不够了。</p><p>但是如果不需要频繁的获取平均数，将Random对象存储起来，可能会造成Random对象不能被gc，也会造成浪费。</p><h3 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h3><p>Random是一个线程安全类，理论上可以通过它同时在多个线程中获得互不相同的随机数，但是它会因为多线程竞争同一个seed而造成性能下降，所以建议在多线程的<br>情况下采用ThreadLocalRandom来产生随机数。</p><p>Random在执行<code>nextInt</code>时，会调用<code>next</code>函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于seed的类型是AtomicLong，在计算nextseed时是原子操作，所以没有线程安全性的问题。</p><h3 id="securerandom"><a class="markdownIt-Anchor" href="#securerandom"></a> SecureRandom</h3><p>Random类只要种子一样，产生的随机数也一样： 因为种子确定，随机数算法也确定，因此输出就是确定的。</p><ul><li>SecureRandom提供加密的强随机数生成器 (RNG)，要求种子必须是不可预知的，可产生非确定性输出</li><li>SecureRandom许多实现都是伪随机数生成器 (PRNG) 形式，这意味着它们将使用确定的算法根据实际的随机种子生成伪随机序列</li><li>SecureRandom和Random都是如果种子一样，产生的随机数也一样： 因为种子确定，随机数算法也确定，因此输出是确定的。<br>SecureRandom类收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。这意味着，种子是不可预测的，而不像Random默认使用系统当前时间的毫秒数作为种子，有规律可寻。</li></ul><p>不当用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] salt = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis());  <span class="comment">//使用系统时间作为种子</span></span><br><span class="line">secureRandom.nextBytes(salt);</span><br></pre></td></tr></table></figure><p>例子中指定了当前系统时间作为种子，替代系统默认随机源。如果同一毫秒连续调用，则得到的随机数则是相同的。</p><p>系统默认的随机源取决于$JAVA_HOME/jre/lib/security/java.security配置中的securerandom.source属性。例如jdk1.8中该配置为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">securerandom.source=file:/dev/random</span><br></pre></td></tr></table></figure><p>SecureRandom内置两种随机数算法，NativePRNG和SHA1PRNG，看实例化的方法了。默认来说会使用NativePRNG算法生成随机数。</p><p>一般来说尽量避免指定任何随机生成器，只需调用空参数构造函数：<code>new SecureRandom()</code>，让系统选择最好的随机数生成器。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-04-23T08:00:03.000Z" title="2020-04-23T08:00:03.000Z">2020-04-23</time>发表</span><span class="level-item"><time datetime="2020-04-27T11:52:27.499Z" title="2020-04-27T11:52:27.499Z">2020-04-27</time>更新</span><span class="level-item">13 分钟读完 (大约1903个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/java%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/">java循环优化</a></h1><div class="content"><p>在许多应用程序中，循环都扮演着非常重要的角色。为了提升循环的运行效率，研发编译器的工程师提出了不少面向循环的编译优化方式，如循环无关代码外提，循环<br>展开等。</p><p>今天，我们便来了解一下，Java 虚拟机中的即时编译器都应用了哪些面向循环的编译优化。</p><h2 id="循环外提"><a class="markdownIt-Anchor" href="#循环外提"></a> 循环外提</h2><p>所谓的循环无关代码（Loop-invariant Code），指的是循环中值不变的表达式。如果能够在不改变程序语义的情况下，将这些循环无关代码提出循环之外，那么<br>程序便可以避免重复执行这些表达式，从而达到性能提升的效果。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        sum += x * y + ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>[])</span>;</span><br><span class="line">   descriptor: (II[I)I</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">4</span>, locals=<span class="number">6</span>, args_size=<span class="number">4</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">3</span>: iconst_0</span><br><span class="line">        <span class="number">4</span>: istore        <span class="number">5</span></span><br><span class="line">        <span class="comment">// 循环开始</span></span><br><span class="line">        <span class="number">6</span>: iload         <span class="number">5</span></span><br><span class="line">        <span class="number">8</span>: aload_3</span><br><span class="line">        <span class="number">9</span>: arraylength         <span class="comment">// ary.length</span></span><br><span class="line">       <span class="number">10</span>: if_icmpge     <span class="number">32</span>    <span class="comment">// i &lt; ary.length</span></span><br><span class="line">       <span class="number">13</span>: iload         <span class="number">4</span></span><br><span class="line">       <span class="number">15</span>: iload_1</span><br><span class="line">       <span class="number">16</span>: iload_2</span><br><span class="line">       <span class="number">17</span>: imul                <span class="comment">// x*y</span></span><br><span class="line">       <span class="number">18</span>: aload_3</span><br><span class="line">       <span class="number">19</span>: iload         <span class="number">5</span></span><br><span class="line">       <span class="number">21</span>: iaload              <span class="comment">// ary[i]</span></span><br><span class="line">       <span class="number">22</span>: iadd</span><br><span class="line">       <span class="number">23</span>: iadd</span><br><span class="line">       <span class="number">24</span>: istore        <span class="number">4</span></span><br><span class="line">       <span class="number">26</span>: iinc          <span class="number">5</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">29</span>: goto          <span class="number">6</span></span><br><span class="line">       <span class="comment">// 循环结束</span></span><br><span class="line">       <span class="number">32</span>: iload         <span class="number">4</span></span><br><span class="line">       <span class="number">34</span>: ireturn</span><br></pre></td></tr></table></figure><p>在上面这段代码中，循环体中的表达式x*y，以及循环判断条件中的ary.length均属于循环不变代码。<br>前者是一个整数乘法运算，而后者则是内存访问操作，读取数组对象ary的长度。（数组的长度存放于数组对象的对象头中，可通过 arraylength 指令来访问。）</p><p>理想情况下，上面这段代码经过循环无关代码外提之后，等同于下面这一手工优化版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1Opt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t0</span> <span class="operator">=</span> x * y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> ary.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t1; i++) &#123;</span><br><span class="line">        sum += t0 + ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1Opt</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>[])</span>;</span><br><span class="line">  descriptor: (II[I)I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">4</span>, locals=<span class="number">8</span>, args_size=<span class="number">4</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">       <span class="number">3</span>: iload_1</span><br><span class="line">       <span class="number">4</span>: iload_2</span><br><span class="line">       <span class="number">5</span>: imul</span><br><span class="line">       <span class="number">6</span>: istore        <span class="number">5</span></span><br><span class="line">       <span class="number">8</span>: aload_3</span><br><span class="line">       <span class="number">9</span>: arraylength</span><br><span class="line">      <span class="number">10</span>: istore        <span class="number">6</span></span><br><span class="line">      <span class="number">12</span>: iconst_0</span><br><span class="line">      <span class="number">13</span>: istore        <span class="number">7</span></span><br><span class="line">      <span class="comment">// 循环开始</span></span><br><span class="line">      <span class="number">15</span>: iload         <span class="number">7</span></span><br><span class="line">      <span class="number">17</span>: iload         <span class="number">6</span></span><br><span class="line">      <span class="number">19</span>: if_icmpge     <span class="number">40</span></span><br><span class="line">      <span class="number">22</span>: iload         <span class="number">4</span></span><br><span class="line">      <span class="number">24</span>: iload         <span class="number">5</span></span><br><span class="line">      <span class="number">26</span>: aload_3</span><br><span class="line">      <span class="number">27</span>: iload         <span class="number">7</span></span><br><span class="line">      <span class="number">29</span>: iaload          <span class="comment">// ary[i]</span></span><br><span class="line">      <span class="number">30</span>: iadd</span><br><span class="line">      <span class="number">31</span>: iadd</span><br><span class="line">      <span class="number">32</span>: istore        <span class="number">4</span></span><br><span class="line">      <span class="number">34</span>: iinc          <span class="number">7</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">37</span>: goto          <span class="number">15</span></span><br><span class="line">      <span class="comment">// 循环结束</span></span><br><span class="line">      <span class="number">40</span>: iload         <span class="number">4</span></span><br><span class="line">      <span class="number">42</span>: ireturn</span><br></pre></td></tr></table></figure><p>我们可以看到，无论是乘法运算x*y，还是内存访问ary.length，现在都在循环之前完成。原本循环中需要执行这两个表达式的地方，现在直接使用循环之前这两个表达式的执行结果。</p><p>java的JIT实现了循环无关代码的外提。</p><p>即时编译器JIT还外提了 int 数组加载指令iaload所暗含的 null 检测（null check）以及下标范围检测（range check）。<br>如果将iaload指令想象成一个接收数组对象以及下标作为参数，并且返回对应数组元素的方法，那么它的伪代码大致如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iaload</span><span class="params">(<span class="type">int</span>[] aryRef, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (aryRef == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// null 检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= aryRef.length) &#123;</span><br><span class="line">        <span class="comment">// 下标范围检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aryRef[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop1 方法中的 null 检测属于循环无关代码。这是因为它始终检测作为输入参数的 int 数组是否为 null，而这与第几次循环无关。</p><p>为了更好地阐述具体的优化，修改了原来的例子，并将iaload展开，形成如下所示的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// null check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;</span><br><span class="line">            <span class="comment">// range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码段中，null 检测涉及了控制流依赖，无法完成外提。</p><p>在 HotSpot VM的C2编译器 中，null 检测的外提是通过额外的编译优化，也就是循环预测（Loop Prediction，对应虚拟机参数-XX:+UseLoopPredicate）来实现的。该优化的实际做法是在循环之前插入同样的检测代码，并在命中的时候进行去优化。这样一来，循环中的检测代码便会被归纳并消除掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">        deoptimize(); <span class="comment">// never returns</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// now evluate to false</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;</span><br><span class="line">            <span class="comment">// range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2><p>另外一项非常重要的循环优化是循环展开（Loop Unrolling）。它指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        sum += (i % <span class="number">2</span> == <span class="number">0</span>) ? ary[i] : -ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过一次循环展开之后将形成下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的步数是 2</span></span><br><span class="line">        sum += (i % <span class="number">2</span> == <span class="number">0</span>) ? ary[i] : -ary[i];</span><br><span class="line">        sum += ((i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) ? ary[i + <span class="number">1</span>] : -ary[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环展开的缺点显而易见：它可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。</p><p>不过，随着循环体的增大，优化机会也会不断增加。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低。比如前面的例子经过循环展开之后便可以进一步优化为如下所示的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3Opt1</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        sum += ary[i];</span><br><span class="line">        sum += -ary[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他循环优化"><a class="markdownIt-Anchor" href="#其他循环优化"></a> 其他循环优化</h2><p>除了循环无关代码外提以及循环展开之外，即时编译器还有两个比较重要的循环优化技术：循环判断外提（loop unswitching）以及循环剥离（loop peeling）。</p><h3 id="循环判断外提"><a class="markdownIt-Anchor" href="#循环判断外提"></a> 循环判断外提</h3><p>指的是将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            sum += ary[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码经过循环判断外提之后，将变成下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">                sum += ary[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4Opt1</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            sum += ary[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环判断外提与循环无关检测外提所针对的代码模式比较类似，都是循环中的 if 语句。不同的是，后者在检查失败时会抛出异常，中止当前的正常执行路径；而前者所针对的是更加常见的情况，即通过 if 语句的不同分支执行不同的代码逻辑。</p><h3 id="循环剥离"><a class="markdownIt-Anchor" href="#循环剥离"></a> 循环剥离</h3><p>指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。通过将这几个特殊的迭代剥离出去，可以使原本的循环体的规律性更加明显，从而触发进一步的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop5</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        sum += ary[j];</span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码剥离了第一个迭代后，将变成下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop5Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != ary &amp;&amp; <span class="number">0</span> &lt; ary.length) &#123;</span><br><span class="line">        sum += ary[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            sum += ary[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转自"><a class="markdownIt-Anchor" href="#转自"></a> 转自</h2><p>极客时间 -《循环优化》</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-11-18T08:51:51.000Z" title="2019-11-18T08:51:51.000Z">2019-11-18</time>发表</span><span class="level-item"><time datetime="2020-12-28T10:35:41.549Z" title="2020-12-28T10:35:41.549Z">2020-12-28</time>更新</span><span class="level-item">18 分钟读完 (大约2723个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/18/redis5%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">redis5伪集群搭建</a></h1><div class="content"><h2 id="redis的发行版本解释"><a class="markdownIt-Anchor" href="#redis的发行版本解释"></a> Redis的发行版本解释</h2><p>格式: major.minor.patchlevel<br>说明: major 主版本号<br>minor 次版本号，如果为偶数表示当前版本是一个稳定版本，否则是一个非稳定版本(不适合生产环境使用)<br>patchlevel 补丁bug修复</p><h2 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h2><p>redis-6.x 开始的多线程代码依赖 C标准库中的新增类型 _Atomic 。但是 gcc 从 4.9 版本才开始正式和完整地支持 stdatomic（gcc-4.8.5 部分支持），而 centos7 默认的 gcc 版本为：4.8.5，无法正确的编译，所以需要升级 gcc 才能正确的编译 redis-6.x。升级方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  centos-release-scl</span><br><span class="line">yum  -y  install  devtoolset-9-gcc  devtoolset-9-gcc-c++  devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line"><span class="comment">#临时有效，退出 shell 或重启会恢复原 gcc 版本</span></span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"><span class="comment">#长期有效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><p>redis 的编译方法见下文。</p><h2 id="单机安装"><a class="markdownIt-Anchor" href="#单机安装"></a> 单机安装</h2><ol><li><p>下载redis5.0.6二进制安装包<br>wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-5.0.6.tar.gz">http://download.redis.io/releases/redis-5.0.6.tar.gz</a></p></li><li><p>解压到/usr/local目录下<br>tar -xzvf redis-5.0.6.tar.gz -C /usr/local</p></li><li><p>编译<br>cd /usr/local/redis-5.0.6 &amp;&amp; make<br>如果make出错，尝试改用 make MALLOC=libc 编译。</p></li><li><p>指定安装位置<br>make install PREFIX=/usr/local/redis</p></li><li><p>拷贝安装目录下配置文件到 /usr/local/redis/conf<br>mkdir /usr/local/redis/conf<br>cp /usr/local/redis-5.0.6/redis.conf /usr/local/redis/conf/</p></li><li><p>修改配置文件 /usr/local/redis/conf/redis.conf<br>vi /usr/local/redis/conf/redis.conf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 以守护进程后台模式运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 绑定本机ip</span></span><br><span class="line"><span class="built_in">bind</span> 172.18.203.30</span><br><span class="line"><span class="comment"># redis进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis_6379.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/log/redis_6379.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 快照数据存放目录,一定是目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis/data/</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure></li></ol><p>默认的bind 接口是127.0.0.1，也就是本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。<br>改成监听的网卡IP或者 0.0.0.0 可使任意IP均可访问。</p><p>在redis目录创建log和data目录<br>7. 启动redis<br>/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis.conf<br>8. 查看是否启动成功<br>查看进程:<br>ps aux | grep redis<br>查看日志:<br>tail -fn 500 /usr/local/redis/log/redis_6379.log<br>命令端验证:<br>/usr/local/redis/bin/redis-cli -h 172.18.203.30 -p 6379<br>172.18.203.30:6379&gt; ping<br>PONG<br>9. 停止redis服务<br>/usr/local/redis/bin/redis-cli shutdown</p><h2 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h2><p>redis建议三主三从共6个节点组成redis集群，测试环境可一台物理上启动6个redis节点，但生产环境至少要准备3台物理机。</p><ol><li><p>服务器上搭建有6个节点的 Redis集群，在路径为/usr/local/redis/redis-cluster下创建6个文件夹代表6个实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster</span><br><span class="line"><span class="built_in">cd</span> /usr/local/redis/redis-cluster</span><br><span class="line"><span class="built_in">mkdir</span> 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure></li><li><p>分别给这6个文件夹，创建日志、数据存放路径。配置文件放实例路径（如：7000）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7000/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7000/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7001/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7001/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7002/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7002/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7003/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7003/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7004/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7004/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7005/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7005/data</span><br></pre></td></tr></table></figure></li><li><p>进安装redis-cluster的实例目录将 redis.conf 配置文件拷贝到 7000 这个目录，并重名命为 7000.conf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span>  /usr/local/redis-5.0.6/redis.conf /usr/local/redis/redis-cluster/7000/7000.conf</span><br></pre></td></tr></table></figure></li><li><p>分别进入 7000 目录修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改端口号对应目录的端口号</span></span><br><span class="line">port 7000</span><br><span class="line"><span class="comment"># Ip绑定 绑定监听的网卡IP或者改为 0.0.0.0，</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 数据位置dir ./  改为&gt;dir /usr/local/redis/redis-cluster/7000/data</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis/redis-cluster/7000/data</span><br><span class="line"><span class="comment"># 启用集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 集群模式中节点的配置文件，文件不指定路径会在data生成</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="comment"># 超时时间</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># redis数据持久化开启，开启AOF模式</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 非保护模式，允许 Redis 远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># pidfile 需要随着文件夹的不同调增</span></span><br><span class="line">pidfile /usr/local/redis/redis-cluster/7000/redis_7000.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-cluster/7000/log/redis_7000.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 如需密码则修改如下配置</span></span><br><span class="line"><span class="comment"># 在：# requirepass foobared 下新增密码配置</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt; 下新增密码配置</span></span><br><span class="line">masterauth 654321</span><br><span class="line"><span class="comment"># nat或容器，内外网地址不一样的情况下，配置 cluster-announce-ip 为外网地址</span></span><br><span class="line">cluster-announce-ip 212.64.5.128</span><br></pre></td></tr></table></figure></li><li><p>拷贝 7000.conf 到其它配置目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7005/7005.conf</span><br></pre></td></tr></table></figure></li><li><p>如上例修改剩下的 5 个配置，将 7000 改成对应的目录，如7001、7002等</p></li><li><p>加载 6 个redis配置文件启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录启动redis (加载制定配置文件启动的方式)  6个都要启动，注意换配置文件位置</span></span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7000/7000.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7005/7005.conf</span><br><span class="line"><span class="comment"># ps进程看看是否都启动</span></span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建redis集群"><a class="markdownIt-Anchor" href="#创建redis集群"></a> 创建redis集群</h3><ol><li><p>创建redis4.x集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录</span></span><br><span class="line">./redis-trib.rb create --replicas 1 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002</span><br></pre></td></tr></table></figure><p>安装过程中，输入 yes，无报错，结尾出现[OK]即创建成功！</p></li><li><p>创建redis5.x集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis5.x用redis-cli方式 不用redis4.x用的redis-trib.rb方式</span></span><br><span class="line">/usr/local/redis/bin/redis-cli --cluster create 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002 0.0.0.0:7003 0.0.0.0:7004 0.0.0.0:7005 --cluster-replicas 1 -a <span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure><p>需先启动redis。<br>–cluster-replicas 1 表示为集群中的每一个主节点指定一个从节点，即一比一的复制。<br>安装过程中，输入 yes，Reids5 集群搭建完成。</p></li><li><p>重建集群<br>先停止服务，再把各个节点下的 appendonly.aof，dump.rdb，nodes.conf 删除后，重建集群即可。删除各节点 data 中的文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7000/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7001/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7002/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7003/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7004/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7005/data/*</span><br></pre></td></tr></table></figure></li></ol><h2 id="redis5集群其他操作"><a class="markdownIt-Anchor" href="#redis5集群其他操作"></a> Redis5集群其他操作</h2><p>Redis5 提供了关闭集群的工具，在如下目录：<br>/usr/local/redis-5.0.6/utils/create-cluster<br>打开此文件修改端口为我们自己的，如 6999。端口PROT设置为6999，NODES为6，工具会自动累加1 生成 7000-7005 六个节点 用于操作。<br>修改stop代码块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ $((PORT &lt; ENDPORT)) != <span class="string">&quot;0&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">        PORT=$((PORT+<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Stopping <span class="variable">$PORT</span>&quot;</span></span><br><span class="line">        ./redis-cli -p <span class="variable">$PORT</span> -a <span class="string">&quot;123456&quot;</span> shutdown nosave</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="查看集群状态"><a class="markdownIt-Anchor" href="#查看集群状态"></a> 查看集群状态</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看节点详细信息</span><br><span class="line">redis-cli -a <span class="string">&#x27;123456&#x27;</span> -p 7000 cluster info</span><br><span class="line">// 查看所有节点</span><br><span class="line">redis-cli -a <span class="string">&#x27;123456&#x27;</span> -p 7000 cluster nodes</span><br></pre></td></tr></table></figure><h3 id="关闭集群"><a class="markdownIt-Anchor" href="#关闭集群"></a> 关闭集群</h3><p>执行 <code>create-cluster stop</code> 可关闭集群。</p><h3 id="启动集群"><a class="markdownIt-Anchor" href="#启动集群"></a> 启动集群</h3><p>执行 <code>create-cluster start</code> 可启动集群<br>建议启动脚本自己编写。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PORT=6999</span><br><span class="line">NODES=6</span><br><span class="line"></span><br><span class="line">ENDPORT=$((PORT+NODES))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;start&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7000/7000.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7005/7005.conf</span><br><span class="line"><span class="comment"># 配置集群时执行一次</span></span><br><span class="line"><span class="comment"># /usr/local/redis/bin/redis-cli --cluster create 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002 0.0.0.0:7003 0.0.0.0:7004 0.0.0.0:7005 --cluster-replicas 1 -a &#x27;123456&#x27;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ $((PORT &lt; ENDPORT)) != <span class="string">&quot;0&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">        PORT=$((PORT+<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Stopping <span class="variable">$PORT</span>&quot;</span></span><br><span class="line">        ./redis-cli -p <span class="variable">$PORT</span> -a <span class="string">&quot;123456&quot;</span> shutdown nosave</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [start|stop]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start       -- Launch Redis Cluster instances.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;stop        -- Stop Redis Cluster instances.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="redis-启动-3-个警告"><a class="markdownIt-Anchor" href="#redis-启动-3-个警告"></a> redis 启动 3 个警告</h2><h3 id="overcommit_memory-报警"><a class="markdownIt-Anchor" href="#overcommit_memory-报警"></a> overcommit_memory 报警</h3><p>WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</p><p>内核参数 overcommit_memory，它是 内存分配策略<br>可选值：0、1、2。<br>0: 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，<br>并把错误返回给应用进程。<br>1: 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2: 表示内核允许分配超过所有物理内存和交换空间总和的内存</p><p>Linux 对大部分申请内存的请求都回复&quot;yes&quot;，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做 Overcommit。当 linux 发现内存不足时，会发生OOM killer(OOM=out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。<br>当 oom-killer 发生时，linux 会选择杀死哪些进程？选择进程的函数是 oom_badness 函数(在 mm/oom_kill.c 中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟 oom_score_adj 有关，而且 oom_score_adj 可以被设置(-1000最低，1000最高)。</p><p>解决方法：<br>按提示的操作（将vm.overcommit_memory 设为1）即可：<br>有三种方式修改内核参数，但要有root权限：（直接修改宿主机的配置文件）</p><ol><li>编辑/etc/sysctl.conf ，添加 vm.overcommit_memory=1，然后 sysctl -p 使配置文件生效</li><li>sysctl vm.overcommit_memory=1</li><li>echo 1 &gt; /proc/sys/vm/overcommit_memory</li></ol><h3 id="关闭thp"><a class="markdownIt-Anchor" href="#关闭thp"></a> 关闭THP</h3><p>WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to ‘madvise’ or ‘never’).</p><p>Linux kernel 在2.6.38内核增加了 THP 特性， 支持大内存页（2MB） 分配， 默认开启。 当开启时可以降低 fork 子进程的速度， 但 fork 操作之后， 每个内存页从原来4KB变为2MB， 会大幅增加重写期间父进程内存消耗。 同时每次写命令引起的复制内存页单位放大了512倍， 会拖慢写操作的执行时间， 导致大量写操作慢查询， 例如简单的 incr 命令也会出现在慢查询中。 因此 Redis 日志中建议将此特性进行禁用。</p><p>redis 给出的解决方案是将 THP 设置为 madvise 或 never。<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>。<br>为了使机器重启后 THP 配置依然生效，可以在 /etc/rc.local 中追加&quot;echo never&gt;/sys/kernel/mm/transparent_hugepage/enabled&quot;。</p><h3 id="the-tcp-backlog-setting"><a class="markdownIt-Anchor" href="#the-tcp-backlog-setting"></a> The TCP backlog setting</h3><p>WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</p><p>将 net.core.somaxconn=1024 添加到 /etc/sysctl.conf 中，然后执行 sysctl -p 生效配置。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-09-12T09:58:58.000Z" title="2019-09-12T09:58:58.000Z">2019-09-12</time>发表</span><span class="level-item"><time datetime="2019-09-12T10:13:21.036Z" title="2019-09-12T10:13:21.036Z">2019-09-12</time>更新</span><span class="level-item">1 分钟读完 (大约121个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/12/Qt5-12-5-vs2019-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/">Qt5.12.5 &amp; vs2019 静态编译</a></h1><div class="content"><h2 id="qt5125-vs2019-静态编译"><a class="markdownIt-Anchor" href="#qt5125-vs2019-静态编译"></a> Qt5.12.5 &amp; vs2019 静态编译</h2><p>vs2019 编译 Qt5.12.5 的过程和之前记录的<a href="https://gspark.github.io/2019/08/24/Qt5-9-8-vs2019-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/">《Qt5.9.8 &amp; vs2019 静态编译》</a>大致相同。这里记录一下不同的地方。</p><h3 id="需要llvm"><a class="markdownIt-Anchor" href="#需要llvm"></a> 需要LLVM</h3><p>编译 Qt5.12.5 需要 llvm, 下载llvm安装，注意在执行配置Qt之前，在设置环境变量 LLVM_INSTALL_DIR。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> LLVM_INSTALL_DIR=d:\ops\LLVM-<span class="number">8</span>.<span class="number">0</span>.<span class="number">1</span>-win64</span><br></pre></td></tr></table></figure><h3 id="要求openssl版本大于等于11"><a class="markdownIt-Anchor" href="#要求openssl版本大于等于11"></a> 要求openssl版本大于等于1.1</h3><p>编译安装 openssl-1.1.1c 即可。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-09-10T02:56:52.000Z" title="2019-09-10T02:56:52.000Z">2019-09-10</time>发表</span><span class="level-item"><time datetime="2019-09-18T02:25:19.971Z" title="2019-09-18T02:25:19.971Z">2019-09-18</time>更新</span><span class="level-item">5 分钟读完 (大约788个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/09/10/Oracle%E8%BD%ACMySql/">Oracle转MySql</a></h1><div class="content"><p>最近产品要支持MySQl数据库，从Oracle转MySql，记录过程，用以备忘。</p><h2 id="手动转换"><a class="markdownIt-Anchor" href="#手动转换"></a> 手动转换</h2><p>手动方式，就是操作步骤会比较繁琐一些。<br>对 Table 的结构和数据：</p><ol><li>使用 SQL Developer 把 oracle 的 table 的schema 和 Data（.sql 和 .xls） 导出</li><li>使用 MySQL 的 WorkBench 创建 Table 和导入数据。<br>由于语法和数据类型会稍微有一些不同，需要做一些调整。<br>对于 View 来说， 特别是复杂的有子查询的 Oracle View 说，要导入到 MySQL 不是那么容易了，基本上都需要重写。</li></ol><h2 id="使用工具-navicat"><a class="markdownIt-Anchor" href="#使用工具-navicat"></a> 使用工具 Navicat</h2><p>试了好几个工具，只有 Navicat 最方便，不仅能导入表结构，还能导入注释。视图和存储过程要手动导入。</p><ol><li>创建 MySql 数据库。</li><li>启动 Navicat，选择<code>工具</code>菜单下的<code>数据传输</code>子菜单。</li><li>在数据传输对话窗体的<code>常规</code>标签页选择源和目标。这里源选择 Oracle 数据库，目标选择 MySQL 数据库。在<code>选项</code>标签页，找到<code>遇到错误继续</code>，根据情况设置是否勾选。</li><li>点击<code>下一步</code>，在接下来的<code>数据库对象</code>页签选择表（Oracle转MySQl，只能选择表）。</li><li>点击<code>开始</code>等待执行结果。</li><li>手动导入存储过程和视图。由于语法不一样，sql语句需要改写。</li></ol><h2 id="mysql5转mysql8"><a class="markdownIt-Anchor" href="#mysql5转mysql8"></a> MySQL5转MySQL8</h2><p>MySQL5转MySQL8相对比较简单，手动转或者用Navicat转都不复杂，Navicat 还可以导入存储过程和视图。只是 mysql8.0.1 之后的默认 COLLATE 为utf8mb4_0900_ai_ci，如果在转换的时候没注意的话，可能出现 <code>java.sql.SQLException: Illegal mix of collations (utf8mb4_general_ci,IMPLICIT) and (utf8mb4_0900_ai_ci,IMPLICIT) for ***</code> 样的错误。解决方案如下：</p><ol><li>MySQL8建库时，编码选 utf8mb4，COLLATE选 utf8mb4_0900_ai_ci。utf8mb4_unicode_ci和utf8mb4_general_ci对于中文和英文来说，其实没什么太大区别。对于我们开发的国内使用的系统来说，随便选哪个都行。utf8mb4_0900_ai_ci大体上就是unicode的进一步细分，0900指代unicode比较算法的编号（ Unicode Collation Algorithm version），ai表示accent insensitive（发音无关），例如e, è, é, ê 和 ë是一视同仁的。所以选 utf8mb4_0900_ai_ci 没什么问题。</li><li>采用Navicat导入时，在“数据传输”的<code>选项</code>里，注意不要勾选<code>包含字符集</code>。</li></ol><h2 id="linux-下-mysql-重启"><a class="markdownIt-Anchor" href="#linux-下-mysql-重启"></a> linux 下 MySQL 重启</h2><p>由于是从源码包安装的Mysql，所以系统中是没有红帽常用的<code>servcie mysqld restart</code>这个脚本，如果没有自建脚本，只好手工重启。采用 Killall mysql，可能会损害数据库。安全重启的方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$mysql_dir</span>/bin/mysqladmin -u root -p shutdown</span><br><span class="line"><span class="variable">$mysql_dir</span>/bin/./mysqld_safe &amp;</span><br></pre></td></tr></table></figure><p>mysqladmin和mysqld_safe位于Mysql安装目录的bin目录下。</p><p><strong>mysql5.7在 windows 平台也有 mysqladmin 指令，测试可以该指令来停止 mysql 服务。</strong></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-08-24T07:09:24.000Z" title="2019-08-24T07:09:24.000Z">2019-08-24</time>发表</span><span class="level-item"><time datetime="2019-09-12T05:22:07.621Z" title="2019-09-12T05:22:07.621Z">2019-09-12</time>更新</span><span class="level-item">11 分钟读完 (大约1640个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/24/Qt5-9-8-vs2019-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91/">Qt5.9.8 &amp; vs2019 静态编译</a></h1><div class="content"><h2 id="qt598-vs2019-静态编译"><a class="markdownIt-Anchor" href="#qt598-vs2019-静态编译"></a> Qt5.9.8 &amp; vs2019 静态编译</h2><p>简单介绍Qt 5.9.8使用VS2019静态编译的过程以及可能遇到的问题的解决方法。首先是依赖，与运行不同，Qt在编译的时候会有一些其它依赖。请安装好它们并且添加至环境变量。</p><ul><li>Perl version 5.12 or later，<a target="_blank" rel="noopener" href="http://strawberryperl.com">下载</a><br>选用的是strawberry perl，有Portable edition版可选。</li><li>python3</li></ul><p>除了上述依赖之外，Qt还有一些可选的外部库依赖，一些库在Qt源码中已经提供，我们只需要在配置的时候指定一下就好，一些并没有提供，需要自己下载别人编译好的或者需要自己编译。主要有两项，分别是ICU和OpenSSL。</p><h3 id="icu"><a class="markdownIt-Anchor" href="#icu"></a> ICU</h3><p>关于ICU在Qt中用于国际化的处理，如不想编译ICU也可跳过这一章节。编译ICU需要cygwin或者MSYS，采用MSYS没有编译成功，本文记录采用cygwin编译过程。</p><h4 id="源码下载"><a class="markdownIt-Anchor" href="#源码下载"></a> 源码下载</h4><ul><li><a target="_blank" rel="noopener" href="http://site.icu-project.org">icu项目地址</a></li><li>安装<a target="_blank" rel="noopener" href="http://www.cygwin.com/install.html">cygwin</a>，至少安装以下几个工具:<ul><li>make</li><li>dos2unix</li><li>binutils</li></ul></li></ul><h4 id="编译工程"><a class="markdownIt-Anchor" href="#编译工程"></a> 编译工程</h4><ul><li><p>打开命令行，设置环境变量，将 cygwin 的 bin 目录路经加入环境变量，执行命令 set PATH=%PATH%;D:\cygwin\bin</p></li><li><p>配置VC编译环境，执行命令 <code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat&quot;</code></p></li><li><p>进入ICU根目录的 source 文件夹，转换文件，执行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dos2unix *</span><br><span class="line">dos2unix -f configure</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>如果需要编成 MT 的，打开 runConfigureICU 文件，将 Cygwin/MSVC 配置中的 MD 改成 MT</p></li><li><p>配置编译选项，执行命令 <code>bash runConfigureICU Cygwin/MSVC -prefix=/cygdrive/z/icu --enable-static --disable-shared</code></p><ul><li>-prefix: 设置安装目录，注意，以 /cygdrive 开头</li><li>–enable-debug --disable-release：编Debug版本，什么都不加，默认为release</li><li>–enable-static --disable-shared：静态编译 lib</li><li>-–disable-static -–enable-shared：动态编译 dll</li></ul></li><li><p>静态编译，执行命令 <code>make</code> ，注意用 cygwin 的 make</p></li><li><p>编译完成后，安装icu，执行命令 <code>make install</code> 命令执行完毕后，icu的库文件就会复制到之前 -prefix 参数指定的目录中</p></li><li><p>清理临时文件，<code>make.exe clean</code></p></li><li><p>编译debug版，添加 --enable-debug --disable-release 选项无效，可修改runConfigureICU 中</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug=0</span><br><span class="line">release=1</span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">debug=1</span><br><span class="line">release=0</span><br></pre></td></tr></table></figure><p>单独编译出debug版。</p></li></ul><h3 id="openssl"><a class="markdownIt-Anchor" href="#openssl"></a> OpenSSL</h3><p>Qt5.9.8 要求OpenSSL的版本是 &gt;= 1.0.0 并且 &lt; 1.1.0。编译OpenSSL需要 Perl。编译OpenSSL可添加添加zlib支持。</p><h4 id="openssl和zlib下载"><a class="markdownIt-Anchor" href="#openssl和zlib下载"></a> OpenSSL和zlib下载</h4><ul><li><a target="_blank" rel="noopener" href="https://www.openssl.org/source">openssl官网</a></li><li>zlib<a target="_blank" rel="noopener" href="https://www.zlib.net">下载</a></li></ul><h4 id="zlib编译"><a class="markdownIt-Anchor" href="#zlib编译"></a> zlib编译</h4><ul><li>vs2019开发人员命令工具，选择 <code>x64 Native Tools Command Prompt for VS 2019</code></li><li>zlib源码根目录下进入到 contrib\masmx86 下 执行如下命令 <code>bld_ml64.bat</code></li><li>启动 vs2019，打开 \contrib\vstudio\vc14\zlibvc.sln，升级工程</li><li>选择64位编译模式进行编译</li></ul><h4 id="添加zlib支持"><a class="markdownIt-Anchor" href="#添加zlib支持"></a> 添加zlib支持</h4><p>打开openssl\crypto\comp\c_zlib.c，在# include &lt;zlib.h&gt;上方添加#define ZLIB_WINAPI</p><h4 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h4><ul><li>打开命令行，设置perl环境 <code>call portableshell.bat /SETENV</code></li><li>设置vs2019编译环境 <code>call &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Auxiliary\Build\vcvars64.bat&quot;</code></li><li>设置OpenSSL编译选项 <code>call perl Configure VC-WIN64A no-asm no-shared --prefix=%openssl% zlib --with-zlib-include=d:\ops\zlib-1.2.11 --with-zlib-lib=d:\ops\zlib-1.2.11\x64\zlibstat.lib</code><ul><li>输入下面两个命令之一配置编译选项，debug-VC-WIN32表示32位调试模式，VC-WIN64A表示64位模式，no-asm表示不用汇编，no-shared表示编译静态库，–prefix=表示最后生成的目录，zlib表示静态依赖zlib，–with-zlib-include=表示zlib的头文件目录，–with-zlib-lib=表示zlib的静态库文件路径</li></ul></li><li>cd openssl源码路径开始编译<ul><li><p>编译安装1.1.1c版</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmake -f Makefile</span><br><span class="line">nmake -f Makefile install</span><br></pre></td></tr></table></figure></li><li><p>编译安装1.0.2s版</p><ul><li><code>call ms\do_win64a</code></li><li><code>nmake -f ms\nt.mak</code></li><li><code>nmake -f ms\nt.mak install</code></li></ul></li></ul></li></ul><h3 id="编译qt"><a class="markdownIt-Anchor" href="#编译qt"></a> 编译Qt</h3><p><a target="_blank" rel="noopener" href="https://download.qt.io/archive/qt/5.9/5.9.8/single">Qt 5.9.8源码下载</a>，下载 qt-everywhere-opensource-src-5.9.8.zip。</p><ul><li><p>打开命令行，设置perl环境 <code>call portableshell.bat /SETENV</code></p></li><li><p>设置python环境，<code>set PATH=%PATH%;d:\ops\python3</code></p></li><li><p>设置ICU环境变量</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> icu=d:\ops\icu</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;<span class="variable">%icu%</span>\bin</span><br><span class="line"><span class="built_in">set</span> ICU_INCLUDE=<span class="variable">%icu%</span>\include</span><br><span class="line"><span class="built_in">set</span> ICU_LIB=<span class="variable">%icu%</span>\lib</span><br></pre></td></tr></table></figure></li><li><p>设置OpenSSL环境</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> OPENSSL=d:\ops\openssl-<span class="number">1</span>.<span class="number">0</span>.<span class="number">2</span>s</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">PATH</span>=<span class="variable">%PATH%</span>;<span class="variable">%OPENSSL%</span>\bin</span><br><span class="line"><span class="built_in">set</span> OPENSSL_INCLUDE=<span class="variable">%OPENSSL%</span>\include</span><br><span class="line"><span class="built_in">set</span> OPENSSL_LIB=<span class="variable">%OPENSSL%</span>\lib</span><br></pre></td></tr></table></figure></li><li><p>进入Qt源码，创建 build 路径，并进入</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="number">5</span>.<span class="number">9</span>.<span class="number">8</span></span><br><span class="line"><span class="built_in">mkdir</span> qt-build &amp;&amp; <span class="built_in">cd</span> qt-build</span><br></pre></td></tr></table></figure></li><li><p>配置静态编译选项</p><ul><li><p>修改 qtbase\mkspecs\common\msvc-desktop.conf，再找到下面几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MD</span><br><span class="line">QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -MD -Zi</span><br><span class="line">QMAKE_CFLAGS_DEBUG = -Zi -MDd</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QMAKE_CFLAGS_RELEASE = $$QMAKE_CFLAGS_OPTIMIZE -MT</span><br><span class="line">QMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -MT -Zi</span><br><span class="line">QMAKE_CFLAGS_DEBUG = -Zi -MTd</span><br></pre></td></tr></table></figure><p>就是把MD的编译选项改成MT。</p></li><li><p>如果是vs2017及以上版本，修改 qtbase\mkspecs\common\msvc-version.conf，找下面几行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># https://developercommunity.visualstudio.com/content/problem/139261/msvc-incorrectly-defines-cplusplus.html</span><br><span class="line"># QMAKE_CXXFLAGS_CXX14 = -std:c++14</span><br><span class="line"># QMAKE_CXXFLAGS_CXX1Z = -std:c++latest</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># https://developercommunity.visualstudio.com/content/problem/139261/msvc-incorrectly-defines-cplusplus.html</span><br><span class="line">QMAKE_CXXFLAGS_CXX14 = -std:c++14</span><br><span class="line">QMAKE_CXXFLAGS_CXX1Z = -std:c++17</span><br></pre></td></tr></table></figure><p>另一处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(QMAKE_MSC_VER, 1910) &#123;</span><br><span class="line">    # No compat spec past MSVC 2017</span><br><span class="line">    COMPAT_MKSPEC       =</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">greaterThan(QMAKE_MSC_VER, 1910) &#123;</span><br><span class="line">    # No compat spec past MSVC 2017</span><br><span class="line">    DEFINES += _ENABLE_EXTENDED_ALIGNED_STORAGE</span><br><span class="line">    COMPAT_MKSPEC       =</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>设置qt配置选项</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> ..\configure.bat -mp -release -static -static-runtime -confirm-license -platform win32-msvc -opensource -prefix <span class="variable">%QT_INSTALL%</span> -icu -I <span class="variable">%ICU_INCLUDE%</span> -L <span class="variable">%ICU_LIB%</span> ICU_LIBS=&quot;sicudt.lib sicuuc.lib sicuin.lib&quot; -openssl -I <span class="variable">%OPENSSL_INCLUDE%</span> -L <span class="variable">%OPENSSL_LIB%</span> OPENSSL_LIBS=&quot;libeay32.lib ssleay32.lib&quot; -opengl desktop -qt-zlib -nomake examples -nomake tests -skip qt3d -skip qtdatavis3d -skip qtgamepad -skip qtserialport -skip qtspeech -skip qtwayland -skip qtwebengine -skip qtwebview -skip qtremoteobjects</span><br></pre></td></tr></table></figure><p>具体配置详情如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-confirm-license -opensource</span><br><span class="line">-release 版本</span><br><span class="line">-static 静态</span><br><span class="line">-platform win32-msvc 版本</span><br><span class="line">-static-runtime</span><br><span class="line">-mp 多线程编译</span><br><span class="line">-silent 不显示编译时多余的大量信息</span><br><span class="line">-opengl desktop 选择desktop而不是dynamic，避免qcustomplot无法使用opengl</span><br><span class="line">-qt-sqlite 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-pcre 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-zlib 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-freetype 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-harfbuzz 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-libpng 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-qt-libjpeg 三个选项[system/qt/no]选择源码自带</span><br><span class="line">-nomake examples 不编译例子</span><br><span class="line">-nomake tests 不编译测试</span><br></pre></td></tr></table></figure><p>移除了 webengine、qtwebview等组件，qtremoteobjects配置出错，也移除了。</p></li><li><p>编译并安装</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nmake &gt; z:\temp\nmake.out.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">nmake install &gt; z:\temp\nmake_install.out.txt <span class="number">2</span>&gt;&amp;<span class="number">1</span></span><br></pre></td></tr></table></figure><p>安装路径为上一步配置的 <code>-prefix</code> 路径。</p></li></ul><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><p><a target="_blank" rel="noopener" href="https://wiki.qt.io/Compiling-ICU-with-MSVC">Compiling-ICU-with-MSVC</a></p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-08-08T09:28:45.000Z" title="2019-08-08T09:28:45.000Z">2019-08-08</time>发表</span><span class="level-item"><time datetime="2019-08-08T10:28:58.642Z" title="2019-08-08T10:28:58.642Z">2019-08-08</time>更新</span><span class="level-item">5 分钟读完 (大约819个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/08/elasticsearch%E5%AE%89%E8%A3%85/">elasticsearch安装</a></h1><div class="content"><h2 id="elasticsearch安装"><a class="markdownIt-Anchor" href="#elasticsearch安装"></a> elasticsearch安装</h2><h3 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h3><p>从 elastic 的官网 <a target="_blank" rel="noopener" href="http://elastic.co/downloads/elasticsearch">elastic.co/downloads/elasticsearch</a> 获取最新版本的 Elasticsearch。<br>当你准备在生产环境安装 Elasticsearch 时，你可以在 官网下载地址 找 到 Debian 或者 RPM 包，除此之外，你也可以使用官方支持的 Puppet module 或者 Chef cookbook。<br>当你解压好了归档文件之后，Elasticsearch 已经准备好运行了。按照下面的操作，在前台(foregroud)启动 Elasticsearch：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> elasticsearch-&lt;version&gt;</span><br><span class="line">./bin/elasticsearch  </span><br></pre></td></tr></table></figure><p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d 。<br>如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\elasticsearch.bat 而不是 bin\elasticsearch 。<br>测试 Elasticsearch 是否启动成功，可以打开另一个终端，执行以下操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&#x27;http://localhost:9200/?pretty&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><h4 id="jdk"><a class="markdownIt-Anchor" href="#jdk"></a> jdk</h4><p>elasticsearch 的7.3.0需要jdk11，安装包自带了，如果环境中JAVA_HOME不是jdk11的话，修改<code>bin\elasticsearch-env</code>脚本，如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># now set the path to java</span></span><br><span class="line"><span class="comment">##if [ ! -z &quot;$JAVA_HOME&quot; ]; then</span></span><br><span class="line"><span class="comment">##  JAVA=&quot;$JAVA_HOME/bin/java&quot;</span></span><br><span class="line"><span class="comment">##else</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="subst">$(uname -s)</span>&quot;</span> = <span class="string">&quot;Darwin&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># OSX has a different structure</span></span><br><span class="line">    JAVA=<span class="string">&quot;<span class="variable">$ES_HOME</span>/jdk/Contents/Home/bin/java&quot;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    JAVA=<span class="string">&quot;<span class="variable">$ES_HOME</span>/jdk/bin/java&quot;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="comment">##fi</span></span><br></pre></td></tr></table></figure><p>将java路径设置成elasticsearch带的jdk路径。</p><h4 id="远程地址"><a class="markdownIt-Anchor" href="#远程地址"></a> 远程地址</h4><p>默认情况下，Elasticsearch 只允许本机访问，如果需要远程访问，可以修改 Elasticsearch 安装目录中的<code>config/elasticsearch.yml</code>文件，去掉network.host的注释，将它的值改成0.0.0.0，让任何人都可以访问，然后重新启动 Elasticsearch 。</p><h3 id="停止"><a class="markdownIt-Anchor" href="#停止"></a> 停止</h3><p>获取PID</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps | grep Elasticsearch</span><br><span class="line">14542 Elasticsearch</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/elasticsearch -p /tmp/elasticsearch-pid -d</span><br><span class="line">$ <span class="built_in">cat</span> /tmp/elasticsearch-pid &amp;&amp; <span class="built_in">echo</span></span><br><span class="line">15516</span><br><span class="line"><span class="built_in">kill</span> -SIGTERM 15516</span><br></pre></td></tr></table></figure><h3 id="启动问题"><a class="markdownIt-Anchor" href="#启动问题"></a> 启动问题</h3><h4 id="orgelasticsearchbootstrapstartupexception-javalangruntimeexception-can-not-run-elasticsearch-as-root"><a class="markdownIt-Anchor" href="#orgelasticsearchbootstrapstartupexception-javalangruntimeexception-can-not-run-elasticsearch-as-root"></a> org.elasticsearch.bootstrap.StartupException: java.lang.RuntimeException: can not run elasticsearch as root</h4><p>不能用root身份登录<br>解决办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd student</span><br><span class="line">useradd es -g student -p 123</span><br><span class="line"><span class="built_in">chown</span> -R es:student elasticsearch-7.0.0</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adduser es</span><br><span class="line">passwd es</span><br><span class="line">sudo <span class="built_in">chown</span> -R es elasticsearch-&lt;version&gt;/</span><br></pre></td></tr></table></figure><h4 id="max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65535"><a class="markdownIt-Anchor" href="#max-file-descriptors-4096-for-elasticsearch-process-is-too-low-increase-to-at-least-65535"></a> max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</h4><p>问题翻译过来就是：elasticsearch用户拥有的可创建文件描述的权限太低，至少需要65536；</p><p>解决办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">切换到root用户修改</span><br><span class="line"><span class="comment">#vim /etc/security/limits.conf</span></span><br><span class="line">在最后面追加下面内容</span><br><span class="line">*** hard nofile 65536</span><br><span class="line">*** soft nofile 65536</span><br></pre></td></tr></table></figure><p>*** 是启动ES的用户<br>退出用户重新登录，使配置生效<br>重新 ulimit -Hn 查看硬限制 会发现数值有4096改成65535</p><h4 id="max-virtual-memory-areas-vmmax_map_count-65530-is-too-low-increase-to-at-least-262144"><a class="markdownIt-Anchor" href="#max-virtual-memory-areas-vmmax_map_count-65530-is-too-low-increase-to-at-least-262144"></a> max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</h4><p>问题翻译过来就是：elasticsearch用户拥有的内存权限太小，至少需要262144；</p><p>解决办法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">切换到root用户,执行命令：</span><br><span class="line"><span class="comment">#sysctl -w vm.max_map_count=262144</span></span><br><span class="line">查看结果：</span><br><span class="line"><span class="comment">#sysctl -a|grep vm.max_map_count</span></span><br><span class="line">显示：</span><br><span class="line">vm.max_map_count = 262144</span><br></pre></td></tr></table></figure><p>上述方法修改之后，如果重启虚拟机将失效，所以：<br>解决办法：<br>在 /etc/sysctl.conf 文件最后添加一行<br>vm.max_map_count=262144<br>即可永久修改</p><h4 id="the-default-discovery-settings-are-unsuitable-for-production-use-at-least-one-of-discoveryseed_hosts-discoveryseed_providers-clusterinitial_master_nodes-must-be-configured"><a class="markdownIt-Anchor" href="#the-default-discovery-settings-are-unsuitable-for-production-use-at-least-one-of-discoveryseed_hosts-discoveryseed_providers-clusterinitial_master_nodes-must-be-configured"></a> the default discovery settings are unsuitable for production use; at least one of [discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes] must be configured</h4><p>默认的发现设置不适合生产使用;至少有一个[发现]。seed_hosts,发现。seed_providers,集群。必须配置initial_master_nodes]</p><p>这时候继续编辑elasticsearch.yml文件<br>将 #cluster.initial_master_nodes: [“node-1”, “node-2”]<br>修改为 cluster.initial_master_nodes: [“node-1”]，记得保存。</p></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/2/">上一页</a></div><div class="pagination-next"><a href="/page/4/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link is-current" href="/page/3/">3</a></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>