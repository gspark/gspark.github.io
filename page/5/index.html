<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-30T01:38:35.000Z" title="2018-03-30T01:38:35.000Z">2018-03-30</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">11 分钟读完 (大约1713个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/30/%E5%9B%9E%E9%A1%BEJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">回顾Java类加载器</a></h1><div class="content"><h1 id="回顾-java-类加载器"><a class="markdownIt-Anchor" href="#回顾-java-类加载器"></a> 回顾 Java 类加载器</h1><p>类加载器使得 Java 类可以被动态加载到 Java 虚拟机中并执行。类加载器从 JDK 1.0 就出现了，最初是为了满足 Java Applet 的需要而开发出来的。Java Applet 需要从远程下载 Java 类文件到浏览器中并执行。现在类加载器在 Web 容器和 OSGi 中得到了广泛的使用。一般来说，Java 应用的开发人员不需要直接同类加载器进行交互。Java 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 ClassNotFoundException和 NoClassDefFoundError等异常。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java <strong>类</strong>。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><p>基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p><h2 id="classloader-加载类的原理"><a class="markdownIt-Anchor" href="#classloader-加载类的原理"></a> ClassLoader 加载类的原理</h2><h3 id="类加载器的组织结构"><a class="markdownIt-Anchor" href="#类加载器的组织结构"></a> 类加载器的组织结构</h3><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。<br>负责加载 JDK 中的核心类库，如：rt.jar、resources.jar、charsets.jar等。</li><li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>负责加载 Java 的扩展类库，默认加载 JAVA_HOME/jre/lib/ext 目下的所有 jar。</li><li>系统类加载器（system class loader \ app class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li></ul><p>除了系统提供的类加载器以外，可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>类加载器树状组织结构示意图:<br><img src="classloader_tree.jpg" alt="类加载器组织结构"></p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>ClassLoader 使用的是双亲委托模型来搜索类的，每个 ClassLoader 实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它 ClassLoader 实例的的父类加载器。当一个 ClassLoader 实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器 Bootstrap ClassLoader 试图加载，如果没加载到，则把任务转交给 Extension ClassLoader 试图加载，如果也没加载到，则转交给 App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等 URL 中加载该类。如果它们都没有加载到这个类时，则抛出 ClassNotFoundException 异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的 Class 实例对象。</p><h3 id="如何判定两个-java-类是相同的"><a class="markdownIt-Anchor" href="#如何判定两个-java-类是相同的"></a> 如何判定两个 Java 类是相同的</h3><p><strong>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的</strong>。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA 和 ClassLoaderB 分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class 类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。</p><h3 id="为什么是双亲委托"><a class="markdownIt-Anchor" href="#为什么是双亲委托"></a> 为什么是双亲委托</h3><p>双亲委托也可称为代理模式，理解了上诉 Java 虚拟机判断 Java 类是否相同的原理就可明白，采用这种模式的原因是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</p><p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。这种技术在许多框架中都被用到，如 tomcat。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader">深入探讨 Java 类加载器</a></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-22T06:22:31.000Z" title="2018-03-22T06:22:31.000Z">2018-03-22</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">29 分钟读完 (大约4419个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/22/kafka%E5%85%A5%E9%97%A8/">Kafka入门</a></h1><div class="content"><h1 id="kafka入门"><a class="markdownIt-Anchor" href="#kafka入门"></a> Kafka入门</h1><p>Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams（一个Java流式处理库）。</p><h2 id="apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"><a class="markdownIt-Anchor" href="#apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"></a> Apache的Kafka™是一个分布式流平台(a distributed streaming platform)</h2><ol><li>它可以让你发布和订阅记录流。在这方面，它类似于一个消息队列或企业消息系统。</li><li>它可以让你持久化收到的记录流，从而具有容错能力。</li><li>它可以让你处理收到的记录流。</li></ol><h2 id="何为消息系统"><a class="markdownIt-Anchor" href="#何为消息系统"></a> 何为消息系统</h2><p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循<strong>pub-sub</strong>。</p><h3 id="点对点消息系统"><a class="markdownIt-Anchor" href="#点对点消息系统"></a> 点对点消息系统</h3><p>在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。</p><p><img src="p2p-message-system.jpg" alt="点对点消息结构"></p><h3 id="发布-订阅消息系统"><a class="markdownIt-Anchor" href="#发布-订阅消息系统"></a> 发布-订阅消息系统</h3><p>在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。</p><p><img src="ps-message-system.jpg" alt="发布-订阅消息结构"></p><h2 id="kafka通常用于下面的使用场景"><a class="markdownIt-Anchor" href="#kafka通常用于下面的使用场景"></a> Kafka通常用于下面的使用场景</h2><ul><li><p>监控<br>Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。</p></li><li><p>日志聚合方案<br>kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。</p></li><li><p>流式处理<br>流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行变换、处理，然后将结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。</p></li><li><p>解耦<br>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你可以做出独立的扩展或者是修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li></ul><h2 id="kafka的架构"><a class="markdownIt-Anchor" href="#kafka的架构"></a> Kafka的架构</h2><p><img src="kafka-structure.jpg" alt="kafka的架构"></p><p>在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0， 1， 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。<br>假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上。为了在集群的节点间进行负载，每一个broker都会保存一个或多个这样的分区。多个producer和consumer可以同时发布或获取消息。</p><h3 id="相关术语"><a class="markdownIt-Anchor" href="#相关术语"></a> 相关术语</h3><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">topics</td><td style="text-align:left">隶属于特定分类的消息流称为topic。数据保存在topic中</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:left"><strong>topics</strong>会被切分为分区。针对每一个主题，kafka最少保持一个分区。每一个这样的分区以顺序不可变的方式保存消息。一个分区有一个或多个大小相同的<strong>segment</strong>文件组成。<strong>Topics</strong>拥有多个分区，因此可以保存大量的数据</td></tr><tr><td style="text-align:center">Partition offset</td><td style="text-align:left">每个分区中的消息拥有一个唯一的序列id，被称为<strong>offset</strong></td></tr><tr><td style="text-align:center">Replicas of partition</td><td style="text-align:left">分区副本仅仅是分区的备份，不会对副本分区进行读写操作，只是用来防止数据丢失</td></tr><tr><td style="text-align:center">Brokers</td><td style="text-align:left">1. Brokers 是维护发布消息的系统。每个broker针对每个topic可能包含0个或多个该topic的分区。假设，一个topic拥有N个分区，并且集群拥有N个broker，则每个broker会负责一个分区<br>2. 假设，一个topic拥有N个分区，并且集群拥有N+M个broker，则前N个broker每个处理一个分区，剩余的M个broker则不会处理任何分区<br>3。 假设，一个topic拥有N个分区，并且集群拥有M个broker（M &lt; N），则这些分区会在所有的broker中进行均匀分配。每个broker可能会处理一个或多个分区。这种场景不推荐使用，因为会导致热点问题和负载不均衡问题</td></tr><tr><td style="text-align:center">Kafka Cluster</td><td style="text-align:left">由多个broker组成的kafka被称为kafka集群。一个kafka集群在不停机扩展。集群负载所有消息的持久化和副本处理</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">Producers 是向一个或多个Kafka中topic发布消息的发布者。Producers 将消息发送到 Kafka 的 brokers中。任意时刻 producer 发布到broker中的消息都会被追加到某个分区的最后一个segment文件的最后。Producer 也可以选择消息发送到指定的分区</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">Consumers 从broker读取数据。Consumers 订阅一个或多个 topic，并通过pull方式从broker拉取订阅的数据</td></tr><tr><td style="text-align:center">Leader</td><td style="text-align:left">Leader是负责某个分区数据读写操作的节点。每个分区都有一个<strong>leader</strong></td></tr><tr><td style="text-align:center">Follower</td><td style="text-align:left">跟随leader操作的节点被称为follower。如果leader节点不可用，则会从所有的fellower中挑选一个作为新的leader节点。一个follower节点作为leader节点一个普通的消费者，拉取leader数据并更新自己的数据存储</td></tr></tbody></table><h3 id="kafka集群模型"><a class="markdownIt-Anchor" href="#kafka集群模型"></a> kafka集群模型</h3><p><img src="kafka-cluster.jpg" alt="kafka集群模型"><br>下面的表格描述了在上图中提到的每个组件的详细信息。</p><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Broker</td><td style="text-align:left">Kafka集群通常使用多个Broker来实现集群的负载均衡。 Kafka brokers 是无状态的，因为它们使用 ZooKeeper 来保持它们的集群信息。 单个Kafka Broker 每秒可以处理数十万的读写请求，即使保存了TB级的数据也不会影响性能。Kafka broker leader 的选举是通过Zookeeper实现的</td></tr><tr><td style="text-align:center">ZooKeeper</td><td style="text-align:left">ZooKeeper是用来管理和协调Kafka broker 的。ZooKeeper 服务主要用来通知 producer 和 consumer 关于任何新加入Kafka集群或某个Kafka Broker宕机退出集群的消息。 根据收到Zookeeper的关于Broker的存在或失败的消息通知，然后生产者和消费者采取决定，并开始与其它Broker协调它们的任务</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">producer将数据推送给Broker。 当新Broker启动时，所有生产者搜索它并自动发送消息到该新Broker。 Kafka Producer不等待来自Broker的确认，并以Broker可以处理的速度发送消息</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">由于 Kafka brokers 是无状态的， 因此需要Consumer来维护根据partition offset已经消费的消息数量信息。 如果 consumer 确认了一个指定消息的offset，那也就意味着 consumer 已经消费了该offset之前的所有消息。Consumer可以向Broker异步发起一个拉取消息的请求来缓存待消费的消息。consumers 也可以通过提供一个指定的offset值来回溯或跳过Partition中的消息。Consumer 消费消息的offset值是保存在ZooKeeper中的</td></tr></tbody></table><h2 id="kafka工作流程"><a class="markdownIt-Anchor" href="#kafka工作流程"></a> Kafka工作流程</h2><p>Kafka是由分裂为一个或多个partition的topic的集合。 Kafka中的partition可以认为是消息的线性排序序列，其中每个消息由它们的索引（称为offset）来标识。 Kafka集群中的所有数据是每个partition数据分区的并集。 新写入的消息写在分区的末尾，消息由消费者顺序读取。通过将消息复制到不同的Broker来提供持久性。Kafka以快速，可靠，持久，容错和零停机的方式提供基于pub-sub和队列模型的消息系统。 在这两种情况下，生产者只需将消息发送到topic，消费者可以根据自己的需要选择任何一种类型的消息传递系统。</p><h3 id="pub-sub-消息模型工作流程"><a class="markdownIt-Anchor" href="#pub-sub-消息模型工作流程"></a> Pub-Sub 消息模型工作流程</h3><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。Kafka确保所有的消息均匀分布在topic的所有partition上。<strong>如果producer发送了两条消息，并且该topic有两个partition，则每个partition会有一条消息</strong>。</li><li>Consumer 订阅指定的topic。</li><li>一旦消费者订阅了topic，Kafka将向消费者提供topic的当前offset，并且还将offset保存在Zookeeper中。</li><li>消费者将定期请求Kafka（如100 Ms）新消息。</li><li>消费者将收到消息并进行处理。</li><li>一旦消息被处理，消费者将向Kafka broker发送确认。</li><li>一旦Kafka收到确认，它将offset更改为新值，并在Zookeeper中更新它。 由于offset在Zookeeper中被维护，消费者可以正确地读取下一条消息，即使服务器宕机后重启。</li><li>以上流程将重复，直到消费者停止请求。</li><li>消费者可以随时回退/跳转到某个topic的期望offset处，并读取所有后续消息。</li></ul><h3 id="队列消息模型工作流程-consumer-group"><a class="markdownIt-Anchor" href="#队列消息模型工作流程-consumer-group"></a> 队列消息模型工作流程 &amp; Consumer Group</h3><p>在基于队列的消息系统中，取代单个消费者的是订阅了相同topic的一群拥有相同Group ID的消费者集群。简单来说，订阅具有相同“组ID”的主题的消费者被认为是单个组，并且消息在它们之间共享。</p><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。</li><li>单个consumer以名为Group-1的Group ID 订阅名为Topic-01的topic。</li><li>Kafka 会以和Pub-Sub消息模型相同的方式和consumer进行交互直到新的消费者以同样的Group ID加入到消费者分组中。</li><li>一旦新的消费者加入后，Kafka将操作切换到共享模式，将所有topic的消息在两个消费者间进行均衡消费。这种共享行为直到加入的消费者结点数目达到该topic的分区数。</li><li>一旦消费者的数目大于topic的分区数，则新的消费者不会收到任何消息直到已经存在的消费者取消订阅。出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。</li><li>该功能被称为 “Consumer Group”。以同样的方式，Kafka将以非常简单和高效的方式提供这两种系统功能。</li></ul><h2 id="kafka-消息的语义"><a class="markdownIt-Anchor" href="#kafka-消息的语义"></a> kafka 消息的语义</h2><ol><li>消息系统系统一般有以下的语义：<ul><li>At most once：消息可能丢失，但不会重复投递</li><li>At least once：消息不会丢失，但可能会重复投递</li><li>Exactly once：消息不丢失、不重复，会且只会被分发一次（真正想要的）</li></ul></li><li>Producer 发送消息以后，有一个commit的概念，如果commit成功，则意味着消息不会丢失，但是Producer有可能提交成功后，没有收到commit的消息。这有可能造成 at least once 语义。</li><li>从 Consumer 角度来看，我们知道 Offset 是由 Consumer 自己维护。所以何时更新 Offset 就决定了 Consumer 的语义。如果收到消息后更新 Offset，如果 Consumer crash，那新的 Cunsumer再次重启消费，就会造成 At most once 语义（消息会丢，但不重复）。</li><li>如果 Consumser 消费完成后，再更新 Offset。如果 Consumer crash，别的 Consumer 重新用这个 Offser 拉取消息，这个时候就会造成 at least once 的语义（消息不丢，但多次被处理）。</li></ol><p>所以结论：默认Kafka提供at-least-once语义的消息分发，允许用户通过在处理消息之前保存位置信息的方式来提供at-most-once语义。如果我们可以实现消费是幂等的，这个时候就可以认为整个系统是Exactly once的了。</p><h2 id="kafka中的partition和offset"><a class="markdownIt-Anchor" href="#kafka中的partition和offset"></a> kafka中的partition和offset</h2><p>说到分区，就要说kafka对消息的存储.在<a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#replication">官方文档</a>中。</p><p><img src="kafka_partition_log.jpg" alt="分区读写日志图"></p><p>首先，kafka是通过log(日志)来记录消息发布的.每当产生一个消息，kafka会记录到本地的log文件中，这个log和我们平时的log有一定的区别.这里可以参考一下<a target="_blank" rel="noopener" href="http://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html">The Log</a>。</p><h3 id="分区partition"><a class="markdownIt-Anchor" href="#分区partition"></a> 分区partition</h3><p>kafka是为分布式环境设计的，因此如果日志文件，其实也可以理解成消息数据库，放在同一个地方，那么必然会带来可用性的下降，一挂全挂，如果全量拷贝到所有的机器上，那么数据又存在过多的冗余，而且由于每台机器的磁盘大小是有限的，所以即使有再多的机器，可处理的消息还是被磁盘所限制，无法超越当前磁盘大小，因此有了partition的概念。</p><p>kafka对消息进行一定的计算，通过hash来进行分区。这样，就把一份log文件分成了多份。如上面的分区读写日志图，分成多份以后，在单台broker上，比如快速上手中，如果新建topic的时候，我们选择了–replication-factor 1 --partitions 2，那么在log目录里，我们会看到test-0目录和test-1目录.就是两个分区了。</p><h3 id="偏移offset"><a class="markdownIt-Anchor" href="#偏移offset"></a> 偏移offset</h3><p>分区就是一个有序的，不可变的消息队列。新来的commit log持续往后面加数据。这些消息被分配了一个下标(或者偏移)，就是offset，用来定位这一条消息。</p><p>消费者消费到了哪条消息，是保持在消费者这一端的。消息者也可以控制，消费者可以在本地保存最后消息的offset，并间歇性的向zookeeper注册offset，也可以重置offset。</p><p>partition存储的时候，又分成了多个segment(段)，然后通过一个index，索引，来标识第几段。这里先可以去看一下本地log目录的分区文件夹。例如，test-0，这个分区里面，会有一个index文件和一个log文件：<br><img src="kafka_index_log.jpg" alt="index和log"></p><p>对于某个指定的分区，假设每5个消息，作为一个段大小，当产生了10条消息的情况想，目前有会得到：<br>0.index (表示这里index是对0-4做的索引)<br>5.index (表示这里index是对5-9做的索引)<br>10.index (表示这里index是对10-15做的索引，目前还没满)<br>和<br>0.log<br>5.log<br>10.log<br>，当消费者需要读取offset=8的时候，首先kafka对index文件列表进行二分查找，可以算出，应该是在5。index对应的log文件中，然后对对应的5.log文件，进行顺序查找：<br>5-&gt;6-&gt;7-&gt;8，直到顺序找到8就好了。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><p><a target="_blank" rel="noopener" href="https://leokongwq.github.io/2017/02/06/mq-kafka-tutorial.html">kafka入门教程</a></p></li><li><p><a target="_blank" rel="noopener" href="http://leaver.me/2015/09/04/kafka%E4%B8%AD%E7%9A%84partition%E5%92%8Coffset/">kafka中的partition和offset</a></p></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-12T02:53:07.000Z" title="2018-03-12T02:53:07.000Z">2018-03-12</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">14 分钟读完 (大约2170个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/12/Java%E7%9A%84NIO%E8%AF%B4%E6%98%8E/">Java的NIO说明</a></h1><div class="content"><h1 id="java的nio说明"><a class="markdownIt-Anchor" href="#java的nio说明"></a> Java的NIO说明</h1><p>Java NIO，是Java SE 1.4版以后，针对网络传输效能优化的新功能。在Java 7时再推出NIO 2，针对档案存取的效能优化。</p><p>有些资料将 NIO 称之为 Non-block I/O，即非阻塞I/O，这个说法不是很正确。NIO 应该称为 New I/O，参考<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=51">JSR 51: New I/O APIs for the JavaTM Platform</a>。因为NIO支持阻塞和非阻塞这两种模式，所以将NIO称之为 Non-block I/O 就不准确了。</p><p>NIO.2是“APIs for filesystem access, scalable asynchronous I/O operations, socket-channel binding and configuration, and multicast datagrams. ”，上述描述抄自<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=203">JSR 203</a>，简单来说就是一些 API 用于文件系统访问、可伸缩的异步 i/o 操作、套接字通道绑定和配置以及多播数据报。</p><p>由于NIO.2具有异步能力，所以NIO.2又被称为AIO(Asynchronous I/O)。</p><h2 id="名词解释"><a class="markdownIt-Anchor" href="#名词解释"></a> 名词解释</h2><ol><li><p>阻塞和非阻塞<br>阻塞调用在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的<strong>状态</strong>。</p></li><li><p>同步和异步<br>同步，就是在发出一个“调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦<strong>调用返回</strong>，就得到返回值了。换句话说，就是由“调用者”主动等待结果。<br>异步则是相反，“调用”在发出之后，这个调用就直接返回了，没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在“调用”发出后，“被调用者”通过状态、通知来通知调用者，或回调处理这个调用。<br>同步和异步关注的是<strong>获取结果的方式</strong>。<a href="#reference">[1]</a></p><p>从上面的解释来看，虽然阻塞/非阻塞和同步/异步是两组关注点不同的概念，还是存在一些疑惑：</p><ul><li>阻塞和同步的区别是什么？<br>阻塞调用会一直block住对应的进程（线程）直到操作完成，数据从kernel中拷贝到用户内存后，用户进程（线程）解除blocking。同步可以是阻塞的也可以是非阻塞的。</li><li>非阻塞和异步的区别是什么？<br>非阻赛是在kernel还在准备数据的情况下会立刻返回，用户进程（线程）可通过轮询kernel等方式，直到数据准备好再拷贝数据到用户内存来获取数据，这种方式就是同步非阻塞。异步就是用户进程将整个操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据，kernel已经将数据拷贝至用户内存。</li></ul></li></ol><h2 id="nio与aio"><a class="markdownIt-Anchor" href="#nio与aio"></a> NIO与AIO</h2><p>通过上面的解释我们知道了NIA与AIO的区别，由于AIO具备异步的特性，它不需要采用轮询的方式来获取数据，只需等待通知就可以获取数据，摒除了空等，相对NIO来说性能有所提高。</p><h2 id="java-nio-direct-buffer的优势"><a class="markdownIt-Anchor" href="#java-nio-direct-buffer的优势"></a> Java NIO direct buffer的优势</h2><p>以下是官方文档给出的说明：</p><p>Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.</p><p>大致意思是：给定一个直接字节缓冲区，Java虚拟机将尽最大努力直接对它执行本地 I/O 操作。也就是说，它将尝试避免在每次调用某个底层操作系统的本地 I/O操作之前（或之后）将缓冲区内容复制到中间缓冲区（或从中间缓冲区复制到缓冲区）。</p><p>优势很明显，减少一次拷贝过程。</p><p>NIO 操作的时候，那么是不是有这么一个中间缓冲区呢？</p><p>Java NIO 在读写到相应的 Channel 的时候，会先将 Java Heap 的 buffer 内容拷贝至直接内存—— Direct Memory。这样的话，采用 DirectByteBuffer 的性能肯定强于使用 HeapByteBuffer，它省去了临时buffer的拷贝开销，这也是为什么各个NIO框架大多使用DirectByteBuffer的原因。</p><p>绝大部分Channel类都是通过sun.nio.ch.IOUtil，这个工具类和外界进行通讯的，如FileChannel/SocketChannel等等，查看sun.nio.ch.IOUtil#read和sun.nio.ch.IOUtil#write代码可以证明这点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Read-only buffer&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">            var5.flip();</span><br><span class="line">            <span class="keyword">if</span> (var6 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.put(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var1.position();</span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var1.limit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> var5 &lt;= var6;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> var5 &lt;= var6 ? var6 - var5 : <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var8</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var7);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var10;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var8.put(var1);</span><br><span class="line">            var8.flip();</span><br><span class="line">            var1.position(var5);</span><br><span class="line">            <span class="type">int</span> <span class="variable">var9</span> <span class="operator">=</span> writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">            <span class="keyword">if</span> (var9 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.position(var5 + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，如果 var1 是 Directbuffer 就直接拷贝（或写入），否则创建一个临时 Directbuffer，将 var1 写入这个临时 Directbuffer，然后再拷贝（或写入）。</p><p>Java为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？</p><p>HeapByteBuffer 内存是分配在堆上的，直接由 Java 虚拟机负责垃圾收集，DirectByteBuffer 是通过 JNI 在 Java 虚拟机外的内存中分配了一块内存（所以即使在运行时通过 -Xmx 指定了 Java 虚拟机的最大堆内存，还是可能实例化超出该大小的 Direct ByteBuffer），DirectByteBuffer 是用户空间的，它的创建是使用了 malloc 申请的内存，该内存块并不直接由 Java 虚拟机负责垃圾收集，但是在 Direct ByteBuffer 包装类被回收时，会通过 Java Reference 机制来释放该内存块。</p><p>当把一个地址通过JNI传递给底层的C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在GC管理下的对象是会在Java堆中移动的。也就是说，有可能把一个地址传给底层的write，但是这段内存却因为GC整理内存而失效了。所以必须要把待发送的数据放到一个GC管不着的地方。这就是调用native方法之前，数据一定要在堆外内存的原因。DirectBuffer 没有省内存拷贝，但是使用HeapBuffer却需要多一次拷贝，所以相对来说Directbuffer要快。</p><p>此外，Directbuffer 的 GC 压力更小。虽然 GC 仍然管理着 DirectBuffer 的回收，但它是使用 PhantomReference 来达到的，在平常的 Young GC 或者 mark and compact 的时候却不会在内存里搬动。如果IO的数量比较大，比如在网络发送很大的文件，那么 GC 的压力下降就会很明显。<a href="#reference">[2]</a></p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>I/O模型中只有同步阻塞、同步非阻塞和异步，没有异步非阻塞。</p><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>下图是几种常见I/O模型的对比：<br><img src="nio2.jpg" alt="IO module"></p><p>下图是阻塞/非阻塞和同步/异步的小结：<br><img src="IO.jpg" alt="同步/异步"></p><div id="reference"></div><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/60892134/answer/182225677">Java NIO direct buffer的优势在哪儿？</a></p></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-08T06:51:06.000Z" title="2018-03-08T06:51:06.000Z">2018-03-08</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">20 分钟读完 (大约2996个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/08/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">Redis应用场景</a></h1><div class="content"><h1 id="redis应用场景"><a class="markdownIt-Anchor" href="#redis应用场景"></a> Redis应用场景</h1><h2 id="redis介绍"><a class="markdownIt-Anchor" href="#redis介绍"></a> Redis介绍</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。</p><p>Redis的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串，还支持如下抽象数据类型：</p><ul><li>字符串列表</li><li>无序不重复的字符串集合</li><li>有序不重复的字符串集合</li><li>键、值都为字符串的哈希表</li></ul><p>值的类型决定了值本身支持的操作。Redis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。</p><h2 id="redis应用"><a class="markdownIt-Anchor" href="#redis应用"></a> Redis应用</h2><h3 id="会话缓存"><a class="markdownIt-Anchor" href="#会话缓存"></a> 会话缓存</h3><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化、Redis提供的数据类型丰富。例如：缓存用户的登录信息，由于用户登录信息有时比较复杂，如果采用json格式存储，使用起来会简单很多。</p><h3 id="列出最新的项目列表"><a class="markdownIt-Anchor" href="#列出最新的项目列表"></a> 列出最新的项目列表</h3><p>下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> foo <span class="keyword">WHERE</span> … <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>应用中，“列出最新的回复”之类的查询非常普遍。如果数据库进行了分库分表的话，查询会变得复杂而且性能低下。类似的问题就可以用Redis来解决。比如说，我们的一个应用想要列出用户贴出的最新20条评论。我们假设数据库中的每条评论都有一个唯一的ID字段。我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：<br><code>LPUSH latest.comments</code><br>我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：<br><code>LTRIM latest.comments 0 5000</code></p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/list/lpush.html">LPUSH</a><br>LPUSH key value [value …]<br>将一个或多个值 value 插入到列表 key 的表头</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/list/ltrim.html">LTRIM</a><br>LTRIM key start stop<br>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><p>当我们需要获取最新评论的项目范围时，调用一个函数来完成(使用伪代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">getLatestComments</span><span class="params">(start, num_items)</span> &#123;</span><br><span class="line">    id_list = redis.lrange(<span class="string">&quot;latest.comments&quot;</span>,start,start+num_items – <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id_list.length &lt; num_items) &#123;</span><br><span class="line">        id_list = SQL_DB(<span class="string">&quot;SELECT … ORDER BY time LIMIT …&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最新ID常驻在Redis中，并且一直是在更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。当然根据需求也可以不访问数据库。</p><h3 id="排名"><a class="markdownIt-Anchor" href="#排名"></a> 排名</h3><p>还有一个很普遍的需求是按得分排名，在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。典型的比如那些在线游戏的排行榜，根据得分你通常想要：</p><ul><li>列出前100名高分选手</li><li>列出某用户当前的全球排名</li></ul><p>这些操作对于Redis来说很简单，即使你有几百万个用户，每分钟都会有几百万个新的得分。<br>模式是这样的，每次获得新得分时，我们用这样的代码：<br><code>ZADD userscore</code><br>得到前100名高分用户很简单：<br><code>ZREVRANGE userscore 0 99</code><br>用户的全球排名也相似，只需要：<br><code>ZRANK userscore</code></p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zadd.html">ZADD</a><br>ZADD key score member [[score member] [score member] …]<br>将一个或多个 member 元素及其 score 值加入到<strong>有序集</strong> key 当中。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zrevrange.html">ZREVRANGE</a><br>ZREVRANGE key start stop [WITHSCORES]<br>返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列.</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zrank.html">ZRANK</a><br>ZRANK key member<br>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><h3 id="延时任务"><a class="markdownIt-Anchor" href="#延时任务"></a> 延时任务</h3><p>经常有类似的需求:</p><ul><li>订单生成后10分钟,如果用户不付款就关闭订单</li><li>用户超时2天未收货，修改为自动收货</li></ul><p>针对于类似这样的任务,一般我们是用定时任务来处理的。订单是存储在mysql的一个表里,表里会有各种状态和创建时间。利用quartz来设定一个定时任务,我们暂时设置为每5分钟扫描一次。扫描的条件为未付款并且当前时间大于创建时间超过15分钟.然后我们再去逐一的操作每一条数据。这个方案简单易用, 但扫表会增加程序负荷、任务执行不够准时。</p><p>还可以采用延时的方式来处理这样的问题，例如利用jdk自带的delayQueue。delayQueue的有点是：效率高,任务触发时间延迟低，不需要扫表，不会对数据库造成压力。但是delayQueue不支持分布式。</p><p>Redis有2种思路实现延时任务：</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a><br>ZREMRANGEBYSCORE key min max<br>移除有序集 key 中，所有 score 值介于 min 和 max 之间的成员。<br>时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><ul><li><p>有序集合<br>使用 sorted Sets 的自动排序, key 为任务id，score 为任务计划执行时的时间戳，任务在 ZADD 加入 sets 后就已经按时间排序，然后采用 delayQueue 的思路每隔1s(或者其他间隔)用 ZRANGEBYSCORE 取出小于当前时间的的任务id 然后再去执行任务。</p><p>由于有序集合中只有任务id，所以还需要一个哈希表来存储任务，有序集合和哈希表通过任务id关联起来。由于先从集合中取出到期的任务id，再从哈希表中取出任务，这是两次操作，可能出现不满足事务的情况发生。处理方法是采用 Redis 事务机制来实现事务，或者利用 Redis 执行 Lua 脚本是原子性的来采用Lua脚本封装这两个操作。</p></li><li><p>键过期通知<br>Reids 2.8 后有一种“键空间”通知的机制 <a target="_blank" rel="noopener" href="http://redisdoc.com/topic/notification.html">Keyspace Notifications</a>，允许客户端去订阅一些key的事件，其中就有 key过期的事件，我们可以把 key 名称设置为 task 的 id 等标识(这种方式 value 的值无法取到，所以只用 key 来识别任务)，expire 设置为计划要执行的时间，然后设置一个客户端来订阅消息过期事件，然后处理 task。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。可以通过修改 redis.conf 文件，或者直接使用 CONFIGSET 命令来开启或关闭键空间通知功能。配置文件修改方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex  <span class="comment">// 打开此配置，其中Ex表示键事件通知里面的key过期事件，每当有过期键被删除时，会发送通知</span></span><br></pre></td></tr></table></figure><ul><li>notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li><li>当参数不是空字符串时，功能开启。</li></ul><p>Redis 使用以下两种方式删除过期的键：</p><ul><li>当一个键被访问时，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是还没被访问到的键。当过期键被程序发现、并且将键从数据库中删除时，Redis 会产生一个 expired 通知。Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除：如果程序没有访问这个过期键，或者带有生存时间的键非常多的话，那么在键的生存时间变为0 ，直到键真正被删除这中间，可能会有一段比较显著的时间间隔。<br>那么通知产生的时间会有一段间隔，如果不能接受这个间隔，可采用有序集合的方式来实现延时任务。</li></ul></li></ul><h3 id="计数"><a class="markdownIt-Anchor" href="#计数"></a> 计数</h3><p>Redis 是一个很好的计数器，它有 INCRBY 等命令。虽然可以用数据库做计数器，来获取统计或显示新信息，但数据库太慢了。使用 Redis 就不需要再担心了。有了原子递增(atomic increment)，你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。例如这样操作：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR user <span class="number">60</span></span><br></pre></td></tr></table></figure><p>计算出最近用户在页面间停顿超过或不超过60秒的页面浏览量。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/string/incrby.html">INCRBY</a><br>INCRBY key increment<br>将 key 所储存的值加上增量 increment。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h3 id="指定时间内的特定项目"><a class="markdownIt-Anchor" href="#指定时间内的特定项目"></a> 指定时间内的特定项目</h3><p>比如想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。在获得一次新的页面浏览时只需要这样做：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD page:day0:</span><br></pre></td></tr></table></figure><p>当然用unix时间替换day0，比如time()-(time()%3600*24)等等。想知道特定用户的数量吗?只需要使用</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD page:day0:</span><br></pre></td></tr></table></figure><p>计算某个特定用户是否访问了这个页面：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER page:day0:</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/sadd.html">SADD</a><br>SADD key member [member …]<br>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/scard.html">SCARD</a><br>SCARD key<br>返回集合 key 的基数(集合中元素的数量)。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/sismember.html">SISMEMBER</a><br>SISMEMBER key member<br>判断 member 元素是否集合 key 的成员。</p><h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3><p>利用 SETNX 可实现分布式锁。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/string/setnx.html">SETNX</a><br>SETNX key value<br>将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。<br>时间复杂度：O(1)<br>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p>设置成功会返回1，可表示拿到了锁，设置返回 0 表示没拿到锁，继续等待。释放锁可调用 DEL 删除 key。考虑到锁未释放而程序宕机，该锁将不会被释放的情况，可以给锁设置一个过期时间，过期后该锁会被 Redis 删除。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-02T03:39:20.000Z" title="2018-03-02T03:39:20.000Z">2018-03-02</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">15 分钟读完 (大约2295个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">微服务实践中的一些思考</a></h1><div class="content"><h1 id="微服务实践中的一些思考"><a class="markdownIt-Anchor" href="#微服务实践中的一些思考"></a> 微服务实践中的一些思考</h1><h2 id="微服务的目的"><a class="markdownIt-Anchor" href="#微服务的目的"></a> 微服务的目的</h2><p>微服务架构由SOA架构演变而来，SOA是怎样的一种架构，这里不再重复。简单的说微服务与SOA的区别，即微服务不再强调SOA架构里面比较重的ESB工业服务总线，同时强调单个业务系统内部实现真正的组件化。ESB的中心化带来了单点故障隐患；服务统一在ESB上进行部署，也限制了服务的水平扩展，不利于提升性能；此外ESB还包含很多业务相关的功能，如业务流程编排等，限制了业务扩展的灵活性。</p><p>业务的复杂度会随着人们日益增长需求而增长，但每个人能够认知的复杂度都是有限的，在面对高复杂度的时候我们会做关注点分离，这是一个最基本的哲学原则。显然在针对复杂业务场景进行建模时，我们也会应用此原则。这个时候去分离关注点一般可以从两个维度出发：</p><ul><li>技术维度分离，采用类似MVC这样的分层思想进行层次的划分。</li><li>业务维度分离，根据不同的业态划分系统，比如按售前、销售、售后划分。</li></ul><p>以上两个维度没有孰优孰劣之分，在处理复杂问题的时候一定都会用上，SOA时代的ESB（工业服务总线）就是一个典型的技术关注点分离出来的中间件。ESB里面封装了大量的业务规则和流程，让ESB成为了掉入焦油坑的怪兽，成为了各种问题之源。微服务架构某种程度上解决了这些问题（但同时也带来了新的问题）。</p><ul><li>微服务是为了着追求高响应力目标而从业务视角去分离复杂度的手段之一。<br>为了能够高效响应业务的变化，微服务的架构更强调<strong>业务维度的关注点分离，来应对高复杂度</strong>。</li><li>微服务的目的是有效的拆分应用，实现敏捷开发和部署，可以使用不同的编程语言编写的。<br>微服务对应用的拆分采用术语来说，就是业务维度的分离。比如根据商品、订单拆分和部署，甚至数据库也按照这个维度进行拆分，不同的服务不同的库。</li><li>微服务是去ESB、去中心化、分布式的。</li><li>微服务是自洽的。<br>自洽实际上意味着我们的每一个微服务都是一个独立的个体，就像峰群中的蜜蜂一样，他们能单独维护，单独迭代，单独部署，单独测试，单独发布。</li></ul><h2 id="微服务的实践"><a class="markdownIt-Anchor" href="#微服务的实践"></a> 微服务的实践</h2><h3 id="去中心"><a class="markdownIt-Anchor" href="#去中心"></a> 去中心</h3><p>国内进行微服务架构一般会采用spring cloud或者dubbo。这两种孰优孰劣不讨论，在功能上它们有一些共性：<strong>服务治理和服务调用</strong>。为什么服务治理和服务调用成为微服务架构框架的共性呢，原因是微服务的去ESB、去中心、分布式。没有服务治理和调用，访问者不知道服务在哪儿，怎样调用。但这样一来，还是会多出一个服务发现的服务器，如spring采用的是eureka，dubbo采用的是zookeeper。</p><p>由于拆分了很多的服务，服务的配置成了问题，这又多出了提供分布式配置的服务器。</p><p>虽然多了服务发现和服务配置，但是这两个服务没有与业务耦合，从业务的角度确实分离了复杂度。</p><h3 id="业务分离"><a class="markdownIt-Anchor" href="#业务分离"></a> 业务分离</h3><p>业务分离大概是微服务中最难的问题了，业务该怎样分，拆分到哪种力度才算合适。既要考虑产品的需求、产品的升级换代，还要考虑团队的技术能力、开发周期，此外还要考虑运维部署等问题。好的架构是进化而来的，业务分离作为架构的一部分，它也应该有个进化和演进的过程，前期可以相对力度较粗，后期再根据情况适当细化。</p><h3 id="数据一致性"><a class="markdownIt-Anchor" href="#数据一致性"></a> 数据一致性</h3><p>分布式是微服务的特性之一，但分布式在提升系统响应力的同时，带来了数据一致性的问题，而且这个问题很不好解决。像分布式事务、分布式锁都有它们各自的问题，都解决的不彻底。采用最终一致性应该是目前微服务解决数据一致性较好的方案。但实现最终一致性有时会影响用户体验，比如用户取消订单，可能涉及到退还用户优惠券等，采用最终一致性的话，可能出现订单已经取消但优惠券还买有退还到账，用户立即继续购买却没有优惠券可用的情况。</p><p>实现最终一致性一般会用到MQ或者kafka等分布式发布订阅消息系统，它们用来解耦服务之间的调用（主要是用于通知）。比如上面的用户取消订单，订单服务需要通知优惠券服务有优惠券需要退还了。由于消息系统一般是异步的，所以出现了上面体验的问题。当然也可以改成同步，但这样就失去了服务拆分的意义了。</p><h3 id="自洽性"><a class="markdownIt-Anchor" href="#自洽性"></a> 自洽性</h3><p>自洽性要求每个微服务都是独立的个体，相互之间没有没有依赖。但是在实践过程中，很难做到这点。比如在电商微服务中要推送消息，消息的来源有些是订单服务，有些是商品服务，接收方是用户，这样就出现了订单服务可能需要访问用户服务的情况，服务之间形成了依赖。解决的方法通过MQ或者Kafka等消息中间件进行解耦。但是这样一来似乎又多了一个中心，和“去中心”就矛盾了。</p><h2 id="微服务的问题"><a class="markdownIt-Anchor" href="#微服务的问题"></a> 微服务的问题</h2><p>在微服务的实践过程中，如上文所述已经暴露出了一些问题。此外，为了支撑微服务，还增加很多的新的模块或服务，例如：服务发现、服务配置、熔断、日志跟踪、API网关等。增加的服务也就成为了微服务的问题。不过，它们只是在技术的维度增加了复杂度，在业务的维度是降低了复杂度。角度不同，结果也就不同。</p><p>上面提及的问题虽然也提出了方案可以解决，但是并觉得不够优雅，这是否与微服务无关，与采用的框架有关？像spring，把“行为”（也称为逻辑、过程）和“状态”（可理解为数据）分离到不同的对象之中，只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object），而那个只有行为的对象就是我们常用的分层架构中的Logic/Service层。这种开发方式称之为“贫血模型”。当然spring也不是固定就只能使用“贫血模型”做开发，但一般情况spring就是“贫血模型”。</p><p>“贫血模型”不符合<code>面对对象</code>设计的本质：“对象应该拥有状态和行为”。比如汽车，汽车有车厢和轮子这是它的状态，汽车可以开动，可以载人这是它的行为。与“贫血模型”对应的是“充血模型”举个简单的例子，设计一个与汽车（Car）相关的功能：</p><ul><li>贫血的设计一般是：类Car+类CarService 驾驶：CarService.driving(Car car);</li><li>充血的设计则可能会是：类Car 驾驶：car.driving(); Car有一个行为是：驾驶</li></ul><p>“充血模型”符合<code>面向对象</code>的设计，采用这种模型应该能够让技术更好的根据业务来建模，从而技术架构能更好的响应业务架构，使技术架构能够根据业务的变化而自发的改变。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-24T06:40:19.000Z" title="2018-02-24T06:40:19.000Z">2018-02-24</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">5 分钟读完 (大约800个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/24/hexo%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/">hexo安装和配置</a></h1><div class="content"><h1 id="hexo安装和配置"><a class="markdownIt-Anchor" href="#hexo安装和配置"></a> hexo安装和配置</h1><h2 id="hexo简介"><a class="markdownIt-Anchor" href="#hexo简介"></a> hexo简介</h2><p>Hexo是一个快速、简洁且高效的博客框架，支持Markdown格式，有众多优秀插件和主题。</p><p>官网： <a target="_blank" rel="noopener" href="http://hexo.io">http://hexo.io</a><br>github: <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a></p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>先安装node.js，安装完成后再执行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2><p>新建一个文件夹（名字如：hexo，可以随便取），由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。进入那个目录</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>在public目录生成相关html文件。</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>开启本地预览服务，打开浏览器访问 <code>http://localhost:4000</code> 即可看到内容。</p><h2 id="修改主题"><a class="markdownIt-Anchor" href="#修改主题"></a> 修改主题</h2><p>默认主题不好看，改用next主题，<a target="_blank" rel="noopener" href="https://github.com/theme-next/hexo-theme-next">hexo-theme-next</a>。<br>首先安装主题</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>主题都安装到themes目录中。<br>然后修改hexo目录中_config.yml文件，将其中的theme: landscape改为theme: next，然后重新执行<code>hexo g</code>来重新生成。</p><h2 id="传到github"><a class="markdownIt-Anchor" href="#传到github"></a> 传到github</h2><p>如果github pages服务都配置好了，发布上传很容易，一句<code>hexo d</code>就搞定。<br>其次，配置_config.yml中有关deploy的部分：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/gspark/gspark.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>直接执行hexo d的话一般会报如下错误：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer <span class="keyword">not</span> found: github</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer <span class="keyword">not</span> found: git</span><br></pre></td></tr></table></figure><p>原因是还需要安装一个插件：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h2 id="原始md文件管理"><a class="markdownIt-Anchor" href="#原始md文件管理"></a> 原始md文件管理</h2><p>hexo生成的静态页面上传github后，原始的md文件也需要版本管理：<br>对自己的xxx.github.io仓库打一个分支，如hexo，再把hexo目录下对应的代码文件和配置文件上传到这个分支即可。以后再分支上进行md文件的增、删、改、查和对配置文件的修改。</p><h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2><h3 id="资源文件配置"><a class="markdownIt-Anchor" href="#资源文件配置"></a> 资源文件配置</h3><p>通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">_config.yml</span></span><br><span class="line">    <span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>bat hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h3 id="图片路径"><a class="markdownIt-Anchor" href="#图片路径"></a> 图片路径</h3><p>hexo博客图片的问题在于，markdown文章使用的图片路径和hexo博客发布时的图片路径不一致。<br>可使用<a target="_blank" rel="noopener" href="https://github.com/CodeFalling/hexo-asset-image">CodeFalling/hexo-asset-image</a>插件来解决。<br>在hexo的目录下执行</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><p>只要使用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](<span class="link">本地图片测试/logo.jpg</span>)</span><br></pre></td></tr></table></figure><p>就可以插入图片。其中[]里面不写文字则没有图片标题。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-09T06:25:59.000Z" title="2018-02-09T06:25:59.000Z">2018-02-09</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">7 分钟读完 (大约1013个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/09/String%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CString-intern/">String常量池和String.intern</a></h1><div class="content"><h1 id="string常量池和stringintern"><a class="markdownIt-Anchor" href="#string常量池和stringintern"></a> String常量池和String.intern</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>字符串在实际中使用非常频繁，如果为每个字符串常量都生成一个String对象，明显会造成内存的浪费，针对这一问题，JVM实现一个字符串常量池的概念，提供了如下实现：</p><ol><li>相同的字符串常量，在常量池只有一份副本；</li><li>通过双引号声明的字符串，直接保存在常量池中；</li><li>如果是String对象，可以通过String.intern方法，把字符串常量保存到常量池中；</li></ol><p>提示：<br><strong>Jave不仅有字符串常量池，Java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型（Double 、Float）的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用常量池，即JVM不负责创建和管理大于127的这些类的对象。</strong></p><h2 id="intern方法"><a class="markdownIt-Anchor" href="#intern方法"></a> intern方法</h2><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testIntern</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Intern&quot;</span>).append(<span class="string">&quot;StringTest&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;CP&quot;</span>).append(<span class="string">&quot;936&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.intern() == s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.7的结果:<br>true<br>false<br>为什么不是:<br>true<br>true</p><h2 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h2><h3 id="intern的实现"><a class="markdownIt-Anchor" href="#intern的实现"></a> intern的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码（反编译jdk8）看出String.intern在java中是native方法，注释翻译如下：<br>执行intern方法时，如果常量池中存在和String对象相同的字符串，则返回常量池中对应字符串的引用；<br>如果常量池中不存在对应的字符串，则添加该字符串到常量池中，并返回字符串引用。</p><h3 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h3><p>如果是jdk6，上面的代码执行结果会是：false false。jdk7之前常量池的内存在永久代进行分配，永久代和Java堆的内存是物理隔离的，执行intern方法时，如果常量池不存在该字符串，虚拟机会在常量池中复制该字符，再返回并返回引用。jdk6的常量池没有上面例子的两个字符串，所以返回的都是false。</p><p>为什么jdk7返回ture和false呢？原因是jdk7把字符串常量池移到了堆中。</p><ul><li>第一个字符串在常量池中不存在，就要字符串添加到常量池中，由于常量池在堆上，添加的时候只是加上该字符串的引用，没有拷贝的过程，然后再返回该字符串的引用，这样intern返回的引用和s1是同一个引用，所以打印出true；</li><li>第二个打印出false，只有一个原因，常量池中有那个字符串。调试时发现确实在字符串常量池中发现这该字符串，如下图：<br><img src="Instances_java.lang.String.jpg" alt="Instances of java.lang.String"></li></ul><h2 id="字符串常量池大小"><a class="markdownIt-Anchor" href="#字符串常量池大小"></a> 字符串常量池大小</h2><ul><li>1、jdk6是1009</li><li>2、jdk7默认是60013，可以通过-XX:StringTableSize = 10009设置StringTable大小，<br>通过-XX:+PrintFlagsFinal打印虚拟机的Global flags参数，可以获得当前StringTable的大小。</li><li>3、jdk8移除了PermGen，常量池移动了堆上，大小受程序内存的限制。</li></ul></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-07T06:55:42.000Z" title="2018-02-07T06:55:42.000Z">2018-02-07</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">7 分钟读完 (大约1074个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/07/JAVA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0/">JAVA字符串常量池</a></h1><div class="content"><h1 id="java字符串常量池"><a class="markdownIt-Anchor" href="#java字符串常量池"></a> JAVA字符串常量池</h1><p>关于Java字符串常量池的话题很多，先从JVM内存模型说起。</p><h2 id="jvm-内存模型"><a class="markdownIt-Anchor" href="#jvm-内存模型"></a> JVM 内存模型</h2><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、本地方法栈、堆、方法区、程序计数器五个部分。<br><img src="jvm_model.jpg" alt="jvm_model"></p><h3 id="虚拟机栈"><a class="markdownIt-Anchor" href="#虚拟机栈"></a> 虚拟机栈</h3><p>Java虚拟机栈是Java方法执行的内存模型，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈帧(Stack Frame)存储局部变量表，操作数栈，动态链接，方法出口等信息。会抛出StackOverflowError和OOM异常。</p><h3 id="本地方法栈"><a class="markdownIt-Anchor" href="#本地方法栈"></a> 本地方法栈</h3><p>jvm调用操作系统方法所使用的栈。本地方法栈和虚拟机栈非常相似，不同的是虚拟机栈服务的是Java方法，而本地方法栈服务的是Native方法。HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。会抛出StackOverflowError和OOM异常。</p><h3 id="堆"><a class="markdownIt-Anchor" href="#堆"></a> 堆</h3><p>简单的来讲，堆内存用于存放由new创建的对象和数组，在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。</p><h3 id="方法区"><a class="markdownIt-Anchor" href="#方法区"></a> 方法区</h3><p>方法区主要存储了class的一些信息，包括运行时常量池、Classloader的引用，字段数据，方法数据等。永久代（permanent generation）只是HotSpot VM曾经用来实现方法区的一个空间；在JDK8的HotSpot VM它被元数据区（Metaspace）代替。HotSpot中也称为永久代（Permanent Generation），（存储的是除了Java应用程序创建的对象之外，HotSpot虚拟机创建和使用的对象）。方法区在不同虚拟机中有不同的实现。<br><strong>jdk7把字符串常量池移到了堆中。<br>jdk1.8中则把永久代给完全删除了，取而代之的是 MetaSpace。</strong></p><h3 id="程序计数器"><a class="markdownIt-Anchor" href="#程序计数器"></a> 程序计数器</h3><p>jvm执行程序的流水线，存放一些跳转指令。</p><h2 id="什么是java字符串常量池"><a class="markdownIt-Anchor" href="#什么是java字符串常量池"></a> 什么是JAVA字符串常量池</h2><p>Java中的常量池，实际上分为两种形态：静态常量池和运行时常量池。</p><ul><li><p>静态常量池，即*.class文件中的常量池，class文件中的常量池不仅仅包含字符串(数字)字面量，还包含类、方法的信息，占用class文件绝大部分空间。<br>静态常量池存储在方法区，如下图：<br><img src="constant_pool.jpg" alt="constant_pool"></p></li><li><p>运行时常量池，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，我们常说的常量池，就是指方法区中的运行时常量池。</p></li><li><p>运行时常量池（runtime constant pool）其中的引用类型常量（例如CONSTANT_String、CONSTANT_Class、CONSTANT_MethodHandle、CONSTANT_MethodType之类）都存的是引用，实际的对象还是存在Java heap上的。</p></li><li><p>HotSpot VM的StringTable的本体在native memory里。它持有String对象的引用而不是String对象的本体。被引用的String还是在Java heap里。一直到JDK6，这些被intern的String在permgen里，JDK7开始改为放在普通Java heap里。</p></li><li><p>运行时常量池，由于运行时常量池在方法区中，我们可以通过jvm参数：-XX:PermSize、-XX:MaxPermSize来设置方法区大小，从而间接限制常量池大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保持引用，防止自动垃圾回收</span></span><br><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="comment">//通过intern方法向常量池中手动添加常量</span></span><br><span class="line">    l.add(String.valueOf(i++).intern());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序立刻会抛出：Exception in thread “main” java.lang.outOfMemoryError: PermGen space异常。PermGen space正是方法区，足以说明常量池在方法区中。</p><p>JDK8 移除了方法区，转而用Metaspace区域替代,使用新的jvm参数：-XX:MaxMetaspaceSize=8M,运行上面的代码，程序没有抛出异常，但是会触发“Metadata GC Threshold”，说明运行时常量池是划分在Metaspace区域中</p></li></ul></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-07T06:04:43.000Z" title="2018-02-07T06:04:43.000Z">2018-02-07</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">1 分钟读完 (大约178个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/07/Navicat%E5%9C%B0%E5%9D%80/">Navicat地址</a></h1><div class="content"><h1 id="navicat下载地址"><a class="markdownIt-Anchor" href="#navicat下载地址"></a> Navicat下载地址</h1><p>国内Navicat网址是：<a target="_blank" rel="noopener" href="http://www.navicat.com.cn">http://www.navicat.com.cn</a><br>网站只有中文版下载。</p><p>国外Navicat网址是：<a target="_blank" rel="noopener" href="http://www.navicat.com">http://www.navicat.com</a><br>国外 Navicat Premium下载地址：<br><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat9_premium_cs.exe">http://download.navicat.com/download/navicat9_premium_cs.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat100_premium_cs.exe">http://download.navicat.com/download/navicat100_premium_cs.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat110_premium_cs_x86.exe">http://download.navicat.com/download/navicat110_premium_cs_x86.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat110_premium_cs_x64.exe">http://download.navicat.com/download/navicat110_premium_cs_x64.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat112_premium_cs_x86.exe">http://download.navicat.com/download/navicat112_premium_cs_x86.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat112_premium_cs_x64.exe">http://download.navicat.com/download/navicat112_premium_cs_x64.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat120_premium_cs_x86.exe">http://download.navicat.com/download/navicat120_premium_cs_x86.exe</a></p><p><a target="_blank" rel="noopener" href="http://download.navicat.com/download/navicat120_premium_cs_x64.exe">http://download.navicat.com/download/navicat120_premium_cs_x64.exe</a></p><p>需要下载英文版，将地址中的cs改成en即可。文件名字带有版本号规则，如11.0, 11.2, 12.0等。<br>以上地址下载的都是对应版本的最新版。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-05T07:44:35.000Z" title="2018-02-05T07:44:35.000Z">2018-02-05</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">15 分钟读完 (大约2317个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/05/hystrix%E5%9C%A8spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/">hystrix在spring中使用和配置</a></h1><div class="content"><h1 id="hystrix在spring中使用和配置-微服务"><a class="markdownIt-Anchor" href="#hystrix在spring中使用和配置-微服务"></a> hystrix在spring中使用和配置 - 微服务</h1><blockquote><pre><code>这篇文章是整理的一些Hystrix的经验。
</code></pre></blockquote><h2 id="hystrix启用"><a class="markdownIt-Anchor" href="#hystrix启用"></a> Hystrix启用</h2><p>在应用主类中使用 @EnableCircuitBreaker 或 @EnableHystrix 注解开启Hystrix的使用。</p><h2 id="hystrix依赖隔离"><a class="markdownIt-Anchor" href="#hystrix依赖隔离"></a> Hystrix依赖隔离</h2><ul><li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。</li><li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li><li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li><li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li><li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li></ul><h2 id="hystrix流程"><a class="markdownIt-Anchor" href="#hystrix流程"></a> Hystrix流程</h2><p><img src="hystrix-command-flow-chart.png" alt="hystrix command flow chart"></p><p>流程说明：</p><ul><li>1:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中。</li><li>2:执行execute()/queue做同步或异步调用。</li><li>3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤。</li><li>4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤。</li><li>5:调用HystrixCommand的run方法.运行依赖逻辑。</li><li>5a:依赖逻辑调用超时,进入步骤8。</li><li>6:判断逻辑是否调用成功。</li><li>6a:返回成功调用结果。</li><li>6b:调用出错，进入步骤8。</li><li>7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态。</li><li>8:getFallback()降级逻辑.以下四种情况将触发getFallback调用：<ul><li>(1):run()方法抛出非HystrixBadRequestException异常</li><li>(2):run()方法调用超时</li><li>(3):熔断器开启拦截调用</li><li>(4):线程池/队列/信号量是否跑满</li></ul></li><li>8a:没有实现getFallback的Command将直接抛出异常。</li><li>8b:fallback降级逻辑调用成功直接返回。</li><li>8c:降级逻辑调用失败抛出异常。</li><li>9:返回执行成功结果。</li></ul><h2 id="hystrix服务降级"><a class="markdownIt-Anchor" href="#hystrix服务降级"></a> Hystrix服务降级</h2><p>在为具体执行逻辑的函数上增加 @HystrixCommand 注解来指定服务降级方法,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">fallback</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当consumer出现异常的时候，服务请求会通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了fallback。</p><h2 id="hystrix隔离"><a class="markdownIt-Anchor" href="#hystrix隔离"></a> Hystrix隔离</h2><p>Hystrix隔离方式采用线程/信号的方式,通过隔离限制依赖的并发量和阻塞扩散。<br>其实，我们在定义服务降级的时候，已经自动的实现了依赖隔离。</p><h2 id="hystrix熔断器-circuit-breaker"><a class="markdownIt-Anchor" href="#hystrix熔断器-circuit-breaker"></a> Hystrix熔断器 Circuit Breaker</h2><p>每个熔断器默认维护10个bucket,每秒一个bucket,每个bucket记录成功,失败,超时,拒绝的状态，默认错误超过50%且10秒内超过20个请求进行中断拦截.</p><h2 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(groupKey = &quot;productStockOpLog&quot;, commandKey = &quot;addProductStockOpLog&quot;, fallbackMethod = &quot;addProductStockOpLogFallback&quot;,</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;400&quot;),//指定多久超时，单位毫秒。超时进fallback</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//判断熔断的最少请求数，默认是10；只有在一个统计窗口内处理的请求数量达到这个阈值，才会进行熔断与否的判断</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;10&quot;),//判断熔断的阈值，默认值50，表示在一个统计窗口内有50%的请求处理失败，会触发熔断</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProductStockOpLog</span><span class="params">(Long sku_id, Object old_value, Object new_value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (new_value != <span class="literal">null</span> &amp;&amp; !new_value.equals(old_value)) &#123;</span><br><span class="line">        doAddOpLog(<span class="literal">null</span>, <span class="literal">null</span>, sku_id, <span class="literal">null</span>, ProductOpType.PRODUCT_STOCK, old_value != <span class="literal">null</span> ? String.valueOf(old_value) : <span class="literal">null</span>, String.valueOf(new_value), <span class="number">0</span>, <span class="string">&quot;C端&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProductStockOpLogFallback</span><span class="params">(Long sku_id, Object old_value, Object new_value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">&quot;发送商品库存变更消息失败,进入Fallback,skuId:&#123;&#125;,oldValue:&#123;&#125;,newValue:&#123;&#125;&quot;</span>, sku_id, old_value, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例2"><a class="markdownIt-Anchor" href="#例2"></a> 例2：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(groupKey=&quot;UserGroup&quot;, commandKey = &quot;GetUserByIdCommand&quot;，</span></span><br><span class="line"><span class="meta">commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;100&quot;),//指定多久超时，单位毫秒。超时进fallback</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//判断熔断的最少请求数，默认是10；只有在一个统计窗口内处理的请求数量达到这个阈值，才会进行熔断与否的判断</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;10&quot;),//判断熔断的阈值，默认值50，表示在一个统计窗口内有50%的请求处理失败，会触发熔断</span></span><br><span class="line"><span class="meta">&#125;,</span></span><br><span class="line"><span class="meta">threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;30&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;101&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;keepAliveTimeMinutes&quot;, value = &quot;2&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;12&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;1440&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>hystrix函数必须为public，fallback函数可以为private。两者需要返回值和参数相同。</li><li>参数配置：</li></ul><table><thead><tr><th style="text-align:left">参数说明</th><th style="text-align:left">值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">groupKey</td><td style="text-align:left">productStockOpLog</td><td style="text-align:left">group标识，一个group使用一个线程池</td></tr><tr><td style="text-align:left">commandKey</td><td style="text-align:left">addProductStockOpLog</td><td style="text-align:left">command标识</td></tr><tr><td style="text-align:left">fallbackMethod</td><td style="text-align:left">addProductStockOpLogFallback</td><td style="text-align:left">fallback方法，两者需要返回值和参数相同</td></tr><tr><td style="text-align:left">超时时间设置</td><td style="text-align:left">400ms</td><td style="text-align:left">执行策略，在THREAD模式下，达到超时时间，可以中断 For most circuits, you should try to set their timeout values close to the 99.5th percentile of a normal healthy system so they will cut off bad requests and not let them take up system resources or affect user behavi</td></tr><tr><td style="text-align:left">统计窗口（10s）内最少请求数</td><td style="text-align:left">10</td><td style="text-align:left">熔断策略</td></tr><tr><td style="text-align:left">熔断多少秒后去尝试请求</td><td style="text-align:left">5s</td><td style="text-align:left">熔断策略，默认值</td></tr><tr><td style="text-align:left">熔断阀值</td><td style="text-align:left">10%</td><td style="text-align:left">熔断策略：一个统计窗口内有10%的请求处理失败，会触发熔断</td></tr><tr><td style="text-align:left">线程池coreSize</td><td style="text-align:left">10</td><td style="text-align:left">默认值（推荐值）</td></tr><tr><td style="text-align:left">线程池maxQueueSize</td><td style="text-align:left">-1</td><td style="text-align:left">即线程池队列为SynchronousQueue</td></tr></tbody></table><h2 id="配置参数说明"><a class="markdownIt-Anchor" href="#配置参数说明"></a> 配置参数说明</h2><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数</th><th style="text-align:left">作用</th><th style="text-align:left">默认值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">基本参数</td><td style="text-align:left">groupKey</td><td style="text-align:left">表示所属的group，一个group共用线程池</td><td style="text-align:left">getClass().getSimpleName();</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">基本参数</td><td style="text-align:left">commandKey</td><td style="text-align:left"></td><td style="text-align:left">当前执行方法名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution （ 控制HystrixCommand.run()的执行策略）</td><td style="text-align:left">execution.isolation.strategy</td><td style="text-align:left">隔离策略，有THREAD和SEMAPHORE THREAD</td><td style="text-align:left">当前执行方法名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.thread.timeoutInMilliseconds</td><td style="text-align:left">超时时间</td><td style="text-align:left">1000ms</td><td style="text-align:left">默认值：1000 在THREAD模式下，达到超时时间，可以中断 在SEMAPHORE模式下，会等待执行完成后，再去判断是否超时 设置标准： 有retry，99meantime+avg meantime 没有retry，99.5meantime</td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.timeout.enabled</td><td style="text-align:left">是否打开超时</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.thread.interruptOnTimeout</td><td style="text-align:left">是否打开超时线程中断</td><td style="text-align:left">true</td><td style="text-align:left">THREAD模式有效</td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.semaphore.maxConcurrentRequests</td><td style="text-align:left">信号量最大并发度</td><td style="text-align:left">10</td><td style="text-align:left">SEMAPHORE模式有效</td></tr><tr><td style="text-align:left">Fallback （ 设置当fallback降级发生时的策略）</td><td style="text-align:left">fallback.isolation.semaphore.maxConcurrentRequests</td><td style="text-align:left">fallback最大并发度</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Fallback</td><td style="text-align:left">fallback.enabled</td><td style="text-align:left">fallback是否可用</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker （配置熔断的策略）</td><td style="text-align:left">circuitBreaker.enabled</td><td style="text-align:left">是否开启熔断</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.requestVolumeThreshold</td><td style="text-align:left">一个统计窗口内熔断触发的最小个数/10s</td><td style="text-align:left">20</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.sleepWindowInMilliseconds</td><td style="text-align:left">熔断多少秒后去尝试请求</td><td style="text-align:left">5000ms</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.errorThresholdPercentage</td><td style="text-align:left">失败率达到多少百分比后熔断</td><td style="text-align:left">50</td><td style="text-align:left">主要根据依赖重要性进行调整</td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.forceOpen</td><td style="text-align:left">是否强制开启熔断</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.forceClosed</td><td style="text-align:left">是否强制关闭熔断</td><td style="text-align:left"></td><td style="text-align:left">如果是强依赖，应该设置为true</td></tr><tr><td style="text-align:left">Metrics （设置关于HystrixCommand执行需要的统计信息）</td><td style="text-align:left">metrics.rollingStats.timeInMilliseconds</td><td style="text-align:left">设置统计滚动窗口的长度，以毫秒为单位。用于监控和熔断器</td><td style="text-align:left">10000</td><td style="text-align:left">滚动窗口被分隔成桶(bucket)，并且进行滚动。 例如这个属性设置10s(10000)，一个桶是1s</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingStats.numBuckets</td><td style="text-align:left">设置统计窗口的桶数量</td><td style="text-align:left">10</td><td style="text-align:left">metrics.rollingStats.timeInMilliseconds必须能被这个值整除</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.enabled</td><td style="text-align:left">设置执行时间是否被跟踪，并且计算各个百分比，50%,90%等的时间</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.timeInMilliseconds</td><td style="text-align:left">设置执行时间在滚动窗口中保留时间，用来计算百分比</td><td style="text-align:left">60000ms</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.numBuckets</td><td style="text-align:left">设置rollingPercentile窗口的桶数量</td><td style="text-align:left">6</td><td style="text-align:left">metrics.rollingPercentile.timeInMilliseconds必须能被这个值整除</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.bucketSize</td><td style="text-align:left">metrics.rollingPercentile.bucketSize</td><td style="text-align:left">100</td><td style="text-align:left">如果设置为100，但是有500次求情，则只会计算最近的100次</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.healthSnapshot.intervalInMilliseconds</td><td style="text-align:left">采样时间间隔</td><td style="text-align:left">500</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Request Context ( 设置HystrixCommand使用的HystrixRequestContext相关的属性)</td><td style="text-align:left">requestCache.enabled</td><td style="text-align:left">设置是否缓存请求，request-scope内缓存</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Request Context</td><td style="text-align:left">requestLog.enabled</td><td style="text-align:left">设置HystrixCommand执行和事件是否打印到HystrixRequestLog中</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">ThreadPool Properties(配置HystrixCommand使用的线程池的属性)</td><td style="text-align:left">coreSize</td><td style="text-align:left">设置线程池的core size,这是最大的并发执行数量</td><td style="text-align:left">10</td><td style="text-align:left">设置标准：coreSize = requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room 大多数情况下默认的10个线程都是值得建议的</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">maxQueueSize</td><td style="text-align:left">最大队列长度。设置BlockingQueue的最大长度</td><td style="text-align:left">-1</td><td style="text-align:left">默认值：-1 如果使用正数，队列将从SynchronousQueue改为LinkedBlockingQueue</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">queueSizeRejectionThreshold</td><td style="text-align:left">设置拒绝请求的临界值</td><td style="text-align:left">5</td><td style="text-align:left">此属性不适用于maxQueueSize = - 1时 设置设个值的原因是maxQueueSize值运行时不能改变，我们可以通过修改这个变量动态修改允许排队的长度</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">keepAliveTimeMinutes</td><td style="text-align:left">设置keep-live时间</td><td style="text-align:left">1分钟</td><td style="text-align:left">这个一般用不到因为默认corePoolSize和maxPoolSize是一样的</td></tr></tbody></table><h3 id="hystrix官方文档"><a class="markdownIt-Anchor" href="#hystrix官方文档"></a> Hystrix官方文档</h3><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">https://github.com/Netflix/Hystrix/wiki</a></p></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/4/">上一页</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/6/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/4/">4</a></li><li><a class="pagination-link is-current" href="/page/5/">5</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>