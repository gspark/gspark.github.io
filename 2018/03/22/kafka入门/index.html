<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>Kafka入门 - 无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Kafka入门 Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布&amp;#x2F;订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Ka"><meta property="og:type" content="blog"><meta property="og:title" content="Kafka入门"><meta property="og:url" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="Kafka入门 Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布&amp;#x2F;订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Ka"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/p2p-message-system.jpg"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/ps-message-system.jpg"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka-structure.jpg"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka-cluster.jpg"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka_partition_log.jpg"><meta property="og:image" content="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka_index_log.jpg"><meta property="article:published_time" content="2018-03-22T06:22:31.000Z"><meta property="article:modified_time" content="2019-05-15T02:48:47.228Z"><meta property="article:author" content="gspark"><meta property="article:tag" content="microservice"><meta property="article:tag" content="Kafka"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="p2p-message-system.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/"},"headline":"无远弗届","image":["https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/p2p-message-system.jpg","https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/ps-message-system.jpg","https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka-structure.jpg","https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka-cluster.jpg","https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka_partition_log.jpg","https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/kafka_index_log.jpg"],"datePublished":"2018-03-22T06:22:31.000Z","dateModified":"2019-05-15T02:48:47.228Z","author":{"@type":"Person","name":"gspark"},"description":"Kafka入门 Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布&#x2F;订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Ka"}</script><link rel="canonical" href="https://gspark.github.io/2018/03/22/kafka%E5%85%A5%E9%97%A8/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-22T06:22:31.000Z" title="2018-03-22T06:22:31.000Z">2018-03-22</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">29 分钟读完 (大约4419个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Kafka入门</h1><div class="content"><h1 id="kafka入门"><a class="markdownIt-Anchor" href="#kafka入门"></a> Kafka入门</h1><p>Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams（一个Java流式处理库）。</p><h2 id="apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"><a class="markdownIt-Anchor" href="#apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"></a> Apache的Kafka™是一个分布式流平台(a distributed streaming platform)</h2><ol><li>它可以让你发布和订阅记录流。在这方面，它类似于一个消息队列或企业消息系统。</li><li>它可以让你持久化收到的记录流，从而具有容错能力。</li><li>它可以让你处理收到的记录流。</li></ol><h2 id="何为消息系统"><a class="markdownIt-Anchor" href="#何为消息系统"></a> 何为消息系统</h2><p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循<strong>pub-sub</strong>。</p><h3 id="点对点消息系统"><a class="markdownIt-Anchor" href="#点对点消息系统"></a> 点对点消息系统</h3><p>在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。</p><p><img src="p2p-message-system.jpg" alt="点对点消息结构"></p><h3 id="发布-订阅消息系统"><a class="markdownIt-Anchor" href="#发布-订阅消息系统"></a> 发布-订阅消息系统</h3><p>在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。</p><p><img src="ps-message-system.jpg" alt="发布-订阅消息结构"></p><h2 id="kafka通常用于下面的使用场景"><a class="markdownIt-Anchor" href="#kafka通常用于下面的使用场景"></a> Kafka通常用于下面的使用场景</h2><ul><li><p>监控<br>Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。</p></li><li><p>日志聚合方案<br>kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。</p></li><li><p>流式处理<br>流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行变换、处理，然后将结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。</p></li><li><p>解耦<br>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你可以做出独立的扩展或者是修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li></ul><h2 id="kafka的架构"><a class="markdownIt-Anchor" href="#kafka的架构"></a> Kafka的架构</h2><p><img src="kafka-structure.jpg" alt="kafka的架构"></p><p>在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0， 1， 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。<br>假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上。为了在集群的节点间进行负载，每一个broker都会保存一个或多个这样的分区。多个producer和consumer可以同时发布或获取消息。</p><h3 id="相关术语"><a class="markdownIt-Anchor" href="#相关术语"></a> 相关术语</h3><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">topics</td><td style="text-align:left">隶属于特定分类的消息流称为topic。数据保存在topic中</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:left"><strong>topics</strong>会被切分为分区。针对每一个主题，kafka最少保持一个分区。每一个这样的分区以顺序不可变的方式保存消息。一个分区有一个或多个大小相同的<strong>segment</strong>文件组成。<strong>Topics</strong>拥有多个分区，因此可以保存大量的数据</td></tr><tr><td style="text-align:center">Partition offset</td><td style="text-align:left">每个分区中的消息拥有一个唯一的序列id，被称为<strong>offset</strong></td></tr><tr><td style="text-align:center">Replicas of partition</td><td style="text-align:left">分区副本仅仅是分区的备份，不会对副本分区进行读写操作，只是用来防止数据丢失</td></tr><tr><td style="text-align:center">Brokers</td><td style="text-align:left">1. Brokers 是维护发布消息的系统。每个broker针对每个topic可能包含0个或多个该topic的分区。假设，一个topic拥有N个分区，并且集群拥有N个broker，则每个broker会负责一个分区<br>2. 假设，一个topic拥有N个分区，并且集群拥有N+M个broker，则前N个broker每个处理一个分区，剩余的M个broker则不会处理任何分区<br>3。 假设，一个topic拥有N个分区，并且集群拥有M个broker（M &lt; N），则这些分区会在所有的broker中进行均匀分配。每个broker可能会处理一个或多个分区。这种场景不推荐使用，因为会导致热点问题和负载不均衡问题</td></tr><tr><td style="text-align:center">Kafka Cluster</td><td style="text-align:left">由多个broker组成的kafka被称为kafka集群。一个kafka集群在不停机扩展。集群负载所有消息的持久化和副本处理</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">Producers 是向一个或多个Kafka中topic发布消息的发布者。Producers 将消息发送到 Kafka 的 brokers中。任意时刻 producer 发布到broker中的消息都会被追加到某个分区的最后一个segment文件的最后。Producer 也可以选择消息发送到指定的分区</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">Consumers 从broker读取数据。Consumers 订阅一个或多个 topic，并通过pull方式从broker拉取订阅的数据</td></tr><tr><td style="text-align:center">Leader</td><td style="text-align:left">Leader是负责某个分区数据读写操作的节点。每个分区都有一个<strong>leader</strong></td></tr><tr><td style="text-align:center">Follower</td><td style="text-align:left">跟随leader操作的节点被称为follower。如果leader节点不可用，则会从所有的fellower中挑选一个作为新的leader节点。一个follower节点作为leader节点一个普通的消费者，拉取leader数据并更新自己的数据存储</td></tr></tbody></table><h3 id="kafka集群模型"><a class="markdownIt-Anchor" href="#kafka集群模型"></a> kafka集群模型</h3><p><img src="kafka-cluster.jpg" alt="kafka集群模型"><br>下面的表格描述了在上图中提到的每个组件的详细信息。</p><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Broker</td><td style="text-align:left">Kafka集群通常使用多个Broker来实现集群的负载均衡。 Kafka brokers 是无状态的，因为它们使用 ZooKeeper 来保持它们的集群信息。 单个Kafka Broker 每秒可以处理数十万的读写请求，即使保存了TB级的数据也不会影响性能。Kafka broker leader 的选举是通过Zookeeper实现的</td></tr><tr><td style="text-align:center">ZooKeeper</td><td style="text-align:left">ZooKeeper是用来管理和协调Kafka broker 的。ZooKeeper 服务主要用来通知 producer 和 consumer 关于任何新加入Kafka集群或某个Kafka Broker宕机退出集群的消息。 根据收到Zookeeper的关于Broker的存在或失败的消息通知，然后生产者和消费者采取决定，并开始与其它Broker协调它们的任务</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">producer将数据推送给Broker。 当新Broker启动时，所有生产者搜索它并自动发送消息到该新Broker。 Kafka Producer不等待来自Broker的确认，并以Broker可以处理的速度发送消息</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">由于 Kafka brokers 是无状态的， 因此需要Consumer来维护根据partition offset已经消费的消息数量信息。 如果 consumer 确认了一个指定消息的offset，那也就意味着 consumer 已经消费了该offset之前的所有消息。Consumer可以向Broker异步发起一个拉取消息的请求来缓存待消费的消息。consumers 也可以通过提供一个指定的offset值来回溯或跳过Partition中的消息。Consumer 消费消息的offset值是保存在ZooKeeper中的</td></tr></tbody></table><h2 id="kafka工作流程"><a class="markdownIt-Anchor" href="#kafka工作流程"></a> Kafka工作流程</h2><p>Kafka是由分裂为一个或多个partition的topic的集合。 Kafka中的partition可以认为是消息的线性排序序列，其中每个消息由它们的索引（称为offset）来标识。 Kafka集群中的所有数据是每个partition数据分区的并集。 新写入的消息写在分区的末尾，消息由消费者顺序读取。通过将消息复制到不同的Broker来提供持久性。Kafka以快速，可靠，持久，容错和零停机的方式提供基于pub-sub和队列模型的消息系统。 在这两种情况下，生产者只需将消息发送到topic，消费者可以根据自己的需要选择任何一种类型的消息传递系统。</p><h3 id="pub-sub-消息模型工作流程"><a class="markdownIt-Anchor" href="#pub-sub-消息模型工作流程"></a> Pub-Sub 消息模型工作流程</h3><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。Kafka确保所有的消息均匀分布在topic的所有partition上。<strong>如果producer发送了两条消息，并且该topic有两个partition，则每个partition会有一条消息</strong>。</li><li>Consumer 订阅指定的topic。</li><li>一旦消费者订阅了topic，Kafka将向消费者提供topic的当前offset，并且还将offset保存在Zookeeper中。</li><li>消费者将定期请求Kafka（如100 Ms）新消息。</li><li>消费者将收到消息并进行处理。</li><li>一旦消息被处理，消费者将向Kafka broker发送确认。</li><li>一旦Kafka收到确认，它将offset更改为新值，并在Zookeeper中更新它。 由于offset在Zookeeper中被维护，消费者可以正确地读取下一条消息，即使服务器宕机后重启。</li><li>以上流程将重复，直到消费者停止请求。</li><li>消费者可以随时回退/跳转到某个topic的期望offset处，并读取所有后续消息。</li></ul><h3 id="队列消息模型工作流程-consumer-group"><a class="markdownIt-Anchor" href="#队列消息模型工作流程-consumer-group"></a> 队列消息模型工作流程 &amp; Consumer Group</h3><p>在基于队列的消息系统中，取代单个消费者的是订阅了相同topic的一群拥有相同Group ID的消费者集群。简单来说，订阅具有相同“组ID”的主题的消费者被认为是单个组，并且消息在它们之间共享。</p><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。</li><li>单个consumer以名为Group-1的Group ID 订阅名为Topic-01的topic。</li><li>Kafka 会以和Pub-Sub消息模型相同的方式和consumer进行交互直到新的消费者以同样的Group ID加入到消费者分组中。</li><li>一旦新的消费者加入后，Kafka将操作切换到共享模式，将所有topic的消息在两个消费者间进行均衡消费。这种共享行为直到加入的消费者结点数目达到该topic的分区数。</li><li>一旦消费者的数目大于topic的分区数，则新的消费者不会收到任何消息直到已经存在的消费者取消订阅。出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。</li><li>该功能被称为 “Consumer Group”。以同样的方式，Kafka将以非常简单和高效的方式提供这两种系统功能。</li></ul><h2 id="kafka-消息的语义"><a class="markdownIt-Anchor" href="#kafka-消息的语义"></a> kafka 消息的语义</h2><ol><li>消息系统系统一般有以下的语义：<ul><li>At most once：消息可能丢失，但不会重复投递</li><li>At least once：消息不会丢失，但可能会重复投递</li><li>Exactly once：消息不丢失、不重复，会且只会被分发一次（真正想要的）</li></ul></li><li>Producer 发送消息以后，有一个commit的概念，如果commit成功，则意味着消息不会丢失，但是Producer有可能提交成功后，没有收到commit的消息。这有可能造成 at least once 语义。</li><li>从 Consumer 角度来看，我们知道 Offset 是由 Consumer 自己维护。所以何时更新 Offset 就决定了 Consumer 的语义。如果收到消息后更新 Offset，如果 Consumer crash，那新的 Cunsumer再次重启消费，就会造成 At most once 语义（消息会丢，但不重复）。</li><li>如果 Consumser 消费完成后，再更新 Offset。如果 Consumer crash，别的 Consumer 重新用这个 Offser 拉取消息，这个时候就会造成 at least once 的语义（消息不丢，但多次被处理）。</li></ol><p>所以结论：默认Kafka提供at-least-once语义的消息分发，允许用户通过在处理消息之前保存位置信息的方式来提供at-most-once语义。如果我们可以实现消费是幂等的，这个时候就可以认为整个系统是Exactly once的了。</p><h2 id="kafka中的partition和offset"><a class="markdownIt-Anchor" href="#kafka中的partition和offset"></a> kafka中的partition和offset</h2><p>说到分区，就要说kafka对消息的存储.在<a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#replication">官方文档</a>中。</p><p><img src="kafka_partition_log.jpg" alt="分区读写日志图"></p><p>首先，kafka是通过log(日志)来记录消息发布的.每当产生一个消息，kafka会记录到本地的log文件中，这个log和我们平时的log有一定的区别.这里可以参考一下<a target="_blank" rel="noopener" href="http://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html">The Log</a>。</p><h3 id="分区partition"><a class="markdownIt-Anchor" href="#分区partition"></a> 分区partition</h3><p>kafka是为分布式环境设计的，因此如果日志文件，其实也可以理解成消息数据库，放在同一个地方，那么必然会带来可用性的下降，一挂全挂，如果全量拷贝到所有的机器上，那么数据又存在过多的冗余，而且由于每台机器的磁盘大小是有限的，所以即使有再多的机器，可处理的消息还是被磁盘所限制，无法超越当前磁盘大小，因此有了partition的概念。</p><p>kafka对消息进行一定的计算，通过hash来进行分区。这样，就把一份log文件分成了多份。如上面的分区读写日志图，分成多份以后，在单台broker上，比如快速上手中，如果新建topic的时候，我们选择了–replication-factor 1 --partitions 2，那么在log目录里，我们会看到test-0目录和test-1目录.就是两个分区了。</p><h3 id="偏移offset"><a class="markdownIt-Anchor" href="#偏移offset"></a> 偏移offset</h3><p>分区就是一个有序的，不可变的消息队列。新来的commit log持续往后面加数据。这些消息被分配了一个下标(或者偏移)，就是offset，用来定位这一条消息。</p><p>消费者消费到了哪条消息，是保持在消费者这一端的。消息者也可以控制，消费者可以在本地保存最后消息的offset，并间歇性的向zookeeper注册offset，也可以重置offset。</p><p>partition存储的时候，又分成了多个segment(段)，然后通过一个index，索引，来标识第几段。这里先可以去看一下本地log目录的分区文件夹。例如，test-0，这个分区里面，会有一个index文件和一个log文件：<br><img src="kafka_index_log.jpg" alt="index和log"></p><p>对于某个指定的分区，假设每5个消息，作为一个段大小，当产生了10条消息的情况想，目前有会得到：<br>0.index (表示这里index是对0-4做的索引)<br>5.index (表示这里index是对5-9做的索引)<br>10.index (表示这里index是对10-15做的索引，目前还没满)<br>和<br>0.log<br>5.log<br>10.log<br>，当消费者需要读取offset=8的时候，首先kafka对index文件列表进行二分查找，可以算出，应该是在5。index对应的log文件中，然后对对应的5.log文件，进行顺序查找：<br>5-&gt;6-&gt;7-&gt;8，直到顺序找到8就好了。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><p><a target="_blank" rel="noopener" href="https://leokongwq.github.io/2017/02/06/mq-kafka-tutorial.html">kafka入门教程</a></p></li><li><p><a target="_blank" rel="noopener" href="http://leaver.me/2015/09/04/kafka%E4%B8%AD%E7%9A%84partition%E5%92%8Coffset/">kafka中的partition和offset</a></p></li></ol></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/microservice/">microservice</a><a class="link-muted mr-2" rel="tag" href="/tags/Kafka/">Kafka</a></div></article></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/03/30/%E5%9B%9E%E9%A1%BEJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">回顾Java类加载器</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/03/12/Java%E7%9A%84NIO%E8%AF%B4%E6%98%8E/"><span class="level-item">Java的NIO说明</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>