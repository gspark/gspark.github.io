<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>标签: Java - 无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Java</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-12-23T09:03:52.000Z" title="2020-12-23T09:03:52.000Z">2020-12-23</time>发表</span><span class="level-item"><time datetime="2020-12-24T01:46:56.636Z" title="2020-12-24T01:46:56.636Z">2020-12-24</time>更新</span><span class="level-item">4 分钟读完 (大约658个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/23/Java-send-mail/">Java send mail</a></h1><div class="content"><p>使用 Java 发送电子邮件主要有两个方法，一个是使用 sun 公司的 mail 包，另一个是使用 SpringBoot。SpringBoot 的封装更简单。<br>这里简单介绍使用 SpringBoot 发送邮件的方法和使用时的注意点。</p><h2 id="smtpsmtps-协议"><a class="markdownIt-Anchor" href="#smtpsmtps-协议"></a> SMTP/SMTPS 协议</h2><p>SMTP（Simple Mail Transfer Protocal）称为简单邮件传输协议。SMTP 是一个请求/响应协议，它监听25号端口，用于接收用户的 Mail 请求，并与远端 Mail 服务器建立 SMTP 连接。<br>SMTPS（SMTP-over-SSL）为 SMTP 协议基于 SSL 安全协议之上的一种变种协议。它继承了 SSL 安全协议的非对称加密的高度安全可靠性，可防止邮件泄露。</p><p>如今绝大多数邮件服务器都使用 SMTP/SMTPS 协议。</p><h2 id="引入依赖库"><a class="markdownIt-Anchor" href="#引入依赖库"></a> 引入依赖库</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续查看 spring-boot-starter-mail 的依赖树可以发现，它是对 sun 公司的 mail 包进行了封装。</p><h2 id="参数配置"><a class="markdownIt-Anchor" href="#参数配置"></a> 参数配置</h2><p>在 application.yml 里进行邮件发送的相关参数配置，示例如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">mail.163.com</span> <span class="comment">#发送邮件服务器</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">xxx@163.com</span> <span class="comment">#发送邮件的邮箱地址</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">xXx@163.com</span> <span class="comment"># 发送邮件的地址，和上面username一致</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">sss@163.com</span></span><br><span class="line">    <span class="attr">default-encoding:</span> <span class="string">utf-8</span></span><br><span class="line">    <span class="attr">protocol:</span> <span class="string">smtps</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">    <span class="attr">properties:</span></span><br><span class="line">      <span class="attr">mail:</span></span><br><span class="line">        <span class="attr">smtp:</span></span><br><span class="line">          <span class="attr">auth:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">starttls:</span></span><br><span class="line">            <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">required:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">test-connection:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>上面的配置有几个需要注意的点：</p><ol><li>password 是客户端授权码，有客户端授权码填授权码，没有的话，填发送邮箱的密码。</li><li>protocol 需要填写。<br><strong>邮件服务器采用 SMTPS 发送协议，protocol 的值要写成 smtps；如果采用 SMTP，则要写成 smtp。</strong></li><li>port 的键是 spring.mail.port<br><strong>有些文章将 port 的键写成了 spring.mail.properties.mail.smtp.port，这可能是 SpringBoot 的版本原因，注意区分。</strong></li></ol><h2 id="封装接口实现发送"><a class="markdownIt-Anchor" href="#封装接口实现发送"></a> 封装接口实现发送</h2><p>封装 Service 实现邮件发送，一个简单的示例如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String from;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;spring.mail.to:&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String to;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JavaMailSender javaMailSender;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送文本邮件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to      收件人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subject 主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content 内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTextMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        <span class="comment">// 发送对象</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != to &amp;&amp; to.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (to.indexOf(<span class="string">&quot;,&quot;</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                message.setTo(to.split(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                message.setTo(to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message.setTo(from);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邮件主题</span></span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        <span class="comment">// 邮件内容</span></span><br><span class="line">        message.setText(content);</span><br><span class="line">        <span class="comment">// 邮件的发起者</span></span><br><span class="line">        message.setFrom(from);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            javaMailSender.send(message);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (org.springframework.mail.MailSendException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;error:&quot;</span> + from, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注入 JavaMailSender，JavaMailSender 实现了邮件发送。上例是发送文本邮件，可发送多个人。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-12-07T07:44:40.000Z" title="2020-12-07T07:44:40.000Z">2020-12-07</time>发表</span><span class="level-item"><time datetime="2020-12-16T03:26:02.172Z" title="2020-12-16T03:26:02.172Z">2020-12-16</time>更新</span><span class="level-item">11 分钟读完 (大约1593个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/12/07/%E4%BC%AA%E5%85%B1%E4%BA%AB%E5%92%8CJava%E7%BC%93%E5%AD%98%E8%A1%8C/">伪共享和Java缓存行</a></h1><div class="content"><p>对于多线程编程来说，一般要注意线程安全的问题，如果是要实现超高并发的中间件，特别是需要多线程处理列表、数组和队列的时候，就需要注意伪共享的问题。否则可能无法发挥多线程的优势，性能可能比单线程还差。</p><h2 id="伪共享"><a class="markdownIt-Anchor" href="#伪共享"></a> 伪共享</h2><p>介绍伪共享前先说说 SMP、Cache、MESI 几个概念。</p><h3 id="smp-系统"><a class="markdownIt-Anchor" href="#smp-系统"></a> SMP 系统</h3></div><a class="article-more button is-small is-size-7" href="/2020/12/07/%E4%BC%AA%E5%85%B1%E4%BA%AB%E5%92%8CJava%E7%BC%93%E5%AD%98%E8%A1%8C/#more">阅读更多</a></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-08-17T08:02:38.000Z" title="2020-08-17T08:02:38.000Z">2020-08-17</time>发表</span><span class="level-item"><time datetime="2020-08-18T09:08:49.148Z" title="2020-08-18T09:08:49.148Z">2020-08-18</time>更新</span><span class="level-item">7 分钟读完 (大约1074个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/17/%E4%BD%BF%E7%94%A8Java8%E7%9A%84Optional%E7%9A%84%E6%80%9D%E8%80%83/">使用Java8的Optional的思考</a></h1><div class="content"><p>Optional 是 Java 8 引入的一个工具类，也是 Java 8 的新特性之一。在 Stream API 中很多地方也都使用到了 Optional。<br>空指针异常（NullPointerExceptions）是 Java 最常见的异常之一。程序员不得不在代码中写很多 null 的检查逻辑，让代码看起来非常臃肿；由于其属于运行时异常，非常难以预判的。<br>为了预防空指针异常，Google 的 Guava 项目率先引入 Optional 类，通过使用检查空值的方式来防止代码污染，受到 Guava 项目的启发，Java 8 中引入了 Optional 类。那在使用 Optional 上有那些值得思考和注意的地方呢。</p><h2 id="ispresent-和-get-的思考"><a class="markdownIt-Anchor" href="#ispresent-和-get-的思考"></a> isPresent() 和 get() 的思考</h2><p>虽然官方文档说明中对 Optional 的描述是：<code>If a value is present, isPresent() will return true and get() will return the value</code>。我们就调用 isPresent() 和 get() 来避免 NullPointException 好了，但如果只是简单的认为它可以解决 NPE 的问题, 于是代码就会是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; student = ......</span><br><span class="line"><span class="keyword">if</span> (student.isPresent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> student.get().getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这种写法这与我们之前写成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> .....</span><br><span class="line"><span class="keyword">if</span> (student != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> student.getName();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本质上是没有区别的。</p><p>虽然说使用 ifPresent(Consumer&lt;? super T&gt; consumer) 来替代 isPresent() 要好一些，但是 Consumer 的 accept 函数的返回值是 void 类型，接受单个输入参数且不返回结果的操作，有使用上的限制。</p><p>所以，如果我们在使用 Optional 时，如果有需要调用 isPresent() 和 get() 的地方，那就该重新审视一下，是否真的有必要使用 Optional。</p><h2 id="不要将-optional-作为函数参数"><a class="markdownIt-Anchor" href="#不要将-optional-作为函数参数"></a> 不要将 Optional 作为函数参数</h2><p>把 Optional 类型用作函数参数在 IntelliJ IDEA 中是强力不推荐的。这该怎么理解呢？Optional 对象是一个容器对象，它包含的对象是否是空，是不确定的。<br>函数作为被调用者，它根据传入的参数进行逻辑运算，那么传给它的参数应该是明确的。</p><p>参数不为 Optional 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    func2(student);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (student == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    student.setId(getId());</span><br><span class="line">    <span class="keyword">return</span> insertStudent(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数为 Optional 的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    func2(Optional.ofNullable(student));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">func2</span><span class="params">(Optional&lt;Student&gt; studentOpt)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentOpt.orElse(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">    student.setId(getId());</span><br><span class="line">    <span class="keyword">return</span> insertStudent(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上两个例子，如果 Optional 为参数的话，按照后一个例子的写法，func2 的逻辑就改变了。<br>如果要逻辑一致的话，就又会使调用到 isPresent() 和 get() 方法，这样就不如不使用 Optional 更为直接。</p><h2 id="不要将-optional-作为字段类型"><a class="markdownIt-Anchor" href="#不要将-optional-作为字段类型"></a> 不要将 Optional 作为字段类型</h2><p>不要将 Optional 作为字段类型有两个原因：</p><ol><li>Optional 包含的对象是不确定的<br>不确定的数据作为字段值没有什么意义，应该审视是否有更好的设计。</li><li>Optional 不能支持序列化<br>Optional 作为字段类型,如果对象需要被序列化，将会出现异常<code>Exception in thread &quot;main&quot; java.io.NotSerializableException</code>。</li></ol><h2 id="optional-使用举例"><a class="markdownIt-Anchor" href="#optional-使用举例"></a> Optional 使用举例</h2><p>除了上述几个场景外，在需要处理 null 的地方，采用 Optional 还是比较好的选择。Optional 虽不能完全杜绝 NPE，但是它能相对优雅的预防 NPE。<br>比如我们可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; studentOpt = Optional.ofNullable(student);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> studentOpt.orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>Optional.ofNullable(obj)：以一种宽容的方式来构造一个 Optional 实例。传 null 进到就得到 Optional.empty(), 非 null 就调用 Optional.of(obj)。<strong>Optional.of(obj) 是可能抛出 NPE的，如果参数 obj 为 null 的话。</strong><br>Optional.orElse()：存在即返回, 无则提供默认值。</p><p>这样看起来比之前的写法要简单很多，改写成一行，更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Optional.ofNullable(student).orElse(<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><p>比如我们还可以这样，将 Steam 与 Optional 结合起来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">(Collection&lt;Integer&gt; studentIds)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> studentIds.stream()</span><br><span class="line">        <span class="comment">//此处 getStudentById 返回的是 Optional&lt;Student&gt;</span></span><br><span class="line">        .map(<span class="built_in">this</span>::getStudentById)     <span class="comment">// 获得 Stream&lt;Optional&lt;Student&gt;&gt;</span></span><br><span class="line">        .filter(Optional::isPresent)   <span class="comment">// 去掉不包含值的 Optional</span></span><br><span class="line">        .map(Optional::get)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 8 的 Optional 除了上述的一些方法，还有一些其它的，像 flatMap 和 orElseThrow 等，可以详细了解一下，找到合适的使用场景。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-08-06T11:40:18.000Z" title="2020-08-06T11:40:18.000Z">2020-08-06</time>发表</span><span class="level-item"><time datetime="2020-08-07T07:52:14.311Z" title="2020-08-07T07:52:14.311Z">2020-08-07</time>更新</span><span class="level-item">5 分钟读完 (大约801个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/06/springboot%E4%B8%ADapplication-yml%E5%92%8Cbootstrap-yml%E7%9A%84%E5%8C%BA%E5%88%AB/">springboot中application.yml和bootstrap.yml的区别</a></h1><div class="content"><p>spring boot 默认支持 properties(.properties)和 YAML(.yml .yaml ) 两种格式的配置文件。<br>yml 和 properties 文件都属于配置文件，它们的功能一样。<br>在 spring boot 框架中 bootstrap.yml 和 application.yml 都可以用来配置参数，甚至这两个文件可以同时出现。</p><h2 id="配置写到-bootstrapyml和写到-applicationyml-有什么区别"><a class="markdownIt-Anchor" href="#配置写到-bootstrapyml和写到-applicationyml-有什么区别"></a> 配置写到 bootstrap.yml和写到 application.yml 有什么区别</h2><h3 id="加载顺序不一样"><a class="markdownIt-Anchor" href="#加载顺序不一样"></a> 加载顺序不一样</h3><p>bootstrap.yml 先加载 application.yml 后加载。<br>从技术上来讲，bootstrap.yml 由父 Spring ApplicationContext 加载。父 ApplicationContext 在使用 application.yml 之前被加载。</p><h3 id="应用场景不一样"><a class="markdownIt-Anchor" href="#应用场景不一样"></a> 应用场景不一样</h3><h4 id="bootstrapyml-典型的应用场景"><a class="markdownIt-Anchor" href="#bootstrapyml-典型的应用场景"></a> bootstrap.yml 典型的应用场景</h4><p>stackoverflow 中有个高票（301）的回答：</p><blockquote><p>I have just asked the Spring Cloud guys and thought I &gt;should share the info I have here.</p><p>bootstrap.yml <strong>is loaded before</strong> application.yml.</p><p>It is typically used for the following:</p><ul><li>when using Spring Cloud Config Server, you should specify <a target="_blank" rel="noopener" href="http://spring.application.name">spring.application.name</a> and spring.cloud.config.server.git.uri inside bootstrap.yml</li><li>some encryption/decryption information</li></ul><p>Technically, bootstrap.yml is loaded by a parent Spring ApplicationContext. That parent ApplicationContext is loaded before the one that uses application.yml.</p></blockquote><p>大致意思如下：</p><ul><li>当使用 Spring Cloud Config Server 配置中心时，需要在 bootstrap.yml 配置文件中指定 <a target="_blank" rel="noopener" href="http://spring.application.name">spring.application.name</a> 和<br>spring.cloud.config.server.git.uri，添加连接到配置中心的配置属性来加载外部配置中心的配置信息。</li><li>一些加密/解密信息</li></ul><p>因为当使用 Spring Cloud 的时候，配置信息一般是从 config server 加载的，为了取得配置信息（比如密码等），需要一些提早的或引导配置。因此，把 config server 信息放在 bootstrap.yml，用来加载真正需要的配置信息。config server 可能做了安全认证，所以访问所需的加解密信息也需要配置在 bootstrap.yml 里。</p><h2 id="属性覆盖"><a class="markdownIt-Anchor" href="#属性覆盖"></a> 属性覆盖</h2><ul><li><p>不接配置中心的情况下，启动的时候 spring boot 默认会加载 bootstrap.yml 以及 bootstrap-{profile}。{profile}在 bootstrap.yml中 spring.profiles.active 指定。<br>加载顺序是： bootstrap.yml &gt; bootstrap-{profile}.yml &gt; application.yml &gt;application-{profile}.yml</p><p>如果这4个配置文件中存在相同的属性，那么后加载的属性值会覆盖掉前加载的属性值。</p><p><strong>需要注意的是，有些文章说 bootstrap 不会被本地配置覆盖，如果这个说法是指 bootstrap 配置属性不会被 application 覆盖，那是错误的。</strong></p><p><strong>如果 spring.profiles.active 配置多个 profile，最后面的 profile 才会生效。例如：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">foo</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev,mysql</span></span><br></pre></td></tr></table></figure><p>mysql profile才有效</p></li><li><p>在接配置中心的情况下，如果有 application.yml，它的属性值会被从配置中心中的同名属性值覆盖。</p></li></ul><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><p>在没有配置中心的情况下，是选择使用 bootstrap.yml 还是 application.yml，或者两者都用？<br>根据 bootstrap.yml 典型的应用场景，在没有配置中心的情况下，使用 bootstrap.yml 的意义不大，即使有加解密信息，将它们放到 application.yml 也是可以的。<br>建议在没有配置中心的情况下，去掉 bootstrap.yml 只使用 application.yml，减少配置文件，配置集中以减少出错的几率。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-04-29T08:01:06.000Z" title="2020-04-29T08:01:06.000Z">2020-04-29</time>发表</span><span class="level-item"><time datetime="2020-04-30T07:05:52.328Z" title="2020-04-30T07:05:52.328Z">2020-04-30</time>更新</span><span class="level-item">12 分钟读完 (大约1743个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/29/Java%E4%B8%AD%E7%9A%84Random%E7%B1%BB/">Java中的Random类</a></h1><div class="content"><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>Java中生成随机数的方式有很多，Math.Random()、Random、ThreadLocalRandom、SecureRandom类等。不同的类和方法适用的产生随机数的场景也不一样。<br>伪随机数是用确定性的算法计算出来自[0,1]均匀分布的随机数序列。并不真正的随机，但具有类似于随机数的统计特征，如均匀性、独立性等。在计算伪随机数时，若<br>使用的初值（种子）不变，那么伪随机数的数序也不变。</p><h2 id="mathrandom"><a class="markdownIt-Anchor" href="#mathrandom"></a> Math.Random()</h2><p>Math.Random()函数能够返回带正号的double值，该值大于等于0.0且小于1.0，即取值范围是[0.0,1.0)的左闭右开区间，返回值是一个伪随机选择的数，在该<br>范围内（近似）均匀分布。例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mathRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Math.random()=&quot;</span> + Math.random());</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * <span class="number">3</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;num=&quot;</span> + num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.random()=<span class="number">0.8890842451831729</span></span><br><span class="line">num=<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="random类"><a class="markdownIt-Anchor" href="#random类"></a> Random类</h2><p>Random类有两种构造方法：</p><ul><li>Random()<br>使用系统计时器的当前值作为随机种子来构建Random对象</li><li>Random(long seed)<br>使用指定 long 种子来构建Random对象</li></ul><p>创建一个Random对象的时候可以给定任意一个合法的种子数，种子数只是随机算法的起源数字，和生成的随机数的区间没有任何关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i=rand.nextInt(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>初始种子为10，它对产生的随机数的范围并没有起作用,<code>rand.nextInt(100);</code>中的100是随机数的上限,产生的随机数为0-100的整数,不包括100。</p><h3 id="对于种子相同的random对象生成的随机数序列是一样的"><a class="markdownIt-Anchor" href="#对于种子相同的random对象生成的随机数序列是一样的"></a> 对于种子相同的Random对象，生成的随机数序列是一样的</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">ran1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran1.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="type">Random</span> <span class="variable">ran2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用另一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line">使用另一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="相同的random对象多次调用nextint生成的随机数序列会不同"><a class="markdownIt-Anchor" href="#相同的random对象多次调用nextint生成的随机数序列会不同"></a> 相同的Random对象，多次调用nextInt生成的随机数序列会不同</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">ran2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;使用另一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用同一个种子为8的Random对象生成[0,10)内随机整数序列: &quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(ran2.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用另一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">3</span> <span class="number">0</span></span><br><span class="line">使用同一个种子为<span class="number">8</span>的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列:</span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">2</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">2</span> <span class="number">9</span> <span class="number">3</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="不同的random对象采用默认构造函数生成的随机数序列不一样"><a class="markdownIt-Anchor" href="#不同的random对象采用默认构造函数生成的随机数序列不一样"></a> 不同的Random对象，采用默认构造函数，生成的随机数序列不一样</h3><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">r3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子缺省是当前系统时间的Random对象生成[0,10)内随机整数序列&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(r3.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Random</span> <span class="variable">r4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">&quot;使用种子缺省是当前系统时间的Random对象生成[0,10)内随机整数序列&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    System.out.print(r4.nextInt(<span class="number">10</span>) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用种子缺省是当前系统时间的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列</span><br><span class="line"><span class="number">7</span> <span class="number">6</span> <span class="number">6</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line">使用种子缺省是当前系统时间的Random对象生成[<span class="number">0</span>,<span class="number">10</span>)内随机整数序列</span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span> <span class="number">5</span> <span class="number">2</span> <span class="number">8</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="random-objects-should-be-reused"><a class="markdownIt-Anchor" href="#random-objects-should-be-reused"></a> “Random” objects should be reused</h3><p>Sonar 的代码审查提出“For better efficiency and randomness, create a single Random, then store, and reuse it.”，主要原因是：</p><ul><li>创建Random是有代价的，如下面的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span> bound)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">return</span> ran.nextInt(bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getRandom每次调用都会构造一个新的Random对象，效率不高。</p><ul><li>随机性不够好，如下面例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">(<span class="type">int</span> bound)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">ran</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> ran.nextInt(bound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样多次调用getRandom可能得到的值都是一样的，随机性不够好。其实这也是一种随机，只是均匀性，对立性不够了。</p><p>但是如果不需要频繁的获取平均数，将Random对象存储起来，可能会造成Random对象不能被gc，也会造成浪费。</p><h3 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h3><p>Random是一个线程安全类，理论上可以通过它同时在多个线程中获得互不相同的随机数，但是它会因为多线程竞争同一个seed而造成性能下降，所以建议在多线程的<br>情况下采用ThreadLocalRandom来产生随机数。</p><p>Random在执行<code>nextInt</code>时，会调用<code>next</code>函数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> bits)</span> &#123;</span><br><span class="line">    <span class="type">long</span> oldseed, nextseed;</span><br><span class="line">    <span class="type">AtomicLong</span> <span class="variable">seed</span> <span class="operator">=</span> <span class="built_in">this</span>.seed;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于seed的类型是AtomicLong，在计算nextseed时是原子操作，所以没有线程安全性的问题。</p><h3 id="securerandom"><a class="markdownIt-Anchor" href="#securerandom"></a> SecureRandom</h3><p>Random类只要种子一样，产生的随机数也一样： 因为种子确定，随机数算法也确定，因此输出就是确定的。</p><ul><li>SecureRandom提供加密的强随机数生成器 (RNG)，要求种子必须是不可预知的，可产生非确定性输出</li><li>SecureRandom许多实现都是伪随机数生成器 (PRNG) 形式，这意味着它们将使用确定的算法根据实际的随机种子生成伪随机序列</li><li>SecureRandom和Random都是如果种子一样，产生的随机数也一样： 因为种子确定，随机数算法也确定，因此输出是确定的。<br>SecureRandom类收集了一些随机事件，比如鼠标点击，键盘点击等等，SecureRandom 使用这些随机事件作为种子。这意味着，种子是不可预测的，而不像Random默认使用系统当前时间的毫秒数作为种子，有规律可寻。</li></ul><p>不当用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] salt = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="type">SecureRandom</span> <span class="variable">secureRandom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">secureRandom.setSeed(System.currentTimeMillis());  <span class="comment">//使用系统时间作为种子</span></span><br><span class="line">secureRandom.nextBytes(salt);</span><br></pre></td></tr></table></figure><p>例子中指定了当前系统时间作为种子，替代系统默认随机源。如果同一毫秒连续调用，则得到的随机数则是相同的。</p><p>系统默认的随机源取决于$JAVA_HOME/jre/lib/security/java.security配置中的securerandom.source属性。例如jdk1.8中该配置为：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">securerandom.source=file:/dev/random</span><br></pre></td></tr></table></figure><p>SecureRandom内置两种随机数算法，NativePRNG和SHA1PRNG，看实例化的方法了。默认来说会使用NativePRNG算法生成随机数。</p><p>一般来说尽量避免指定任何随机生成器，只需调用空参数构造函数：<code>new SecureRandom()</code>，让系统选择最好的随机数生成器。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2020-04-23T08:00:03.000Z" title="2020-04-23T08:00:03.000Z">2020-04-23</time>发表</span><span class="level-item"><time datetime="2020-04-27T11:52:27.499Z" title="2020-04-27T11:52:27.499Z">2020-04-27</time>更新</span><span class="level-item">13 分钟读完 (大约1903个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/04/23/java%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96/">java循环优化</a></h1><div class="content"><p>在许多应用程序中，循环都扮演着非常重要的角色。为了提升循环的运行效率，研发编译器的工程师提出了不少面向循环的编译优化方式，如循环无关代码外提，循环<br>展开等。</p><p>今天，我们便来了解一下，Java 虚拟机中的即时编译器都应用了哪些面向循环的编译优化。</p><h2 id="循环外提"><a class="markdownIt-Anchor" href="#循环外提"></a> 循环外提</h2><p>所谓的循环无关代码（Loop-invariant Code），指的是循环中值不变的表达式。如果能够在不改变程序语义的情况下，将这些循环无关代码提出循环之外，那么<br>程序便可以避免重复执行这些表达式，从而达到性能提升的效果。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        sum += x * y + ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>[])</span>;</span><br><span class="line">   descriptor: (II[I)I</span><br><span class="line">   flags: ACC_PUBLIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">4</span>, locals=<span class="number">6</span>, args_size=<span class="number">4</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">        <span class="number">3</span>: iconst_0</span><br><span class="line">        <span class="number">4</span>: istore        <span class="number">5</span></span><br><span class="line">        <span class="comment">// 循环开始</span></span><br><span class="line">        <span class="number">6</span>: iload         <span class="number">5</span></span><br><span class="line">        <span class="number">8</span>: aload_3</span><br><span class="line">        <span class="number">9</span>: arraylength         <span class="comment">// ary.length</span></span><br><span class="line">       <span class="number">10</span>: if_icmpge     <span class="number">32</span>    <span class="comment">// i &lt; ary.length</span></span><br><span class="line">       <span class="number">13</span>: iload         <span class="number">4</span></span><br><span class="line">       <span class="number">15</span>: iload_1</span><br><span class="line">       <span class="number">16</span>: iload_2</span><br><span class="line">       <span class="number">17</span>: imul                <span class="comment">// x*y</span></span><br><span class="line">       <span class="number">18</span>: aload_3</span><br><span class="line">       <span class="number">19</span>: iload         <span class="number">5</span></span><br><span class="line">       <span class="number">21</span>: iaload              <span class="comment">// ary[i]</span></span><br><span class="line">       <span class="number">22</span>: iadd</span><br><span class="line">       <span class="number">23</span>: iadd</span><br><span class="line">       <span class="number">24</span>: istore        <span class="number">4</span></span><br><span class="line">       <span class="number">26</span>: iinc          <span class="number">5</span>, <span class="number">1</span></span><br><span class="line">       <span class="number">29</span>: goto          <span class="number">6</span></span><br><span class="line">       <span class="comment">// 循环结束</span></span><br><span class="line">       <span class="number">32</span>: iload         <span class="number">4</span></span><br><span class="line">       <span class="number">34</span>: ireturn</span><br></pre></td></tr></table></figure><p>在上面这段代码中，循环体中的表达式x*y，以及循环判断条件中的ary.length均属于循环不变代码。<br>前者是一个整数乘法运算，而后者则是内存访问操作，读取数组对象ary的长度。（数组的长度存放于数组对象的对象头中，可通过 arraylength 指令来访问。）</p><p>理想情况下，上面这段代码经过循环无关代码外提之后，等同于下面这一手工优化版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1Opt</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t0</span> <span class="operator">=</span> x * y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">t1</span> <span class="operator">=</span> ary.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t1; i++) &#123;</span><br><span class="line">        sum += t0 + ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1Opt</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>[])</span>;</span><br><span class="line">  descriptor: (II[I)I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">4</span>, locals=<span class="number">8</span>, args_size=<span class="number">4</span></span><br><span class="line">       <span class="number">0</span>: iconst_0</span><br><span class="line">       <span class="number">1</span>: istore        <span class="number">4</span></span><br><span class="line">       <span class="number">3</span>: iload_1</span><br><span class="line">       <span class="number">4</span>: iload_2</span><br><span class="line">       <span class="number">5</span>: imul</span><br><span class="line">       <span class="number">6</span>: istore        <span class="number">5</span></span><br><span class="line">       <span class="number">8</span>: aload_3</span><br><span class="line">       <span class="number">9</span>: arraylength</span><br><span class="line">      <span class="number">10</span>: istore        <span class="number">6</span></span><br><span class="line">      <span class="number">12</span>: iconst_0</span><br><span class="line">      <span class="number">13</span>: istore        <span class="number">7</span></span><br><span class="line">      <span class="comment">// 循环开始</span></span><br><span class="line">      <span class="number">15</span>: iload         <span class="number">7</span></span><br><span class="line">      <span class="number">17</span>: iload         <span class="number">6</span></span><br><span class="line">      <span class="number">19</span>: if_icmpge     <span class="number">40</span></span><br><span class="line">      <span class="number">22</span>: iload         <span class="number">4</span></span><br><span class="line">      <span class="number">24</span>: iload         <span class="number">5</span></span><br><span class="line">      <span class="number">26</span>: aload_3</span><br><span class="line">      <span class="number">27</span>: iload         <span class="number">7</span></span><br><span class="line">      <span class="number">29</span>: iaload          <span class="comment">// ary[i]</span></span><br><span class="line">      <span class="number">30</span>: iadd</span><br><span class="line">      <span class="number">31</span>: iadd</span><br><span class="line">      <span class="number">32</span>: istore        <span class="number">4</span></span><br><span class="line">      <span class="number">34</span>: iinc          <span class="number">7</span>, <span class="number">1</span></span><br><span class="line">      <span class="number">37</span>: goto          <span class="number">15</span></span><br><span class="line">      <span class="comment">// 循环结束</span></span><br><span class="line">      <span class="number">40</span>: iload         <span class="number">4</span></span><br><span class="line">      <span class="number">42</span>: ireturn</span><br></pre></td></tr></table></figure><p>我们可以看到，无论是乘法运算x*y，还是内存访问ary.length，现在都在循环之前完成。原本循环中需要执行这两个表达式的地方，现在直接使用循环之前这两个表达式的执行结果。</p><p>java的JIT实现了循环无关代码的外提。</p><p>即时编译器JIT还外提了 int 数组加载指令iaload所暗含的 null 检测（null check）以及下标范围检测（range check）。<br>如果将iaload指令想象成一个接收数组对象以及下标作为参数，并且返回对应数组元素的方法，那么它的伪代码大致如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">iaload</span><span class="params">(<span class="type">int</span>[] aryRef, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (aryRef == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// null 检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= aryRef.length) &#123;</span><br><span class="line">        <span class="comment">// 下标范围检测</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aryRef[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop1 方法中的 null 检测属于循环无关代码。这是因为它始终检测作为输入参数的 int 数组是否为 null，而这与第几次循环无关。</p><p>为了更好地阐述具体的优化，修改了原来的例子，并将iaload展开，形成如下所示的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop1</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// null check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;</span><br><span class="line">            <span class="comment">// range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码段中，null 检测涉及了控制流依赖，无法完成外提。</p><p>在 HotSpot VM的C2编译器 中，null 检测的外提是通过额外的编译优化，也就是循环预测（Loop Prediction，对应虚拟机参数-XX:+UseLoopPredicate）来实现的。该优化的实际做法是在循环之前插入同样的检测代码，并在命中的时候进行去优化。这样一来，循环中的检测代码便会被归纳并消除掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop2</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">        deoptimize(); <span class="comment">// never returns</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// now evluate to false</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= a.length) &#123;</span><br><span class="line">            <span class="comment">// range check</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环展开"><a class="markdownIt-Anchor" href="#循环展开"></a> 循环展开</h2><p>另外一项非常重要的循环优化是循环展开（Loop Unrolling）。它指的是在循环体中重复多次循环迭代，并减少循环次数的编译优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i++) &#123;</span><br><span class="line">        sum += (i % <span class="number">2</span> == <span class="number">0</span>) ? ary[i] : -ary[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码经过一次循环展开之后将形成下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意这里的步数是 2</span></span><br><span class="line">        sum += (i % <span class="number">2</span> == <span class="number">0</span>) ? ary[i] : -ary[i];</span><br><span class="line">        sum += ((i + <span class="number">1</span>) % <span class="number">2</span> == <span class="number">0</span>) ? ary[i + <span class="number">1</span>] : -ary[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环展开的缺点显而易见：它可能会增加代码的冗余度，导致所生成机器码的长度大幅上涨。</p><p>不过，随着循环体的增大，优化机会也会不断增加。一旦循环展开能够触发进一步的优化，总体的代码复杂度也将降低。比如前面的例子经过循环展开之后便可以进一步优化为如下所示的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop3Opt1</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">64</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">        sum += ary[i];</span><br><span class="line">        sum += -ary[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他循环优化"><a class="markdownIt-Anchor" href="#其他循环优化"></a> 其他循环优化</h2><p>除了循环无关代码外提以及循环展开之外，即时编译器还有两个比较重要的循环优化技术：循环判断外提（loop unswitching）以及循环剥离（loop peeling）。</p><h3 id="循环判断外提"><a class="markdownIt-Anchor" href="#循环判断外提"></a> 循环判断外提</h3><p>指的是将循环中的 if 语句外提至循环之前，并且在该 if 语句的两个分支中分别放置一份循环代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            sum += ary[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码经过循环判断外提之后，将变成下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">                sum += ary[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop4Opt1</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ary.length &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            sum += ary[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环判断外提与循环无关检测外提所针对的代码模式比较类似，都是循环中的 if 语句。不同的是，后者在检查失败时会抛出异常，中止当前的正常执行路径；而前者所针对的是更加常见的情况，即通过 if 语句的不同分支执行不同的代码逻辑。</p><h3 id="循环剥离"><a class="markdownIt-Anchor" href="#循环剥离"></a> 循环剥离</h3><p>指的是将循环的前几个迭代或者后几个迭代剥离出循环的优化方式。一般来说，循环的前几个迭代或者后几个迭代都包含特殊处理。通过将这几个特殊的迭代剥离出去，可以使原本的循环体的规律性更加明显，从而触发进一步的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop5</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">        sum += ary[j];</span><br><span class="line">        j = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码剥离了第一个迭代后，将变成下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loop5Opt</span><span class="params">(<span class="type">int</span>[] ary)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">null</span> != ary &amp;&amp; <span class="number">0</span> &lt; ary.length) &#123;</span><br><span class="line">        sum += ary[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ary.length; i++) &#123;</span><br><span class="line">            sum += ary[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转自"><a class="markdownIt-Anchor" href="#转自"></a> 转自</h2><p>极客时间 -《循环优化》</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-04-12T07:41:21.000Z" title="2018-04-12T07:41:21.000Z">2018-04-12</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">6 分钟读完 (大约881个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/04/12/%E5%9B%9E%E9%A1%BEJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8-%E7%BB%AD/">回顾Java类加载器(续)</a></h1><div class="content"><h1 id="回顾-java-类加载器续"><a class="markdownIt-Anchor" href="#回顾-java-类加载器续"></a> 回顾 Java 类加载器(续)</h1><p>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。</p><h2 id="显式加载类"><a class="markdownIt-Anchor" href="#显式加载类"></a> 显式加载类</h2><p>在代码中显式加载某个类，有三种方法：</p><ol><li>this.getClass().getClassLoader().loadClass()</li><li>Class.forName()</li><li>CustomClassLoader.findClass()</li></ol><p>loadClass会调用findClass。</p><h2 id="loadclass"><a class="markdownIt-Anchor" href="#loadclass"></a> loadClass()</h2><p>ClassLoader.loadClass()的加载步骤为：</p><ol><li>调用 findLoadedClass(String) 来检查是否已经加载类。</li><li>在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。</li><li>调用 findClass(String) 方法查找类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="classloaderfindclass"><a class="markdownIt-Anchor" href="#classloaderfindclass"></a> ClassLoader.findClass()</h3><p>ClassLoader.loadClass()的最后一步是调用findClass()，这个方法在ClassLoader中并未实现，由其子类负责实现。findClass()的功能是找到class文件并把字节码加载到内存中。自定义的ClassLoader一般会覆盖这个方法，以便使用不同的加载路径。<br>URLClassLoader 的findClass 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(<span class="keyword">final</span> String name)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        result = AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PrivilegedExceptionAction</span>&lt;Class&lt;?&gt;&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Class&lt;?&gt; run() <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> name.replace(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;/&#x27;</span>).concat(<span class="string">&quot;.class&quot;</span>);</span><br><span class="line">                    <span class="type">Resource</span> <span class="variable">res</span> <span class="operator">=</span> ucp.getResource(path, <span class="literal">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (res != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> defineClass(name, res);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, acc);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.security.PrivilegedActionException pae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (ClassNotFoundException) pae.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ucp 是 URLClassPath 对象，帮助获取 class 文件字节流，URLClassPath 会用 FileLoader 或者 JarLoader 去加载字节码。</li><li>defineClass()，创建类对象，将类字节码解析成 JVM 能够识别的 Class 对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; defineClass(String name, Resource res) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> res.getCodeSourceURL();</span><br><span class="line">    <span class="keyword">if</span> (i != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pkgname</span> <span class="operator">=</span> name.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="comment">// Check if package already loaded.</span></span><br><span class="line">        <span class="type">Manifest</span> <span class="variable">man</span> <span class="operator">=</span> res.getManifest();</span><br><span class="line">        definePackageInternal(pkgname, man, url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Now read the class bytes and define the class</span></span><br><span class="line">    java.nio.<span class="type">ByteBuffer</span> <span class="variable">bb</span> <span class="operator">=</span> res.getByteBuffer();</span><br><span class="line">    <span class="keyword">if</span> (bb != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Use (direct) ByteBuffer:</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bb, cs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] b = res.getBytes();</span><br><span class="line">        <span class="comment">// must read certificates AFTER reading bytes.</span></span><br><span class="line">        CodeSigner[] signers = res.getCodeSigners();</span><br><span class="line">        <span class="type">CodeSource</span> <span class="variable">cs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CodeSource</span>(url, signers);</span><br><span class="line">        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length, cs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="classforname"><a class="markdownIt-Anchor" href="#classforname"></a> Class.forName</h2><p>Class的装载分了三个阶段，loading，linking和initializing，分别定义在The Java Language Specification的12.2，12.3和12.4。</p><p>Class.forName(className)实际上是调用Class.forName(className, true, ClassLoader.getClassLoader(caller), caller)。注意第二个参数，是指Class被loading后是不是必须被初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">            <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassLoader.loadClass(className)实际上调用的是ClassLoader.loadClass(name, false)，第二个参数指出Class是否被link。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区别就出来了。Class.forName(className)装载的class已经被初始化，会执行类中的 static 块和 static 方法，而ClassLoader.loadClass(className)装载的class还没有被link。<br>一般情况下，这两个方法效果一样，都能装载Class。但如果程序依赖于Class是否被初始化，就必须用Class.forName(name)了。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-30T01:38:35.000Z" title="2018-03-30T01:38:35.000Z">2018-03-30</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">11 分钟读完 (大约1713个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/30/%E5%9B%9E%E9%A1%BEJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/">回顾Java类加载器</a></h1><div class="content"><h1 id="回顾-java-类加载器"><a class="markdownIt-Anchor" href="#回顾-java-类加载器"></a> 回顾 Java 类加载器</h1><p>类加载器使得 Java 类可以被动态加载到 Java 虚拟机中并执行。类加载器从 JDK 1.0 就出现了，最初是为了满足 Java Applet 的需要而开发出来的。Java Applet 需要从远程下载 Java 类文件到浏览器中并执行。现在类加载器在 Web 容器和 OSGi 中得到了广泛的使用。一般来说，Java 应用的开发人员不需要直接同类加载器进行交互。Java 虚拟机默认的行为就已经足够满足大多数情况的需求了。不过如果遇到了需要与类加载器进行交互的情况，而对类加载器的机制又不是很了解的话，就很容易花大量的时间去调试 ClassNotFoundException和 NoClassDefFoundError等异常。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class 类的一个实例。每个这样的实例用来表示一个 Java <strong>类</strong>。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p><p>基本上所有的类加载器都是 java.lang.ClassLoader 类的一个实例。</p><h2 id="classloader-加载类的原理"><a class="markdownIt-Anchor" href="#classloader-加载类的原理"></a> ClassLoader 加载类的原理</h2><h3 id="类加载器的组织结构"><a class="markdownIt-Anchor" href="#类加载器的组织结构"></a> 类加载器的组织结构</h3><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：</p><ul><li>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。<br>负责加载 JDK 中的核心类库，如：rt.jar、resources.jar、charsets.jar等。</li><li>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>负责加载 Java 的扩展类库，默认加载 JAVA_HOME/jre/lib/ext 目下的所有 jar。</li><li>系统类加载器（system class loader \ app class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</li></ul><p>除了系统提供的类加载器以外，可以通过继承 java.lang.ClassLoader 类的方式实现自己的类加载器，以满足一些特殊的需求。</p><p>类加载器树状组织结构示意图:<br><img src="classloader_tree.jpg" alt="类加载器组织结构"></p><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>ClassLoader 使用的是双亲委托模型来搜索类的，每个 ClassLoader 实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它 ClassLoader 实例的的父类加载器。当一个 ClassLoader 实例需要加载某个类时，它会试图亲自搜索某个类之前，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器 Bootstrap ClassLoader 试图加载，如果没加载到，则把任务转交给 Extension ClassLoader 试图加载，如果也没加载到，则转交给 App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等 URL 中加载该类。如果它们都没有加载到这个类时，则抛出 ClassNotFoundException 异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的 Class 实例对象。</p><h3 id="如何判定两个-java-类是相同的"><a class="markdownIt-Anchor" href="#如何判定两个-java-类是相同的"></a> 如何判定两个 Java 类是相同的</h3><p><strong>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的</strong>。比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA 和 ClassLoaderB 分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class 类的实例来表示这个类。这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。</p><h3 id="为什么是双亲委托"><a class="markdownIt-Anchor" href="#为什么是双亲委托"></a> 为什么是双亲委托</h3><p>双亲委托也可称为代理模式，理解了上诉 Java 虚拟机判断 Java 类是否相同的原理就可明白，采用这种模式的原因是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object 类，也就是说在运行的时候，java.lang.Object 这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object 类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。</p><p>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。这种技术在许多框架中都被用到，如 tomcat。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader">深入探讨 Java 类加载器</a></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-12T02:53:07.000Z" title="2018-03-12T02:53:07.000Z">2018-03-12</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">14 分钟读完 (大约2170个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/12/Java%E7%9A%84NIO%E8%AF%B4%E6%98%8E/">Java的NIO说明</a></h1><div class="content"><h1 id="java的nio说明"><a class="markdownIt-Anchor" href="#java的nio说明"></a> Java的NIO说明</h1><p>Java NIO，是Java SE 1.4版以后，针对网络传输效能优化的新功能。在Java 7时再推出NIO 2，针对档案存取的效能优化。</p><p>有些资料将 NIO 称之为 Non-block I/O，即非阻塞I/O，这个说法不是很正确。NIO 应该称为 New I/O，参考<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=51">JSR 51: New I/O APIs for the JavaTM Platform</a>。因为NIO支持阻塞和非阻塞这两种模式，所以将NIO称之为 Non-block I/O 就不准确了。</p><p>NIO.2是“APIs for filesystem access, scalable asynchronous I/O operations, socket-channel binding and configuration, and multicast datagrams. ”，上述描述抄自<a target="_blank" rel="noopener" href="https://www.jcp.org/en/jsr/detail?id=203">JSR 203</a>，简单来说就是一些 API 用于文件系统访问、可伸缩的异步 i/o 操作、套接字通道绑定和配置以及多播数据报。</p><p>由于NIO.2具有异步能力，所以NIO.2又被称为AIO(Asynchronous I/O)。</p><h2 id="名词解释"><a class="markdownIt-Anchor" href="#名词解释"></a> 名词解释</h2><ol><li><p>阻塞和非阻塞<br>阻塞调用在调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用在不能立刻得到结果之前，该调用不会阻塞当前线程。<br>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的<strong>状态</strong>。</p></li><li><p>同步和异步<br>同步，就是在发出一个“调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦<strong>调用返回</strong>，就得到返回值了。换句话说，就是由“调用者”主动等待结果。<br>异步则是相反，“调用”在发出之后，这个调用就直接返回了，没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在“调用”发出后，“被调用者”通过状态、通知来通知调用者，或回调处理这个调用。<br>同步和异步关注的是<strong>获取结果的方式</strong>。<a href="#reference">[1]</a></p><p>从上面的解释来看，虽然阻塞/非阻塞和同步/异步是两组关注点不同的概念，还是存在一些疑惑：</p><ul><li>阻塞和同步的区别是什么？<br>阻塞调用会一直block住对应的进程（线程）直到操作完成，数据从kernel中拷贝到用户内存后，用户进程（线程）解除blocking。同步可以是阻塞的也可以是非阻塞的。</li><li>非阻塞和异步的区别是什么？<br>非阻赛是在kernel还在准备数据的情况下会立刻返回，用户进程（线程）可通过轮询kernel等方式，直到数据准备好再拷贝数据到用户内存来获取数据，这种方式就是同步非阻塞。异步就是用户进程将整个操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据，kernel已经将数据拷贝至用户内存。</li></ul></li></ol><h2 id="nio与aio"><a class="markdownIt-Anchor" href="#nio与aio"></a> NIO与AIO</h2><p>通过上面的解释我们知道了NIA与AIO的区别，由于AIO具备异步的特性，它不需要采用轮询的方式来获取数据，只需等待通知就可以获取数据，摒除了空等，相对NIO来说性能有所提高。</p><h2 id="java-nio-direct-buffer的优势"><a class="markdownIt-Anchor" href="#java-nio-direct-buffer的优势"></a> Java NIO direct buffer的优势</h2><p>以下是官方文档给出的说明：</p><p>Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.</p><p>大致意思是：给定一个直接字节缓冲区，Java虚拟机将尽最大努力直接对它执行本地 I/O 操作。也就是说，它将尝试避免在每次调用某个底层操作系统的本地 I/O操作之前（或之后）将缓冲区内容复制到中间缓冲区（或从中间缓冲区复制到缓冲区）。</p><p>优势很明显，减少一次拷贝过程。</p><p>NIO 操作的时候，那么是不是有这么一个中间缓冲区呢？</p><p>Java NIO 在读写到相应的 Channel 的时候，会先将 Java Heap 的 buffer 内容拷贝至直接内存—— Direct Memory。这样的话，采用 DirectByteBuffer 的性能肯定强于使用 HeapByteBuffer，它省去了临时buffer的拷贝开销，这也是为什么各个NIO框架大多使用DirectByteBuffer的原因。</p><p>绝大部分Channel类都是通过sun.nio.ch.IOUtil，这个工具类和外界进行通讯的，如FileChannel/SocketChannel等等，查看sun.nio.ch.IOUtil#read和sun.nio.ch.IOUtil#write代码可以证明这点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var1.isReadOnly()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Read-only buffer&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> readIntoNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var5</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var1.remaining());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var7;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> readIntoNativeBuffer(var0, var5, var2, var4);</span><br><span class="line">            var5.flip();</span><br><span class="line">            <span class="keyword">if</span> (var6 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.put(var5);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var7 = var6;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">write</span><span class="params">(FileDescriptor var0, ByteBuffer var1, <span class="type">long</span> var2, NativeDispatcher var4)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">if</span> (var1 <span class="keyword">instanceof</span> DirectBuffer) &#123;</span><br><span class="line">        <span class="keyword">return</span> writeFromNativeBuffer(var0, var1, var2, var4);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">var5</span> <span class="operator">=</span> var1.position();</span><br><span class="line">        <span class="type">int</span> <span class="variable">var6</span> <span class="operator">=</span> var1.limit();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> var5 &lt;= var6;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">var7</span> <span class="operator">=</span> var5 &lt;= var6 ? var6 - var5 : <span class="number">0</span>;</span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">var8</span> <span class="operator">=</span> Util.getTemporaryDirectBuffer(var7);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> var10;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            var8.put(var1);</span><br><span class="line">            var8.flip();</span><br><span class="line">            var1.position(var5);</span><br><span class="line">            <span class="type">int</span> <span class="variable">var9</span> <span class="operator">=</span> writeFromNativeBuffer(var0, var8, var2, var4);</span><br><span class="line">            <span class="keyword">if</span> (var9 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                var1.position(var5 + var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            var10 = var9;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Util.offerFirstTemporaryDirectBuffer(var8);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，如果 var1 是 Directbuffer 就直接拷贝（或写入），否则创建一个临时 Directbuffer，将 var1 写入这个临时 Directbuffer，然后再拷贝（或写入）。</p><p>Java为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？</p><p>HeapByteBuffer 内存是分配在堆上的，直接由 Java 虚拟机负责垃圾收集，DirectByteBuffer 是通过 JNI 在 Java 虚拟机外的内存中分配了一块内存（所以即使在运行时通过 -Xmx 指定了 Java 虚拟机的最大堆内存，还是可能实例化超出该大小的 Direct ByteBuffer），DirectByteBuffer 是用户空间的，它的创建是使用了 malloc 申请的内存，该内存块并不直接由 Java 虚拟机负责垃圾收集，但是在 Direct ByteBuffer 包装类被回收时，会通过 Java Reference 机制来释放该内存块。</p><p>当把一个地址通过JNI传递给底层的C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在GC管理下的对象是会在Java堆中移动的。也就是说，有可能把一个地址传给底层的write，但是这段内存却因为GC整理内存而失效了。所以必须要把待发送的数据放到一个GC管不着的地方。这就是调用native方法之前，数据一定要在堆外内存的原因。DirectBuffer 没有省内存拷贝，但是使用HeapBuffer却需要多一次拷贝，所以相对来说Directbuffer要快。</p><p>此外，Directbuffer 的 GC 压力更小。虽然 GC 仍然管理着 DirectBuffer 的回收，但它是使用 PhantomReference 来达到的，在平常的 Young GC 或者 mark and compact 的时候却不会在内存里搬动。如果IO的数量比较大，比如在网络发送很大的文件，那么 GC 的压力下降就会很明显。<a href="#reference">[2]</a></p><h2 id="后记"><a class="markdownIt-Anchor" href="#后记"></a> 后记</h2><p>I/O模型中只有同步阻塞、同步非阻塞和异步，没有异步非阻塞。</p><p>所有的系统I/O都分为两个阶段：等待就绪和操作。举例来说，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p><p>下图是几种常见I/O模型的对比：<br><img src="nio2.jpg" alt="IO module"></p><p>下图是阻塞/非阻塞和同步/异步的小结：<br><img src="IO.jpg" alt="同步/异步"></p><div id="reference"></div><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/60892134/answer/182225677">Java NIO direct buffer的优势在哪儿？</a></p></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-09T06:25:59.000Z" title="2018-02-09T06:25:59.000Z">2018-02-09</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">7 分钟读完 (大约1013个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/09/String%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CString-intern/">String常量池和String.intern</a></h1><div class="content"><h1 id="string常量池和stringintern"><a class="markdownIt-Anchor" href="#string常量池和stringintern"></a> String常量池和String.intern</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>字符串在实际中使用非常频繁，如果为每个字符串常量都生成一个String对象，明显会造成内存的浪费，针对这一问题，JVM实现一个字符串常量池的概念，提供了如下实现：</p><ol><li>相同的字符串常量，在常量池只有一份副本；</li><li>通过双引号声明的字符串，直接保存在常量池中；</li><li>如果是String对象，可以通过String.intern方法，把字符串常量保存到常量池中；</li></ol><p>提示：<br><strong>Jave不仅有字符串常量池，Java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型（Double 、Float）的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用常量池，即JVM不负责创建和管理大于127的这些类的对象。</strong></p><h2 id="intern方法"><a class="markdownIt-Anchor" href="#intern方法"></a> intern方法</h2><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testIntern</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;Intern&quot;</span>).append(<span class="string">&quot;StringTest&quot;</span>).toString();</span><br><span class="line">    System.out.println(s1.intern() == s1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;CP&quot;</span>).append(<span class="string">&quot;936&quot;</span>).toString();</span><br><span class="line">    System.out.println(s2.intern() == s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.7的结果:<br>true<br>false<br>为什么不是:<br>true<br>true</p><h2 id="原因"><a class="markdownIt-Anchor" href="#原因"></a> 原因</h2><h3 id="intern的实现"><a class="markdownIt-Anchor" href="#intern的实现"></a> intern的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a canonical representation for the string object.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * A pool of strings, initially empty, is maintained privately by the</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> String&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * When the intern method is invoked, if the pool already contains a</span></span><br><span class="line"><span class="comment"> * string equal to this &#123;<span class="doctag">@code</span> String&#125; object as determined by</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span></span><br><span class="line"><span class="comment"> * returned. Otherwise, this &#123;<span class="doctag">@code</span> String&#125; object is added to the</span></span><br><span class="line"><span class="comment"> * pool and a reference to this &#123;<span class="doctag">@code</span> String&#125; object is returned.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * It follows that for any two strings &#123;<span class="doctag">@code</span> s&#125; and &#123;<span class="doctag">@code</span> t&#125;,</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="doctag">@code</span> true&#125;</span></span><br><span class="line"><span class="comment"> * if and only if &#123;<span class="doctag">@code</span> s.equals(t)&#125; is &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * All literal strings and string-valued constant expressions are</span></span><br><span class="line"><span class="comment"> * interned. String literals are defined in section 3.10.5 of the</span></span><br><span class="line"><span class="comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a string that has the same contents as this string, but is</span></span><br><span class="line"><span class="comment"> *          guaranteed to be from a pool of unique strings.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>从上面的代码（反编译jdk8）看出String.intern在java中是native方法，注释翻译如下：<br>执行intern方法时，如果常量池中存在和String对象相同的字符串，则返回常量池中对应字符串的引用；<br>如果常量池中不存在对应的字符串，则添加该字符串到常量池中，并返回字符串引用。</p><h3 id="字符串常量池"><a class="markdownIt-Anchor" href="#字符串常量池"></a> 字符串常量池</h3><p>如果是jdk6，上面的代码执行结果会是：false false。jdk7之前常量池的内存在永久代进行分配，永久代和Java堆的内存是物理隔离的，执行intern方法时，如果常量池不存在该字符串，虚拟机会在常量池中复制该字符，再返回并返回引用。jdk6的常量池没有上面例子的两个字符串，所以返回的都是false。</p><p>为什么jdk7返回ture和false呢？原因是jdk7把字符串常量池移到了堆中。</p><ul><li>第一个字符串在常量池中不存在，就要字符串添加到常量池中，由于常量池在堆上，添加的时候只是加上该字符串的引用，没有拷贝的过程，然后再返回该字符串的引用，这样intern返回的引用和s1是同一个引用，所以打印出true；</li><li>第二个打印出false，只有一个原因，常量池中有那个字符串。调试时发现确实在字符串常量池中发现这该字符串，如下图：<br><img src="Instances_java.lang.String.jpg" alt="Instances of java.lang.String"></li></ul><h2 id="字符串常量池大小"><a class="markdownIt-Anchor" href="#字符串常量池大小"></a> 字符串常量池大小</h2><ul><li>1、jdk6是1009</li><li>2、jdk7默认是60013，可以通过-XX:StringTableSize = 10009设置StringTable大小，<br>通过-XX:+PrintFlagsFinal打印虚拟机的Global flags参数，可以获得当前StringTable的大小。</li><li>3、jdk8移除了PermGen，常量池移动了堆上，大小受程序内存的限制。</li></ul></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/Java/page/0/">上一页</a></div><div class="pagination-next"><a href="/tags/Java/page/2/">下一页</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/Java/">1</a></li><li><a class="pagination-link" href="/tags/Java/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>