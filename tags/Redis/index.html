<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>标签: Redis - 无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">Redis</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2019-11-18T08:51:51.000Z" title="2019-11-18T08:51:51.000Z">2019-11-18</time>发表</span><span class="level-item"><time datetime="2020-12-28T10:35:41.549Z" title="2020-12-28T10:35:41.549Z">2020-12-28</time>更新</span><span class="level-item">18 分钟读完 (大约2723个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/18/redis5%E4%BC%AA%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">redis5伪集群搭建</a></h1><div class="content"><h2 id="redis的发行版本解释"><a class="markdownIt-Anchor" href="#redis的发行版本解释"></a> Redis的发行版本解释</h2><p>格式: major.minor.patchlevel<br>说明: major 主版本号<br>minor 次版本号，如果为偶数表示当前版本是一个稳定版本，否则是一个非稳定版本(不适合生产环境使用)<br>patchlevel 补丁bug修复</p><h2 id="编译"><a class="markdownIt-Anchor" href="#编译"></a> 编译</h2><p>redis-6.x 开始的多线程代码依赖 C标准库中的新增类型 _Atomic 。但是 gcc 从 4.9 版本才开始正式和完整地支持 stdatomic（gcc-4.8.5 部分支持），而 centos7 默认的 gcc 版本为：4.8.5，无法正确的编译，所以需要升级 gcc 才能正确的编译 redis-6.x。升级方法：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum  -y  install  centos-release-scl</span><br><span class="line">yum  -y  install  devtoolset-9-gcc  devtoolset-9-gcc-c++  devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line"><span class="comment">#临时有效，退出 shell 或重启会恢复原 gcc 版本</span></span><br><span class="line">scl <span class="built_in">enable</span> devtoolset-9 bash</span><br><span class="line"><span class="comment">#长期有效</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure><p>redis 的编译方法见下文。</p><h2 id="单机安装"><a class="markdownIt-Anchor" href="#单机安装"></a> 单机安装</h2><ol><li><p>下载redis5.0.6二进制安装包<br>wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redis-5.0.6.tar.gz">http://download.redis.io/releases/redis-5.0.6.tar.gz</a></p></li><li><p>解压到/usr/local目录下<br>tar -xzvf redis-5.0.6.tar.gz -C /usr/local</p></li><li><p>编译<br>cd /usr/local/redis-5.0.6 &amp;&amp; make<br>如果make出错，尝试改用 make MALLOC=libc 编译。</p></li><li><p>指定安装位置<br>make install PREFIX=/usr/local/redis</p></li><li><p>拷贝安装目录下配置文件到 /usr/local/redis/conf<br>mkdir /usr/local/redis/conf<br>cp /usr/local/redis-5.0.6/redis.conf /usr/local/redis/conf/</p></li><li><p>修改配置文件 /usr/local/redis/conf/redis.conf<br>vi /usr/local/redis/conf/redis.conf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 以守护进程后台模式运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 绑定本机ip</span></span><br><span class="line"><span class="built_in">bind</span> 172.18.203.30</span><br><span class="line"><span class="comment"># redis进程文件</span></span><br><span class="line">pidfile /usr/local/redis/redis_6379.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/log/redis_6379.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 快照数据存放目录,一定是目录</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis/data/</span><br><span class="line"><span class="comment"># 认证密码</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure></li></ol><p>默认的bind 接口是127.0.0.1，也就是本地回环地址。这样的话，访问redis服务只能通过本机的客户端连接，而无法通过远程连接。<br>改成监听的网卡IP或者 0.0.0.0 可使任意IP均可访问。</p><p>在redis目录创建log和data目录<br>7. 启动redis<br>/usr/local/redis/bin/redis-server /usr/local/redis/conf/redis.conf<br>8. 查看是否启动成功<br>查看进程:<br>ps aux | grep redis<br>查看日志:<br>tail -fn 500 /usr/local/redis/log/redis_6379.log<br>命令端验证:<br>/usr/local/redis/bin/redis-cli -h 172.18.203.30 -p 6379<br>172.18.203.30:6379&gt; ping<br>PONG<br>9. 停止redis服务<br>/usr/local/redis/bin/redis-cli shutdown</p><h2 id="集群搭建"><a class="markdownIt-Anchor" href="#集群搭建"></a> 集群搭建</h2><p>redis建议三主三从共6个节点组成redis集群，测试环境可一台物理上启动6个redis节点，但生产环境至少要准备3台物理机。</p><ol><li><p>服务器上搭建有6个节点的 Redis集群，在路径为/usr/local/redis/redis-cluster下创建6个文件夹代表6个实例。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster</span><br><span class="line"><span class="built_in">cd</span> /usr/local/redis/redis-cluster</span><br><span class="line"><span class="built_in">mkdir</span> 7000 7001 7002 7003 7004 7005</span><br></pre></td></tr></table></figure></li><li><p>分别给这6个文件夹，创建日志、数据存放路径。配置文件放实例路径（如：7000）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7000/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7000/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7001/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7001/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7002/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7002/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7003/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7003/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7004/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7004/data</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7005/log</span><br><span class="line"><span class="built_in">mkdir</span> /usr/local/redis/redis-cluster/7005/data</span><br></pre></td></tr></table></figure></li><li><p>进安装redis-cluster的实例目录将 redis.conf 配置文件拷贝到 7000 这个目录，并重名命为 7000.conf</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span>  /usr/local/redis-5.0.6/redis.conf /usr/local/redis/redis-cluster/7000/7000.conf</span><br></pre></td></tr></table></figure></li><li><p>分别进入 7000 目录修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改端口号对应目录的端口号</span></span><br><span class="line">port 7000</span><br><span class="line"><span class="comment"># Ip绑定 绑定监听的网卡IP或者改为 0.0.0.0，</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 数据位置dir ./  改为&gt;dir /usr/local/redis/redis-cluster/7000/data</span></span><br><span class="line"><span class="built_in">dir</span> /usr/local/redis/redis-cluster/7000/data</span><br><span class="line"><span class="comment"># 启用集群模式</span></span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 集群模式中节点的配置文件，文件不指定路径会在data生成</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="comment"># 超时时间</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># redis数据持久化开启，开启AOF模式</span></span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 非保护模式，允许 Redis 远程访问</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># pidfile 需要随着文件夹的不同调增</span></span><br><span class="line">pidfile /usr/local/redis/redis-cluster/7000/redis_7000.pid</span><br><span class="line"><span class="comment"># 日志文件</span></span><br><span class="line">logfile /usr/local/redis/redis-cluster/7000/log/redis_7000.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 如需密码则修改如下配置</span></span><br><span class="line"><span class="comment"># 在：# requirepass foobared 下新增密码配置</span></span><br><span class="line">requirepass 123456</span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt; 下新增密码配置</span></span><br><span class="line">masterauth 654321</span><br><span class="line"><span class="comment"># nat或容器，内外网地址不一样的情况下，配置 cluster-announce-ip 为外网地址</span></span><br><span class="line">cluster-announce-ip 212.64.5.128</span><br></pre></td></tr></table></figure></li><li><p>拷贝 7000.conf 到其它配置目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line"><span class="built_in">cp</span> /usr/local/redis/redis-cluster/7000/redis.conf /usr/local/redis/redis-cluster/7005/7005.conf</span><br></pre></td></tr></table></figure></li><li><p>如上例修改剩下的 5 个配置，将 7000 改成对应的目录，如7001、7002等</p></li><li><p>加载 6 个redis配置文件启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录启动redis (加载制定配置文件启动的方式)  6个都要启动，注意换配置文件位置</span></span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7000/7000.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line">/usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7005/7005.conf</span><br><span class="line"><span class="comment"># ps进程看看是否都启动</span></span><br><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建redis集群"><a class="markdownIt-Anchor" href="#创建redis集群"></a> 创建redis集群</h3><ol><li><p>创建redis4.x集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入redis的src目录</span></span><br><span class="line">./redis-trib.rb create --replicas 1 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002</span><br></pre></td></tr></table></figure><p>安装过程中，输入 yes，无报错，结尾出现[OK]即创建成功！</p></li><li><p>创建redis5.x集群</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># redis5.x用redis-cli方式 不用redis4.x用的redis-trib.rb方式</span></span><br><span class="line">/usr/local/redis/bin/redis-cli --cluster create 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002 0.0.0.0:7003 0.0.0.0:7004 0.0.0.0:7005 --cluster-replicas 1 -a <span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure><p>需先启动redis。<br>–cluster-replicas 1 表示为集群中的每一个主节点指定一个从节点，即一比一的复制。<br>安装过程中，输入 yes，Reids5 集群搭建完成。</p></li><li><p>重建集群<br>先停止服务，再把各个节点下的 appendonly.aof，dump.rdb，nodes.conf 删除后，重建集群即可。删除各节点 data 中的文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7000/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7001/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7002/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7003/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7004/data/*</span><br><span class="line"><span class="built_in">rm</span> -f /usr/local/redis/redis-cluster/7005/data/*</span><br></pre></td></tr></table></figure></li></ol><h2 id="redis5集群其他操作"><a class="markdownIt-Anchor" href="#redis5集群其他操作"></a> Redis5集群其他操作</h2><p>Redis5 提供了关闭集群的工具，在如下目录：<br>/usr/local/redis-5.0.6/utils/create-cluster<br>打开此文件修改端口为我们自己的，如 6999。端口PROT设置为6999，NODES为6，工具会自动累加1 生成 7000-7005 六个节点 用于操作。<br>修改stop代码块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ $((PORT &lt; ENDPORT)) != <span class="string">&quot;0&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">        PORT=$((PORT+<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Stopping <span class="variable">$PORT</span>&quot;</span></span><br><span class="line">        ./redis-cli -p <span class="variable">$PORT</span> -a <span class="string">&quot;123456&quot;</span> shutdown nosave</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="查看集群状态"><a class="markdownIt-Anchor" href="#查看集群状态"></a> 查看集群状态</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看节点详细信息</span><br><span class="line">redis-cli -a <span class="string">&#x27;123456&#x27;</span> -p 7000 cluster info</span><br><span class="line">// 查看所有节点</span><br><span class="line">redis-cli -a <span class="string">&#x27;123456&#x27;</span> -p 7000 cluster nodes</span><br></pre></td></tr></table></figure><h3 id="关闭集群"><a class="markdownIt-Anchor" href="#关闭集群"></a> 关闭集群</h3><p>执行 <code>create-cluster stop</code> 可关闭集群。</p><h3 id="启动集群"><a class="markdownIt-Anchor" href="#启动集群"></a> 启动集群</h3><p>执行 <code>create-cluster start</code> 可启动集群<br>建议启动脚本自己编写。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PORT=6999</span><br><span class="line">NODES=6</span><br><span class="line"></span><br><span class="line">ENDPORT=$((PORT+NODES))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;start&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7000/7000.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7001/7001.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7002/7002.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7003/7003.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7004/7004.conf</span><br><span class="line">        /usr/local/redis/bin/redis-server /usr/local/redis/redis-cluster/7005/7005.conf</span><br><span class="line"><span class="comment"># 配置集群时执行一次</span></span><br><span class="line"><span class="comment"># /usr/local/redis/bin/redis-cli --cluster create 0.0.0.0:7000 0.0.0.0:7001 0.0.0.0:7002 0.0.0.0:7003 0.0.0.0:7004 0.0.0.0:7005 --cluster-replicas 1 -a &#x27;123456&#x27;</span></span><br><span class="line">        <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$1</span>&quot;</span> == <span class="string">&quot;stop&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">while</span> [ $((PORT &lt; ENDPORT)) != <span class="string">&quot;0&quot;</span> ]; <span class="keyword">do</span></span><br><span class="line">        PORT=$((PORT+<span class="number">1</span>))</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;Stopping <span class="variable">$PORT</span>&quot;</span></span><br><span class="line">        ./redis-cli -p <span class="variable">$PORT</span> -a <span class="string">&quot;123456&quot;</span> shutdown nosave</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [start|stop]&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start       -- Launch Redis Cluster instances.&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;stop        -- Stop Redis Cluster instances.&quot;</span></span><br></pre></td></tr></table></figure><h2 id="redis-启动-3-个警告"><a class="markdownIt-Anchor" href="#redis-启动-3-个警告"></a> redis 启动 3 个警告</h2><h3 id="overcommit_memory-报警"><a class="markdownIt-Anchor" href="#overcommit_memory-报警"></a> overcommit_memory 报警</h3><p>WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</p><p>内核参数 overcommit_memory，它是 内存分配策略<br>可选值：0、1、2。<br>0: 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，<br>并把错误返回给应用进程。<br>1: 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。<br>2: 表示内核允许分配超过所有物理内存和交换空间总和的内存</p><p>Linux 对大部分申请内存的请求都回复&quot;yes&quot;，以便能跑更多更大的程序。因为申请内存后，并不会马上使用内存。这种技术叫做 Overcommit。当 linux 发现内存不足时，会发生OOM killer(OOM=out-of-memory)。它会选择杀死一些进程(用户态进程，不是内核线程)，以便释放内存。<br>当 oom-killer 发生时，linux 会选择杀死哪些进程？选择进程的函数是 oom_badness 函数(在 mm/oom_kill.c 中)，该函数会计算每个进程的点数(0~1000)。点数越高，这个进程越有可能被杀死。每个进程的点数跟 oom_score_adj 有关，而且 oom_score_adj 可以被设置(-1000最低，1000最高)。</p><p>解决方法：<br>按提示的操作（将vm.overcommit_memory 设为1）即可：<br>有三种方式修改内核参数，但要有root权限：（直接修改宿主机的配置文件）</p><ol><li>编辑/etc/sysctl.conf ，添加 vm.overcommit_memory=1，然后 sysctl -p 使配置文件生效</li><li>sysctl vm.overcommit_memory=1</li><li>echo 1 &gt; /proc/sys/vm/overcommit_memory</li></ol><h3 id="关闭thp"><a class="markdownIt-Anchor" href="#关闭thp"></a> 关闭THP</h3><p>WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo madvise &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled (set to ‘madvise’ or ‘never’).</p><p>Linux kernel 在2.6.38内核增加了 THP 特性， 支持大内存页（2MB） 分配， 默认开启。 当开启时可以降低 fork 子进程的速度， 但 fork 操作之后， 每个内存页从原来4KB变为2MB， 会大幅增加重写期间父进程内存消耗。 同时每次写命令引起的复制内存页单位放大了512倍， 会拖慢写操作的执行时间， 导致大量写操作慢查询， 例如简单的 incr 命令也会出现在慢查询中。 因此 Redis 日志中建议将此特性进行禁用。</p><p>redis 给出的解决方案是将 THP 设置为 madvise 或 never。<code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>。<br>为了使机器重启后 THP 配置依然生效，可以在 /etc/rc.local 中追加&quot;echo never&gt;/sys/kernel/mm/transparent_hugepage/enabled&quot;。</p><h3 id="the-tcp-backlog-setting"><a class="markdownIt-Anchor" href="#the-tcp-backlog-setting"></a> The TCP backlog setting</h3><p>WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</p><p>将 net.core.somaxconn=1024 添加到 /etc/sysctl.conf 中，然后执行 sysctl -p 生效配置。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-08-23T07:09:33.000Z" title="2018-08-23T07:09:33.000Z">2018-08-23</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">2 分钟读完 (大约363个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/08/23/jedis%E6%8A%A5%E9%94%99-No-reachable-node-in-cluster/">jedis报错:No reachable node in cluster</a></h1><div class="content"><h1 id="jedis报错no-reachable-node-in-cluster"><a class="markdownIt-Anchor" href="#jedis报错no-reachable-node-in-cluster"></a> jedis报错:No reachable node in cluster</h1><p>服务器掉电重启后，java项目报错了：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.data.redis.RedisConnectionFailureException: No reachable node in cluster; nested exception is redis.clients.jedis.exceptions.JedisNoReachableClusterNodeException: No reachable node in cluster  </span><br><span class="line">    at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:67)  </span><br><span class="line">    at org.springframework.data.redis.connection.jedis.JedisExceptionConverter.convert(JedisExceptionConverter.java:41)  </span><br><span class="line">    at org.springframework.data.redis.PassThroughExceptionTranslationStrategy.translate(PassThroughExceptionTranslationStrategy.java:37)  </span><br><span class="line">    at org.springframework.data.redis.connection.jedis.JedisClusterConnection.convertJedisAccessException(JedisClusterConnection.java:3696)  </span><br><span class="line">    at org.springframework.data.redis.connection.jedis.JedisClusterConnection.get(JedisClusterConnection.java:546)  </span><br><span class="line">    at org.springframework.data.redis.connection.DefaultStringRedisConnection.get(DefaultStringRedisConnection.java:284)  </span><br><span class="line">    at org.springframework.data.redis.core.DefaultValueOperations$1.inRedis(DefaultValueOperations.java:46)  </span><br><span class="line">    at org.springframework.data.redis.core.AbstractOperations$ValueDeserializingRedisCallback.doInRedis(AbstractOperations.java:54)  </span><br><span class="line">    at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:204)  </span><br><span class="line">    at org.springframework.data.redis.core.RedisTemplate.execute(RedisTemplate.java:166)  </span><br><span class="line">    at org.springframework.data.redis.core.AbstractOperations.execute(AbstractOperations.java:88)  </span><br><span class="line">    at org.springframework.data.redis.core.DefaultValueOperations.get(DefaultValueOperations.java:43)  </span><br><span class="line">    at com.jhqc.pxsj.msa.pub.redis.RedisForStringServiceImpl.get(RedisForStringServiceImpl.java:29)</span><br></pre></td></tr></table></figure><p>应是redis cluster出问题了，对解决方法做个记录备忘。</p><ol><li><p>重启redis集群</p></li><li><p>检测redis 节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb check  192.168.31.233:7000</span><br></pre></td></tr></table></figure><p>但是出现如下错误信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line"></span><br><span class="line">[WARNING] Node 192.168.31.233:7000 has slots <span class="keyword">in</span> importing state (19816).</span><br><span class="line"></span><br><span class="line">[WARNING] Node 192.168.31.233:7001 has slots <span class="keyword">in</span> migrating state (19816).</span><br><span class="line"></span><br><span class="line">[WARNING] The following slots are open: 19816</span><br></pre></td></tr></table></figure><p>尝试用：<code>redis-trib.rb fix 192.168.31.233:7000</code> 提示：<code>[ERR] Calling MIGRATE: ERR Syntax error, try CLIENT (LIST | KILL | GETNAME | SETNAME | PAUSE | REPLY)</code></p></li><li><p>清理 slot</p><p>使用命令：<code>cluster setslot 19816 stable</code> 清理id为19816有问题的slot。<br>note：服务器cluster命令没有找到，通过RedisDesktopManager连接上每个节点，执行上面的命令。</p></li><li><p>重启redis cluster</p></li><li><p>重启java服务<br>没重启java服务，客户端同样报错，重启后正常。</p></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-08T06:51:06.000Z" title="2018-03-08T06:51:06.000Z">2018-03-08</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.212Z" title="2019-05-15T02:48:47.212Z">2019-05-15</time>更新</span><span class="level-item">20 分钟读完 (大约2996个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/08/Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/">Redis应用场景</a></h1><div class="content"><h1 id="redis应用场景"><a class="markdownIt-Anchor" href="#redis应用场景"></a> Redis应用场景</h1><h2 id="redis介绍"><a class="markdownIt-Anchor" href="#redis介绍"></a> Redis介绍</h2><p>Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。从2015年6月开始，Redis的开发由Redis Labs赞助，根据月度排行网站DB-Engines.com的数据显示，Redis是最流行的键值对存储数据库。</p><p>Redis的外围由一个键、值映射的字典构成。与其他非关系型数据库主要不同在于：Redis中值的类型不仅限于字符串，还支持如下抽象数据类型：</p><ul><li>字符串列表</li><li>无序不重复的字符串集合</li><li>有序不重复的字符串集合</li><li>键、值都为字符串的哈希表</li></ul><p>值的类型决定了值本身支持的操作。Redis支持不同无序、有序的列表，无序、有序的集合间的交集、并集等高级服务器端原子操作。</p><h2 id="redis应用"><a class="markdownIt-Anchor" href="#redis应用"></a> Redis应用</h2><h3 id="会话缓存"><a class="markdownIt-Anchor" href="#会话缓存"></a> 会话缓存</h3><p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化、Redis提供的数据类型丰富。例如：缓存用户的登录信息，由于用户登录信息有时比较复杂，如果采用json格式存储，使用起来会简单很多。</p><h3 id="列出最新的项目列表"><a class="markdownIt-Anchor" href="#列出最新的项目列表"></a> 列出最新的项目列表</h3><p>下面这个语句常用来显示最新项目，随着数据多了，查询毫无疑问会越来越慢。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> foo <span class="keyword">WHERE</span> … <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="type">time</span> <span class="keyword">DESC</span> LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>应用中，“列出最新的回复”之类的查询非常普遍。如果数据库进行了分库分表的话，查询会变得复杂而且性能低下。类似的问题就可以用Redis来解决。比如说，我们的一个应用想要列出用户贴出的最新20条评论。我们假设数据库中的每条评论都有一个唯一的ID字段。我们可以使用分页来制作主页和评论页，使用Redis的模板，每次新评论发表时，我们会将它的ID添加到一个Redis列表：<br><code>LPUSH latest.comments</code><br>我们将列表裁剪为指定长度，因此Redis只需要保存最新的5000条评论：<br><code>LTRIM latest.comments 0 5000</code></p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/list/lpush.html">LPUSH</a><br>LPUSH key value [value …]<br>将一个或多个值 value 插入到列表 key 的表头</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/list/ltrim.html">LTRIM</a><br>LTRIM key start stop<br>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</p><p>当我们需要获取最新评论的项目范围时，调用一个函数来完成(使用伪代码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Comment&gt; <span class="title function_">getLatestComments</span><span class="params">(start, num_items)</span> &#123;</span><br><span class="line">    id_list = redis.lrange(<span class="string">&quot;latest.comments&quot;</span>,start,start+num_items – <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (id_list.length &lt; num_items) &#123;</span><br><span class="line">        id_list = SQL_DB(<span class="string">&quot;SELECT … ORDER BY time LIMIT …&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> id_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最新ID常驻在Redis中，并且一直是在更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。当然根据需求也可以不访问数据库。</p><h3 id="排名"><a class="markdownIt-Anchor" href="#排名"></a> 排名</h3><p>还有一个很普遍的需求是按得分排名，在按得分排序以及实时更新这些几乎每秒钟都需要更新的功能上数据库的性能不够理想。典型的比如那些在线游戏的排行榜，根据得分你通常想要：</p><ul><li>列出前100名高分选手</li><li>列出某用户当前的全球排名</li></ul><p>这些操作对于Redis来说很简单，即使你有几百万个用户，每分钟都会有几百万个新的得分。<br>模式是这样的，每次获得新得分时，我们用这样的代码：<br><code>ZADD userscore</code><br>得到前100名高分用户很简单：<br><code>ZREVRANGE userscore 0 99</code><br>用户的全球排名也相似，只需要：<br><code>ZRANK userscore</code></p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zadd.html">ZADD</a><br>ZADD key score member [[score member] [score member] …]<br>将一个或多个 member 元素及其 score 值加入到<strong>有序集</strong> key 当中。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zrevrange.html">ZREVRANGE</a><br>ZREVRANGE key start stop [WITHSCORES]<br>返回有序集 key 中，指定区间内的成员。其中成员的位置按 score 值递减(从大到小)来排列.</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zrank.html">ZRANK</a><br>ZRANK key member<br>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。</p><h3 id="延时任务"><a class="markdownIt-Anchor" href="#延时任务"></a> 延时任务</h3><p>经常有类似的需求:</p><ul><li>订单生成后10分钟,如果用户不付款就关闭订单</li><li>用户超时2天未收货，修改为自动收货</li></ul><p>针对于类似这样的任务,一般我们是用定时任务来处理的。订单是存储在mysql的一个表里,表里会有各种状态和创建时间。利用quartz来设定一个定时任务,我们暂时设置为每5分钟扫描一次。扫描的条件为未付款并且当前时间大于创建时间超过15分钟.然后我们再去逐一的操作每一条数据。这个方案简单易用, 但扫表会增加程序负荷、任务执行不够准时。</p><p>还可以采用延时的方式来处理这样的问题，例如利用jdk自带的delayQueue。delayQueue的有点是：效率高,任务触发时间延迟低，不需要扫表，不会对数据库造成压力。但是delayQueue不支持分布式。</p><p>Redis有2种思路实现延时任务：</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/sorted_set/zremrangebyscore.html">ZREMRANGEBYSCORE</a><br>ZREMRANGEBYSCORE key min max<br>移除有序集 key 中，所有 score 值介于 min 和 max 之间的成员。<br>时间复杂度: O(log(N)+M)， N 为有序集的基数，而 M 为被移除成员的数量。</p><ul><li><p>有序集合<br>使用 sorted Sets 的自动排序, key 为任务id，score 为任务计划执行时的时间戳，任务在 ZADD 加入 sets 后就已经按时间排序，然后采用 delayQueue 的思路每隔1s(或者其他间隔)用 ZRANGEBYSCORE 取出小于当前时间的的任务id 然后再去执行任务。</p><p>由于有序集合中只有任务id，所以还需要一个哈希表来存储任务，有序集合和哈希表通过任务id关联起来。由于先从集合中取出到期的任务id，再从哈希表中取出任务，这是两次操作，可能出现不满足事务的情况发生。处理方法是采用 Redis 事务机制来实现事务，或者利用 Redis 执行 Lua 脚本是原子性的来采用Lua脚本封装这两个操作。</p></li><li><p>键过期通知<br>Reids 2.8 后有一种“键空间”通知的机制 <a target="_blank" rel="noopener" href="http://redisdoc.com/topic/notification.html">Keyspace Notifications</a>，允许客户端去订阅一些key的事件，其中就有 key过期的事件，我们可以把 key 名称设置为 task 的 id 等标识(这种方式 value 的值无法取到，所以只用 key 来识别任务)，expire 设置为计划要执行的时间，然后设置一个客户端来订阅消息过期事件，然后处理 task。因为开启键空间通知功能需要消耗一些 CPU ，所以在默认配置下，该功能处于关闭状态。可以通过修改 redis.conf 文件，或者直接使用 CONFIGSET 命令来开启或关闭键空间通知功能。配置文件修改方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex  <span class="comment">// 打开此配置，其中Ex表示键事件通知里面的key过期事件，每当有过期键被删除时，会发送通知</span></span><br></pre></td></tr></table></figure><ul><li>notify-keyspace-events 选项的参数为空字符串时，功能关闭。</li><li>当参数不是空字符串时，功能开启。</li></ul><p>Redis 使用以下两种方式删除过期的键：</p><ul><li>当一个键被访问时，如果键已经过期，那么该键将被删除。</li><li>底层系统会在后台渐进地查找并删除那些过期的键，从而处理那些已经过期、但是还没被访问到的键。当过期键被程序发现、并且将键从数据库中删除时，Redis 会产生一个 expired 通知。Redis 并不保证生存时间（TTL）变为 0 的键会立即被删除：如果程序没有访问这个过期键，或者带有生存时间的键非常多的话，那么在键的生存时间变为0 ，直到键真正被删除这中间，可能会有一段比较显著的时间间隔。<br>那么通知产生的时间会有一段间隔，如果不能接受这个间隔，可采用有序集合的方式来实现延时任务。</li></ul></li></ul><h3 id="计数"><a class="markdownIt-Anchor" href="#计数"></a> 计数</h3><p>Redis 是一个很好的计数器，它有 INCRBY 等命令。虽然可以用数据库做计数器，来获取统计或显示新信息，但数据库太慢了。使用 Redis 就不需要再担心了。有了原子递增(atomic increment)，你可以放心的加上各种计数，用GETSET重置，或者是让它们过期。例如这样操作：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR user <span class="number">60</span></span><br></pre></td></tr></table></figure><p>计算出最近用户在页面间停顿超过或不超过60秒的页面浏览量。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/string/incrby.html">INCRBY</a><br>INCRBY key increment<br>将 key 所储存的值加上增量 increment。如果 key 不存在，那么 key 的值会先被初始化为 0 ，然后再执行 INCRBY 命令。如果值包含错误的类型，或字符串类型的值不能表示为数字，那么返回一个错误。本操作的值限制在 64 位(bit)有符号数字表示之内。</p><h3 id="指定时间内的特定项目"><a class="markdownIt-Anchor" href="#指定时间内的特定项目"></a> 指定时间内的特定项目</h3><p>比如想要知道某些特定的注册用户或IP地址，他们到底有多少访问了某篇文章。在获得一次新的页面浏览时只需要这样做：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD page:day0:</span><br></pre></td></tr></table></figure><p>当然用unix时间替换day0，比如time()-(time()%3600*24)等等。想知道特定用户的数量吗?只需要使用</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD page:day0:</span><br></pre></td></tr></table></figure><p>计算某个特定用户是否访问了这个页面：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER page:day0:</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/sadd.html">SADD</a><br>SADD key member [member …]<br>将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/scard.html">SCARD</a><br>SCARD key<br>返回集合 key 的基数(集合中元素的数量)。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/set/sismember.html">SISMEMBER</a><br>SISMEMBER key member<br>判断 member 元素是否集合 key 的成员。</p><h3 id="分布式锁"><a class="markdownIt-Anchor" href="#分布式锁"></a> 分布式锁</h3><p>利用 SETNX 可实现分布式锁。</p><p><a target="_blank" rel="noopener" href="http://redisdoc.com/string/setnx.html">SETNX</a><br>SETNX key value<br>将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作。<br>时间复杂度：O(1)<br>返回值：设置成功，返回 1 。设置失败，返回 0 。</p><p>设置成功会返回1，可表示拿到了锁，设置返回 0 表示没拿到锁，继续等待。释放锁可调用 DEL 删除 key。考虑到锁未释放而程序宕机，该锁将不会被释放的情况，可以给锁设置一个过期时间，过期后该锁会被 Redis 删除。</p></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>