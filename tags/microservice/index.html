<!doctype html><html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta><title>标签: microservice - 无远弗届</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="无远弗届"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="无远弗届"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="gspark&amp;#39;s blog"><meta property="og:type" content="blog"><meta property="og:title" content="无远弗届"><meta property="og:url" content="https://gspark.github.io/"><meta property="og:site_name" content="无远弗届"><meta property="og:description" content="gspark&amp;#39;s blog"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://gspark.github.io/img/og_image.png"><meta property="article:author" content="gspark"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://gspark.github.io"},"headline":"无远弗届","image":["https://gspark.github.io/img/og_image.png"],"author":{"@type":"Person","name":"gspark"},"description":"gspark&#39;s blog"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">gspark&#039;s blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">标签</a></li><li class="is-active"><a href="#" aria-current="page">microservice</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-22T06:22:31.000Z" title="2018-03-22T06:22:31.000Z">2018-03-22</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">29 分钟读完 (大约4419个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/22/kafka%E5%85%A5%E9%97%A8/">Kafka入门</a></h1><div class="content"><h1 id="kafka入门"><a class="markdownIt-Anchor" href="#kafka入门"></a> Kafka入门</h1><p>Kafka最初是由LinkedIn（领英）开发，并随后于2011年初开源，并于2012年10月23日由Apache Incubator孵化出站。Kafka由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams（一个Java流式处理库）。</p><h2 id="apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"><a class="markdownIt-Anchor" href="#apache的kafkatm是一个分布式流平台a-distributed-streaming-platform"></a> Apache的Kafka™是一个分布式流平台(a distributed streaming platform)</h2><ol><li>它可以让你发布和订阅记录流。在这方面，它类似于一个消息队列或企业消息系统。</li><li>它可以让你持久化收到的记录流，从而具有容错能力。</li><li>它可以让你处理收到的记录流。</li></ol><h2 id="何为消息系统"><a class="markdownIt-Anchor" href="#何为消息系统"></a> 何为消息系统</h2><p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不用关心消息如何共享。 分布式消息传递基于可靠消息队列的概念。 消息在客户端应用程序和消息传递系统之间异步排队。 有两种类型的消息模式可用：一种是点对点，另一种是发布-订阅（pub-sub）消息系统。 大多数消息模式遵循<strong>pub-sub</strong>。</p><h3 id="点对点消息系统"><a class="markdownIt-Anchor" href="#点对点消息系统"></a> 点对点消息系统</h3><p>在点对点消息系统中，消息被保留在队列中。 一个或多个消费者可以消费队列中的消息，但是特定消息最多只能由一个消费者消费。 一旦消费者读取队列中的消息，它就从该队列中消失。 该系统的典型示例是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器也可以同时工作。</p><p><img src="p2p-message-system.jpg" alt="点对点消息结构"></p><h3 id="发布-订阅消息系统"><a class="markdownIt-Anchor" href="#发布-订阅消息系统"></a> 发布-订阅消息系统</h3><p>在发布-订阅系统中，消息被保留在一个主题中。与点对点系统不同，消费者可以订阅一个或多个主题并使用该主题中的所有消息。在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者。</p><p><img src="ps-message-system.jpg" alt="发布-订阅消息结构"></p><h2 id="kafka通常用于下面的使用场景"><a class="markdownIt-Anchor" href="#kafka通常用于下面的使用场景"></a> Kafka通常用于下面的使用场景</h2><ul><li><p>监控<br>Kafka通常用于监控数据的操作。 这涉及聚合来自分布式应用程序的统计信息，以产生集中化的操作数据。</p></li><li><p>日志聚合方案<br>kafka可以用来收集跨组织的多个服务的日志，并将这些日志转为统一的格式供消费者使用。</p></li><li><p>流式处理<br>流行的实时计算框架，如Storm和Spark流式读取topic中的数据进行变换、处理，然后将结果写入新的，用户或应用需要使用的topic中。Kafka强大的持久性功能在流式处理上下文中也是非常有用的。</p></li><li><p>解耦<br>在项目启动之初来预测将来项目会碰到什么需求，是极其困难的。消息系统在处理过程中间插入了一个隐含的、基于数据的接口层，两边的处理过程都要实现这一接口。这允许你可以做出独立的扩展或者是修改两边的处理过程，只要确保它们遵守同样的接口约束。</p></li></ul><h2 id="kafka的架构"><a class="markdownIt-Anchor" href="#kafka的架构"></a> Kafka的架构</h2><p><img src="kafka-structure.jpg" alt="kafka的架构"></p><p>在上图中一个topic被配置为拥有3个分区，分区1包含两个偏移因子0和1。分区2包含4个偏移因子0， 1， 2 和 3。分区3包含1个偏移因子0。 分区副本的id和该副本所在的broker的id一致。<br>假设，如果一个topic配置的副本因子为3，则kafka会针对该topic的每个分区创建3个独立的副本并将这些副本尽量均匀分散到集群的每个节点上。为了在集群的节点间进行负载，每一个broker都会保存一个或多个这样的分区。多个producer和consumer可以同时发布或获取消息。</p><h3 id="相关术语"><a class="markdownIt-Anchor" href="#相关术语"></a> 相关术语</h3><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">topics</td><td style="text-align:left">隶属于特定分类的消息流称为topic。数据保存在topic中</td></tr><tr><td style="text-align:center">partitions</td><td style="text-align:left"><strong>topics</strong>会被切分为分区。针对每一个主题，kafka最少保持一个分区。每一个这样的分区以顺序不可变的方式保存消息。一个分区有一个或多个大小相同的<strong>segment</strong>文件组成。<strong>Topics</strong>拥有多个分区，因此可以保存大量的数据</td></tr><tr><td style="text-align:center">Partition offset</td><td style="text-align:left">每个分区中的消息拥有一个唯一的序列id，被称为<strong>offset</strong></td></tr><tr><td style="text-align:center">Replicas of partition</td><td style="text-align:left">分区副本仅仅是分区的备份，不会对副本分区进行读写操作，只是用来防止数据丢失</td></tr><tr><td style="text-align:center">Brokers</td><td style="text-align:left">1. Brokers 是维护发布消息的系统。每个broker针对每个topic可能包含0个或多个该topic的分区。假设，一个topic拥有N个分区，并且集群拥有N个broker，则每个broker会负责一个分区<br>2. 假设，一个topic拥有N个分区，并且集群拥有N+M个broker，则前N个broker每个处理一个分区，剩余的M个broker则不会处理任何分区<br>3。 假设，一个topic拥有N个分区，并且集群拥有M个broker（M &lt; N），则这些分区会在所有的broker中进行均匀分配。每个broker可能会处理一个或多个分区。这种场景不推荐使用，因为会导致热点问题和负载不均衡问题</td></tr><tr><td style="text-align:center">Kafka Cluster</td><td style="text-align:left">由多个broker组成的kafka被称为kafka集群。一个kafka集群在不停机扩展。集群负载所有消息的持久化和副本处理</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">Producers 是向一个或多个Kafka中topic发布消息的发布者。Producers 将消息发送到 Kafka 的 brokers中。任意时刻 producer 发布到broker中的消息都会被追加到某个分区的最后一个segment文件的最后。Producer 也可以选择消息发送到指定的分区</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">Consumers 从broker读取数据。Consumers 订阅一个或多个 topic，并通过pull方式从broker拉取订阅的数据</td></tr><tr><td style="text-align:center">Leader</td><td style="text-align:left">Leader是负责某个分区数据读写操作的节点。每个分区都有一个<strong>leader</strong></td></tr><tr><td style="text-align:center">Follower</td><td style="text-align:left">跟随leader操作的节点被称为follower。如果leader节点不可用，则会从所有的fellower中挑选一个作为新的leader节点。一个follower节点作为leader节点一个普通的消费者，拉取leader数据并更新自己的数据存储</td></tr></tbody></table><h3 id="kafka集群模型"><a class="markdownIt-Anchor" href="#kafka集群模型"></a> kafka集群模型</h3><p><img src="kafka-cluster.jpg" alt="kafka集群模型"><br>下面的表格描述了在上图中提到的每个组件的详细信息。</p><table><thead><tr><th style="text-align:center">组件</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">Broker</td><td style="text-align:left">Kafka集群通常使用多个Broker来实现集群的负载均衡。 Kafka brokers 是无状态的，因为它们使用 ZooKeeper 来保持它们的集群信息。 单个Kafka Broker 每秒可以处理数十万的读写请求，即使保存了TB级的数据也不会影响性能。Kafka broker leader 的选举是通过Zookeeper实现的</td></tr><tr><td style="text-align:center">ZooKeeper</td><td style="text-align:left">ZooKeeper是用来管理和协调Kafka broker 的。ZooKeeper 服务主要用来通知 producer 和 consumer 关于任何新加入Kafka集群或某个Kafka Broker宕机退出集群的消息。 根据收到Zookeeper的关于Broker的存在或失败的消息通知，然后生产者和消费者采取决定，并开始与其它Broker协调它们的任务</td></tr><tr><td style="text-align:center">Producers</td><td style="text-align:left">producer将数据推送给Broker。 当新Broker启动时，所有生产者搜索它并自动发送消息到该新Broker。 Kafka Producer不等待来自Broker的确认，并以Broker可以处理的速度发送消息</td></tr><tr><td style="text-align:center">Consumers</td><td style="text-align:left">由于 Kafka brokers 是无状态的， 因此需要Consumer来维护根据partition offset已经消费的消息数量信息。 如果 consumer 确认了一个指定消息的offset，那也就意味着 consumer 已经消费了该offset之前的所有消息。Consumer可以向Broker异步发起一个拉取消息的请求来缓存待消费的消息。consumers 也可以通过提供一个指定的offset值来回溯或跳过Partition中的消息。Consumer 消费消息的offset值是保存在ZooKeeper中的</td></tr></tbody></table><h2 id="kafka工作流程"><a class="markdownIt-Anchor" href="#kafka工作流程"></a> Kafka工作流程</h2><p>Kafka是由分裂为一个或多个partition的topic的集合。 Kafka中的partition可以认为是消息的线性排序序列，其中每个消息由它们的索引（称为offset）来标识。 Kafka集群中的所有数据是每个partition数据分区的并集。 新写入的消息写在分区的末尾，消息由消费者顺序读取。通过将消息复制到不同的Broker来提供持久性。Kafka以快速，可靠，持久，容错和零停机的方式提供基于pub-sub和队列模型的消息系统。 在这两种情况下，生产者只需将消息发送到topic，消费者可以根据自己的需要选择任何一种类型的消息传递系统。</p><h3 id="pub-sub-消息模型工作流程"><a class="markdownIt-Anchor" href="#pub-sub-消息模型工作流程"></a> Pub-Sub 消息模型工作流程</h3><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。Kafka确保所有的消息均匀分布在topic的所有partition上。<strong>如果producer发送了两条消息，并且该topic有两个partition，则每个partition会有一条消息</strong>。</li><li>Consumer 订阅指定的topic。</li><li>一旦消费者订阅了topic，Kafka将向消费者提供topic的当前offset，并且还将offset保存在Zookeeper中。</li><li>消费者将定期请求Kafka（如100 Ms）新消息。</li><li>消费者将收到消息并进行处理。</li><li>一旦消息被处理，消费者将向Kafka broker发送确认。</li><li>一旦Kafka收到确认，它将offset更改为新值，并在Zookeeper中更新它。 由于offset在Zookeeper中被维护，消费者可以正确地读取下一条消息，即使服务器宕机后重启。</li><li>以上流程将重复，直到消费者停止请求。</li><li>消费者可以随时回退/跳转到某个topic的期望offset处，并读取所有后续消息。</li></ul><h3 id="队列消息模型工作流程-consumer-group"><a class="markdownIt-Anchor" href="#队列消息模型工作流程-consumer-group"></a> 队列消息模型工作流程 &amp; Consumer Group</h3><p>在基于队列的消息系统中，取代单个消费者的是订阅了相同topic的一群拥有相同Group ID的消费者集群。简单来说，订阅具有相同“组ID”的主题的消费者被认为是单个组，并且消息在它们之间共享。</p><ul><li>生产者定期向topic发送消息。</li><li>Kafka broker 根据配置将topic的消息存储到指定的partition上。</li><li>单个consumer以名为Group-1的Group ID 订阅名为Topic-01的topic。</li><li>Kafka 会以和Pub-Sub消息模型相同的方式和consumer进行交互直到新的消费者以同样的Group ID加入到消费者分组中。</li><li>一旦新的消费者加入后，Kafka将操作切换到共享模式，将所有topic的消息在两个消费者间进行均衡消费。这种共享行为直到加入的消费者结点数目达到该topic的分区数。</li><li>一旦消费者的数目大于topic的分区数，则新的消费者不会收到任何消息直到已经存在的消费者取消订阅。出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。</li><li>该功能被称为 “Consumer Group”。以同样的方式，Kafka将以非常简单和高效的方式提供这两种系统功能。</li></ul><h2 id="kafka-消息的语义"><a class="markdownIt-Anchor" href="#kafka-消息的语义"></a> kafka 消息的语义</h2><ol><li>消息系统系统一般有以下的语义：<ul><li>At most once：消息可能丢失，但不会重复投递</li><li>At least once：消息不会丢失，但可能会重复投递</li><li>Exactly once：消息不丢失、不重复，会且只会被分发一次（真正想要的）</li></ul></li><li>Producer 发送消息以后，有一个commit的概念，如果commit成功，则意味着消息不会丢失，但是Producer有可能提交成功后，没有收到commit的消息。这有可能造成 at least once 语义。</li><li>从 Consumer 角度来看，我们知道 Offset 是由 Consumer 自己维护。所以何时更新 Offset 就决定了 Consumer 的语义。如果收到消息后更新 Offset，如果 Consumer crash，那新的 Cunsumer再次重启消费，就会造成 At most once 语义（消息会丢，但不重复）。</li><li>如果 Consumser 消费完成后，再更新 Offset。如果 Consumer crash，别的 Consumer 重新用这个 Offser 拉取消息，这个时候就会造成 at least once 的语义（消息不丢，但多次被处理）。</li></ol><p>所以结论：默认Kafka提供at-least-once语义的消息分发，允许用户通过在处理消息之前保存位置信息的方式来提供at-most-once语义。如果我们可以实现消费是幂等的，这个时候就可以认为整个系统是Exactly once的了。</p><h2 id="kafka中的partition和offset"><a class="markdownIt-Anchor" href="#kafka中的partition和offset"></a> kafka中的partition和offset</h2><p>说到分区，就要说kafka对消息的存储.在<a target="_blank" rel="noopener" href="http://kafka.apache.org/documentation.html#replication">官方文档</a>中。</p><p><img src="kafka_partition_log.jpg" alt="分区读写日志图"></p><p>首先，kafka是通过log(日志)来记录消息发布的.每当产生一个消息，kafka会记录到本地的log文件中，这个log和我们平时的log有一定的区别.这里可以参考一下<a target="_blank" rel="noopener" href="http://www.cnblogs.com/foreach-break/p/notes_about_distributed_system_and_The_log.html">The Log</a>。</p><h3 id="分区partition"><a class="markdownIt-Anchor" href="#分区partition"></a> 分区partition</h3><p>kafka是为分布式环境设计的，因此如果日志文件，其实也可以理解成消息数据库，放在同一个地方，那么必然会带来可用性的下降，一挂全挂，如果全量拷贝到所有的机器上，那么数据又存在过多的冗余，而且由于每台机器的磁盘大小是有限的，所以即使有再多的机器，可处理的消息还是被磁盘所限制，无法超越当前磁盘大小，因此有了partition的概念。</p><p>kafka对消息进行一定的计算，通过hash来进行分区。这样，就把一份log文件分成了多份。如上面的分区读写日志图，分成多份以后，在单台broker上，比如快速上手中，如果新建topic的时候，我们选择了–replication-factor 1 --partitions 2，那么在log目录里，我们会看到test-0目录和test-1目录.就是两个分区了。</p><h3 id="偏移offset"><a class="markdownIt-Anchor" href="#偏移offset"></a> 偏移offset</h3><p>分区就是一个有序的，不可变的消息队列。新来的commit log持续往后面加数据。这些消息被分配了一个下标(或者偏移)，就是offset，用来定位这一条消息。</p><p>消费者消费到了哪条消息，是保持在消费者这一端的。消息者也可以控制，消费者可以在本地保存最后消息的offset，并间歇性的向zookeeper注册offset，也可以重置offset。</p><p>partition存储的时候，又分成了多个segment(段)，然后通过一个index，索引，来标识第几段。这里先可以去看一下本地log目录的分区文件夹。例如，test-0，这个分区里面，会有一个index文件和一个log文件：<br><img src="kafka_index_log.jpg" alt="index和log"></p><p>对于某个指定的分区，假设每5个消息，作为一个段大小，当产生了10条消息的情况想，目前有会得到：<br>0.index (表示这里index是对0-4做的索引)<br>5.index (表示这里index是对5-9做的索引)<br>10.index (表示这里index是对10-15做的索引，目前还没满)<br>和<br>0.log<br>5.log<br>10.log<br>，当消费者需要读取offset=8的时候，首先kafka对index文件列表进行二分查找，可以算出，应该是在5。index对应的log文件中，然后对对应的5.log文件，进行顺序查找：<br>5-&gt;6-&gt;7-&gt;8，直到顺序找到8就好了。</p><h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2><ol><li><p><a target="_blank" rel="noopener" href="https://leokongwq.github.io/2017/02/06/mq-kafka-tutorial.html">kafka入门教程</a></p></li><li><p><a target="_blank" rel="noopener" href="http://leaver.me/2015/09/04/kafka%E4%B8%AD%E7%9A%84partition%E5%92%8Coffset/">kafka中的partition和offset</a></p></li></ol></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-03-02T03:39:20.000Z" title="2018-03-02T03:39:20.000Z">2018-03-02</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">15 分钟读完 (大约2295个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/03/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/">微服务实践中的一些思考</a></h1><div class="content"><h1 id="微服务实践中的一些思考"><a class="markdownIt-Anchor" href="#微服务实践中的一些思考"></a> 微服务实践中的一些思考</h1><h2 id="微服务的目的"><a class="markdownIt-Anchor" href="#微服务的目的"></a> 微服务的目的</h2><p>微服务架构由SOA架构演变而来，SOA是怎样的一种架构，这里不再重复。简单的说微服务与SOA的区别，即微服务不再强调SOA架构里面比较重的ESB工业服务总线，同时强调单个业务系统内部实现真正的组件化。ESB的中心化带来了单点故障隐患；服务统一在ESB上进行部署，也限制了服务的水平扩展，不利于提升性能；此外ESB还包含很多业务相关的功能，如业务流程编排等，限制了业务扩展的灵活性。</p><p>业务的复杂度会随着人们日益增长需求而增长，但每个人能够认知的复杂度都是有限的，在面对高复杂度的时候我们会做关注点分离，这是一个最基本的哲学原则。显然在针对复杂业务场景进行建模时，我们也会应用此原则。这个时候去分离关注点一般可以从两个维度出发：</p><ul><li>技术维度分离，采用类似MVC这样的分层思想进行层次的划分。</li><li>业务维度分离，根据不同的业态划分系统，比如按售前、销售、售后划分。</li></ul><p>以上两个维度没有孰优孰劣之分，在处理复杂问题的时候一定都会用上，SOA时代的ESB（工业服务总线）就是一个典型的技术关注点分离出来的中间件。ESB里面封装了大量的业务规则和流程，让ESB成为了掉入焦油坑的怪兽，成为了各种问题之源。微服务架构某种程度上解决了这些问题（但同时也带来了新的问题）。</p><ul><li>微服务是为了着追求高响应力目标而从业务视角去分离复杂度的手段之一。<br>为了能够高效响应业务的变化，微服务的架构更强调<strong>业务维度的关注点分离，来应对高复杂度</strong>。</li><li>微服务的目的是有效的拆分应用，实现敏捷开发和部署，可以使用不同的编程语言编写的。<br>微服务对应用的拆分采用术语来说，就是业务维度的分离。比如根据商品、订单拆分和部署，甚至数据库也按照这个维度进行拆分，不同的服务不同的库。</li><li>微服务是去ESB、去中心化、分布式的。</li><li>微服务是自洽的。<br>自洽实际上意味着我们的每一个微服务都是一个独立的个体，就像峰群中的蜜蜂一样，他们能单独维护，单独迭代，单独部署，单独测试，单独发布。</li></ul><h2 id="微服务的实践"><a class="markdownIt-Anchor" href="#微服务的实践"></a> 微服务的实践</h2><h3 id="去中心"><a class="markdownIt-Anchor" href="#去中心"></a> 去中心</h3><p>国内进行微服务架构一般会采用spring cloud或者dubbo。这两种孰优孰劣不讨论，在功能上它们有一些共性：<strong>服务治理和服务调用</strong>。为什么服务治理和服务调用成为微服务架构框架的共性呢，原因是微服务的去ESB、去中心、分布式。没有服务治理和调用，访问者不知道服务在哪儿，怎样调用。但这样一来，还是会多出一个服务发现的服务器，如spring采用的是eureka，dubbo采用的是zookeeper。</p><p>由于拆分了很多的服务，服务的配置成了问题，这又多出了提供分布式配置的服务器。</p><p>虽然多了服务发现和服务配置，但是这两个服务没有与业务耦合，从业务的角度确实分离了复杂度。</p><h3 id="业务分离"><a class="markdownIt-Anchor" href="#业务分离"></a> 业务分离</h3><p>业务分离大概是微服务中最难的问题了，业务该怎样分，拆分到哪种力度才算合适。既要考虑产品的需求、产品的升级换代，还要考虑团队的技术能力、开发周期，此外还要考虑运维部署等问题。好的架构是进化而来的，业务分离作为架构的一部分，它也应该有个进化和演进的过程，前期可以相对力度较粗，后期再根据情况适当细化。</p><h3 id="数据一致性"><a class="markdownIt-Anchor" href="#数据一致性"></a> 数据一致性</h3><p>分布式是微服务的特性之一，但分布式在提升系统响应力的同时，带来了数据一致性的问题，而且这个问题很不好解决。像分布式事务、分布式锁都有它们各自的问题，都解决的不彻底。采用最终一致性应该是目前微服务解决数据一致性较好的方案。但实现最终一致性有时会影响用户体验，比如用户取消订单，可能涉及到退还用户优惠券等，采用最终一致性的话，可能出现订单已经取消但优惠券还买有退还到账，用户立即继续购买却没有优惠券可用的情况。</p><p>实现最终一致性一般会用到MQ或者kafka等分布式发布订阅消息系统，它们用来解耦服务之间的调用（主要是用于通知）。比如上面的用户取消订单，订单服务需要通知优惠券服务有优惠券需要退还了。由于消息系统一般是异步的，所以出现了上面体验的问题。当然也可以改成同步，但这样就失去了服务拆分的意义了。</p><h3 id="自洽性"><a class="markdownIt-Anchor" href="#自洽性"></a> 自洽性</h3><p>自洽性要求每个微服务都是独立的个体，相互之间没有没有依赖。但是在实践过程中，很难做到这点。比如在电商微服务中要推送消息，消息的来源有些是订单服务，有些是商品服务，接收方是用户，这样就出现了订单服务可能需要访问用户服务的情况，服务之间形成了依赖。解决的方法通过MQ或者Kafka等消息中间件进行解耦。但是这样一来似乎又多了一个中心，和“去中心”就矛盾了。</p><h2 id="微服务的问题"><a class="markdownIt-Anchor" href="#微服务的问题"></a> 微服务的问题</h2><p>在微服务的实践过程中，如上文所述已经暴露出了一些问题。此外，为了支撑微服务，还增加很多的新的模块或服务，例如：服务发现、服务配置、熔断、日志跟踪、API网关等。增加的服务也就成为了微服务的问题。不过，它们只是在技术的维度增加了复杂度，在业务的维度是降低了复杂度。角度不同，结果也就不同。</p><p>上面提及的问题虽然也提出了方案可以解决，但是并觉得不够优雅，这是否与微服务无关，与采用的框架有关？像spring，把“行为”（也称为逻辑、过程）和“状态”（可理解为数据）分离到不同的对象之中，只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object），而那个只有行为的对象就是我们常用的分层架构中的Logic/Service层。这种开发方式称之为“贫血模型”。当然spring也不是固定就只能使用“贫血模型”做开发，但一般情况spring就是“贫血模型”。</p><p>“贫血模型”不符合<code>面对对象</code>设计的本质：“对象应该拥有状态和行为”。比如汽车，汽车有车厢和轮子这是它的状态，汽车可以开动，可以载人这是它的行为。与“贫血模型”对应的是“充血模型”举个简单的例子，设计一个与汽车（Car）相关的功能：</p><ul><li>贫血的设计一般是：类Car+类CarService 驾驶：CarService.driving(Car car);</li><li>充血的设计则可能会是：类Car 驾驶：car.driving(); Car有一个行为是：驾驶</li></ul><p>“充血模型”符合<code>面向对象</code>的设计，采用这种模型应该能够让技术更好的根据业务来建模，从而技术架构能更好的响应业务架构，使技术架构能够根据业务的变化而自发的改变。</p></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time datetime="2018-02-05T07:44:35.000Z" title="2018-02-05T07:44:35.000Z">2018-02-05</time>发表</span><span class="level-item"><time datetime="2019-05-15T02:48:47.228Z" title="2019-05-15T02:48:47.228Z">2019-05-15</time>更新</span><span class="level-item">15 分钟读完 (大约2317个字)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/02/05/hystrix%E5%9C%A8spring%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/">hystrix在spring中使用和配置</a></h1><div class="content"><h1 id="hystrix在spring中使用和配置-微服务"><a class="markdownIt-Anchor" href="#hystrix在spring中使用和配置-微服务"></a> hystrix在spring中使用和配置 - 微服务</h1><blockquote><pre><code>这篇文章是整理的一些Hystrix的经验。
</code></pre></blockquote><h2 id="hystrix启用"><a class="markdownIt-Anchor" href="#hystrix启用"></a> Hystrix启用</h2><p>在应用主类中使用 @EnableCircuitBreaker 或 @EnableHystrix 注解开启Hystrix的使用。</p><h2 id="hystrix依赖隔离"><a class="markdownIt-Anchor" href="#hystrix依赖隔离"></a> Hystrix依赖隔离</h2><ul><li>Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。</li><li>可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。</li><li>为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</li><li>依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。</li><li>提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。</li></ul><h2 id="hystrix流程"><a class="markdownIt-Anchor" href="#hystrix流程"></a> Hystrix流程</h2><p><img src="hystrix-command-flow-chart.png" alt="hystrix command flow chart"></p><p>流程说明：</p><ul><li>1:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中。</li><li>2:执行execute()/queue做同步或异步调用。</li><li>3:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤。</li><li>4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤。</li><li>5:调用HystrixCommand的run方法.运行依赖逻辑。</li><li>5a:依赖逻辑调用超时,进入步骤8。</li><li>6:判断逻辑是否调用成功。</li><li>6a:返回成功调用结果。</li><li>6b:调用出错，进入步骤8。</li><li>7:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态。</li><li>8:getFallback()降级逻辑.以下四种情况将触发getFallback调用：<ul><li>(1):run()方法抛出非HystrixBadRequestException异常</li><li>(2):run()方法调用超时</li><li>(3):熔断器开启拦截调用</li><li>(4):线程池/队列/信号量是否跑满</li></ul></li><li>8a:没有实现getFallback的Command将直接抛出异常。</li><li>8b:fallback降级逻辑调用成功直接返回。</li><li>8c:降级逻辑调用失败抛出异常。</li><li>9:返回执行成功结果。</li></ul><h2 id="hystrix服务降级"><a class="markdownIt-Anchor" href="#hystrix服务降级"></a> Hystrix服务降级</h2><p>在为具体执行逻辑的函数上增加 @HystrixCommand 注解来指定服务降级方法,例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(fallbackMethod = &quot;fallback&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://eureka-client/dc&quot;</span>, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">fallback</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fallback&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当consumer出现异常的时候，服务请求会通过HystrixCommand注解中指定的降级逻辑进行执行，因此该请求的结果返回了fallback。</p><h2 id="hystrix隔离"><a class="markdownIt-Anchor" href="#hystrix隔离"></a> Hystrix隔离</h2><p>Hystrix隔离方式采用线程/信号的方式,通过隔离限制依赖的并发量和阻塞扩散。<br>其实，我们在定义服务降级的时候，已经自动的实现了依赖隔离。</p><h2 id="hystrix熔断器-circuit-breaker"><a class="markdownIt-Anchor" href="#hystrix熔断器-circuit-breaker"></a> Hystrix熔断器 Circuit Breaker</h2><p>每个熔断器默认维护10个bucket,每秒一个bucket,每个bucket记录成功,失败,超时,拒绝的状态，默认错误超过50%且10秒内超过20个请求进行中断拦截.</p><h2 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(groupKey = &quot;productStockOpLog&quot;, commandKey = &quot;addProductStockOpLog&quot;, fallbackMethod = &quot;addProductStockOpLogFallback&quot;,</span></span><br><span class="line"><span class="meta">    commandProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;400&quot;),//指定多久超时，单位毫秒。超时进fallback</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//判断熔断的最少请求数，默认是10；只有在一个统计窗口内处理的请求数量达到这个阈值，才会进行熔断与否的判断</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;10&quot;),//判断熔断的阈值，默认值50，表示在一个统计窗口内有50%的请求处理失败，会触发熔断</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProductStockOpLog</span><span class="params">(Long sku_id, Object old_value, Object new_value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (new_value != <span class="literal">null</span> &amp;&amp; !new_value.equals(old_value)) &#123;</span><br><span class="line">        doAddOpLog(<span class="literal">null</span>, <span class="literal">null</span>, sku_id, <span class="literal">null</span>, ProductOpType.PRODUCT_STOCK, old_value != <span class="literal">null</span> ? String.valueOf(old_value) : <span class="literal">null</span>, String.valueOf(new_value), <span class="number">0</span>, <span class="string">&quot;C端&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProductStockOpLogFallback</span><span class="params">(Long sku_id, Object old_value, Object new_value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">&quot;发送商品库存变更消息失败,进入Fallback,skuId:&#123;&#125;,oldValue:&#123;&#125;,newValue:&#123;&#125;&quot;</span>, sku_id, old_value, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例2"><a class="markdownIt-Anchor" href="#例2"></a> 例2：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HystrixCommand(groupKey=&quot;UserGroup&quot;, commandKey = &quot;GetUserByIdCommand&quot;，</span></span><br><span class="line"><span class="meta">commandProperties = &#123;</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value = &quot;100&quot;),//指定多久超时，单位毫秒。超时进fallback</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;10&quot;),//判断熔断的最少请求数，默认是10；只有在一个统计窗口内处理的请求数量达到这个阈值，才会进行熔断与否的判断</span></span><br><span class="line"><span class="meta">    @HystrixProperty(name = &quot;circuitBreaker.errorThresholdPercentage&quot;, value = &quot;10&quot;),//判断熔断的阈值，默认值50，表示在一个统计窗口内有50%的请求处理失败，会触发熔断</span></span><br><span class="line"><span class="meta">&#125;,</span></span><br><span class="line"><span class="meta">threadPoolProperties = &#123;</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;coreSize&quot;, value = &quot;30&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;maxQueueSize&quot;, value = &quot;101&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;keepAliveTimeMinutes&quot;, value = &quot;2&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;queueSizeRejectionThreshold&quot;, value = &quot;15&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;metrics.rollingStats.numBuckets&quot;, value = &quot;12&quot;),</span></span><br><span class="line"><span class="meta">        @HystrixProperty(name = &quot;metrics.rollingStats.timeInMilliseconds&quot;, value = &quot;1440&quot;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>hystrix函数必须为public，fallback函数可以为private。两者需要返回值和参数相同。</li><li>参数配置：</li></ul><table><thead><tr><th style="text-align:left">参数说明</th><th style="text-align:left">值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">groupKey</td><td style="text-align:left">productStockOpLog</td><td style="text-align:left">group标识，一个group使用一个线程池</td></tr><tr><td style="text-align:left">commandKey</td><td style="text-align:left">addProductStockOpLog</td><td style="text-align:left">command标识</td></tr><tr><td style="text-align:left">fallbackMethod</td><td style="text-align:left">addProductStockOpLogFallback</td><td style="text-align:left">fallback方法，两者需要返回值和参数相同</td></tr><tr><td style="text-align:left">超时时间设置</td><td style="text-align:left">400ms</td><td style="text-align:left">执行策略，在THREAD模式下，达到超时时间，可以中断 For most circuits, you should try to set their timeout values close to the 99.5th percentile of a normal healthy system so they will cut off bad requests and not let them take up system resources or affect user behavi</td></tr><tr><td style="text-align:left">统计窗口（10s）内最少请求数</td><td style="text-align:left">10</td><td style="text-align:left">熔断策略</td></tr><tr><td style="text-align:left">熔断多少秒后去尝试请求</td><td style="text-align:left">5s</td><td style="text-align:left">熔断策略，默认值</td></tr><tr><td style="text-align:left">熔断阀值</td><td style="text-align:left">10%</td><td style="text-align:left">熔断策略：一个统计窗口内有10%的请求处理失败，会触发熔断</td></tr><tr><td style="text-align:left">线程池coreSize</td><td style="text-align:left">10</td><td style="text-align:left">默认值（推荐值）</td></tr><tr><td style="text-align:left">线程池maxQueueSize</td><td style="text-align:left">-1</td><td style="text-align:left">即线程池队列为SynchronousQueue</td></tr></tbody></table><h2 id="配置参数说明"><a class="markdownIt-Anchor" href="#配置参数说明"></a> 配置参数说明</h2><table><thead><tr><th style="text-align:left">分类</th><th style="text-align:left">参数</th><th style="text-align:left">作用</th><th style="text-align:left">默认值</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">基本参数</td><td style="text-align:left">groupKey</td><td style="text-align:left">表示所属的group，一个group共用线程池</td><td style="text-align:left">getClass().getSimpleName();</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">基本参数</td><td style="text-align:left">commandKey</td><td style="text-align:left"></td><td style="text-align:left">当前执行方法名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution （ 控制HystrixCommand.run()的执行策略）</td><td style="text-align:left">execution.isolation.strategy</td><td style="text-align:left">隔离策略，有THREAD和SEMAPHORE THREAD</td><td style="text-align:left">当前执行方法名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.thread.timeoutInMilliseconds</td><td style="text-align:left">超时时间</td><td style="text-align:left">1000ms</td><td style="text-align:left">默认值：1000 在THREAD模式下，达到超时时间，可以中断 在SEMAPHORE模式下，会等待执行完成后，再去判断是否超时 设置标准： 有retry，99meantime+avg meantime 没有retry，99.5meantime</td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.timeout.enabled</td><td style="text-align:left">是否打开超时</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.thread.interruptOnTimeout</td><td style="text-align:left">是否打开超时线程中断</td><td style="text-align:left">true</td><td style="text-align:left">THREAD模式有效</td></tr><tr><td style="text-align:left">Execution</td><td style="text-align:left">execution.isolation.semaphore.maxConcurrentRequests</td><td style="text-align:left">信号量最大并发度</td><td style="text-align:left">10</td><td style="text-align:left">SEMAPHORE模式有效</td></tr><tr><td style="text-align:left">Fallback （ 设置当fallback降级发生时的策略）</td><td style="text-align:left">fallback.isolation.semaphore.maxConcurrentRequests</td><td style="text-align:left">fallback最大并发度</td><td style="text-align:left">10</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Fallback</td><td style="text-align:left">fallback.enabled</td><td style="text-align:left">fallback是否可用</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker （配置熔断的策略）</td><td style="text-align:left">circuitBreaker.enabled</td><td style="text-align:left">是否开启熔断</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.requestVolumeThreshold</td><td style="text-align:left">一个统计窗口内熔断触发的最小个数/10s</td><td style="text-align:left">20</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.sleepWindowInMilliseconds</td><td style="text-align:left">熔断多少秒后去尝试请求</td><td style="text-align:left">5000ms</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.errorThresholdPercentage</td><td style="text-align:left">失败率达到多少百分比后熔断</td><td style="text-align:left">50</td><td style="text-align:left">主要根据依赖重要性进行调整</td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.forceOpen</td><td style="text-align:left">是否强制开启熔断</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Circuit Breaker</td><td style="text-align:left">circuitBreaker.forceClosed</td><td style="text-align:left">是否强制关闭熔断</td><td style="text-align:left"></td><td style="text-align:left">如果是强依赖，应该设置为true</td></tr><tr><td style="text-align:left">Metrics （设置关于HystrixCommand执行需要的统计信息）</td><td style="text-align:left">metrics.rollingStats.timeInMilliseconds</td><td style="text-align:left">设置统计滚动窗口的长度，以毫秒为单位。用于监控和熔断器</td><td style="text-align:left">10000</td><td style="text-align:left">滚动窗口被分隔成桶(bucket)，并且进行滚动。 例如这个属性设置10s(10000)，一个桶是1s</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingStats.numBuckets</td><td style="text-align:left">设置统计窗口的桶数量</td><td style="text-align:left">10</td><td style="text-align:left">metrics.rollingStats.timeInMilliseconds必须能被这个值整除</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.enabled</td><td style="text-align:left">设置执行时间是否被跟踪，并且计算各个百分比，50%,90%等的时间</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.timeInMilliseconds</td><td style="text-align:left">设置执行时间在滚动窗口中保留时间，用来计算百分比</td><td style="text-align:left">60000ms</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.numBuckets</td><td style="text-align:left">设置rollingPercentile窗口的桶数量</td><td style="text-align:left">6</td><td style="text-align:left">metrics.rollingPercentile.timeInMilliseconds必须能被这个值整除</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.rollingPercentile.bucketSize</td><td style="text-align:left">metrics.rollingPercentile.bucketSize</td><td style="text-align:left">100</td><td style="text-align:left">如果设置为100，但是有500次求情，则只会计算最近的100次</td></tr><tr><td style="text-align:left">Metrics</td><td style="text-align:left">metrics.healthSnapshot.intervalInMilliseconds</td><td style="text-align:left">采样时间间隔</td><td style="text-align:left">500</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Request Context ( 设置HystrixCommand使用的HystrixRequestContext相关的属性)</td><td style="text-align:left">requestCache.enabled</td><td style="text-align:left">设置是否缓存请求，request-scope内缓存</td><td style="text-align:left">true</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Request Context</td><td style="text-align:left">requestLog.enabled</td><td style="text-align:left">设置HystrixCommand执行和事件是否打印到HystrixRequestLog中</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">ThreadPool Properties(配置HystrixCommand使用的线程池的属性)</td><td style="text-align:left">coreSize</td><td style="text-align:left">设置线程池的core size,这是最大的并发执行数量</td><td style="text-align:left">10</td><td style="text-align:left">设置标准：coreSize = requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room 大多数情况下默认的10个线程都是值得建议的</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">maxQueueSize</td><td style="text-align:left">最大队列长度。设置BlockingQueue的最大长度</td><td style="text-align:left">-1</td><td style="text-align:left">默认值：-1 如果使用正数，队列将从SynchronousQueue改为LinkedBlockingQueue</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">queueSizeRejectionThreshold</td><td style="text-align:left">设置拒绝请求的临界值</td><td style="text-align:left">5</td><td style="text-align:left">此属性不适用于maxQueueSize = - 1时 设置设个值的原因是maxQueueSize值运行时不能改变，我们可以通过修改这个变量动态修改允许排队的长度</td></tr><tr><td style="text-align:left">ThreadPool Properties</td><td style="text-align:left">keepAliveTimeMinutes</td><td style="text-align:left">设置keep-live时间</td><td style="text-align:left">1分钟</td><td style="text-align:left">这个一般用不到因为默认corePoolSize和maxPoolSize是一样的</td></tr></tbody></table><h3 id="hystrix官方文档"><a class="markdownIt-Anchor" href="#hystrix官方文档"></a> Hystrix官方文档</h3><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">https://github.com/Netflix/Hystrix/wiki</a></p></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-2-widescreen order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="gspark"></figure><p class="title is-size-4 is-block" style="line-height:inherit">gspark</p><p class="is-size-6 is-block">厚德载物</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">50</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">13</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://gspark.github.io" target="_blank" rel="noopener">关注我</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://github.com" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">github</span></span><span class="level-right"><span class="level-item tag">github.com</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time datetime="2024-11-16T06:57:52.000Z">2024-11-16</time></p><p class="title"><a href="/2024/11/16/charles%E6%89%8B%E6%9C%BA%E7%AB%AF%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AEchls-pro-ssl%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">charles手机端无法访问chls.pro/ssl解决方案</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2024-10-28T06:32:17.000Z">2024-10-28</time></p><p class="title"><a href="/2024/10/28/win10%E7%BC%96%E8%AF%91ffmpeg7/">win10编译ffmpeg7</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-04-13T11:43:41.000Z">2023-04-13</time></p><p class="title"><a href="/2023/04/13/aop%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%85%A5%E5%BA%93-AfterThrowing%E8%B0%83%E7%94%A8%E6%AD%A3%E5%B8%B8%EF%BC%8C%E6%95%B0%E6%8D%AE%E6%9C%AA%E6%8F%90%E4%BA%A4/">aop实现日志入库@AfterThrowing调用正常，数据未提交</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-03-14T06:17:23.000Z">2023-03-14</time></p><p class="title"><a href="/2023/03/14/visual-studio-C++%E5%B7%A5%E7%A8%8B.vs%E6%96%87%E4%BB%B6%E5%A4%B9%E8%BF%87%E5%A4%A7/">visual studio C++工程.vs文件夹过大</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time datetime="2023-02-03T07:32:14.000Z">2023-02-03</time></p><p class="title"><a href="/2023/02/03/oracle%E5%88%97%E8%A1%A8%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%95%B0%E4%B8%BA1000%EF%BC%8Cmybaits%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">oracle列表中最大表达式数为1000，mybaits解决方案</a></p></div></article></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-2-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/11/"><span class="level-start"><span class="level-item">十一月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/10/"><span class="level-start"><span class="level-item">十月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/04/"><span class="level-start"><span class="level-item">四月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/03/"><span class="level-start"><span class="level-item">三月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/02/"><span class="level-start"><span class="level-item">二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/11/"><span class="level-start"><span class="level-item">十一月 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">十月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">十一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/06/"><span class="level-start"><span class="level-item">六月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/05/"><span class="level-start"><span class="level-item">五月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/12/"><span class="level-start"><span class="level-item">十二月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/08/"><span class="level-start"><span class="level-item">八月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/07/"><span class="level-start"><span class="level-item">七月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/09/"><span class="level-start"><span class="level-item">九月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/08/"><span class="level-start"><span class="level-item">八月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/07/"><span class="level-start"><span class="level-item">七月 2018</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/04/"><span class="level-start"><span class="level-item">四月 2018</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/03/"><span class="level-start"><span class="level-item">三月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2018/02/"><span class="level-start"><span class="level-item">二月 2018</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NIO/"><span class="tag">NIO</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/c/"><span class="tag">c++</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cache/"><span class="tag">cache</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/go/"><span class="tag">go</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/microservice/"><span class="tag">microservice</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mybatis/"><span class="tag">mybatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/software/"><span class="tag">software</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag">1</span></a></div></div></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">gspark&#039;s blog</a><p class="is-size-7"><span>&copy; 2024 gspark</span>  飞流直下三千尺，疑是银河落九天</p></div><div class="level-end"></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><script src="/js/main.js" defer></script></body></html>